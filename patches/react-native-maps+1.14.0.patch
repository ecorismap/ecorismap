diff --git a/node_modules/react-native-maps/.DS_Store b/node_modules/react-native-maps/.DS_Store
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/react-native-maps/android/build.gradle b/node_modules/react-native-maps/android/build.gradle
index cc44531..e37b068 100644
--- a/node_modules/react-native-maps/android/build.gradle
+++ b/node_modules/react-native-maps/android/build.gradle
@@ -56,6 +56,7 @@ repositories {
     // Android JSC is installed from npm
     url "$rootDir/../node_modules/jsc-android/dist"
   }
+
   google()
 }
 
@@ -66,4 +67,6 @@ dependencies {
   implementation "com.google.android.gms:play-services-location:21.0.1"
   implementation 'com.google.maps.android:android-maps-utils:3.8.2'
   implementation "androidx.work:work-runtime:2.7.1"
+  implementation 'com.google.protobuf:protobuf-javalite:3.21.11'
+  implementation 'com.google.code.gson:gson:2.8.8'
 }
diff --git a/node_modules/react-native-maps/android/build/.transforms/2f398fa146c85afae99e8b5a12023d69/results.bin b/node_modules/react-native-maps/android/build/.transforms/2f398fa146c85afae99e8b5a12023d69/results.bin
new file mode 100644
index 0000000..0d259dd
--- /dev/null
+++ b/node_modules/react-native-maps/android/build/.transforms/2f398fa146c85afae99e8b5a12023d69/results.bin
@@ -0,0 +1 @@
+o/classes
diff --git a/node_modules/react-native-maps/android/build/.transforms/2f398fa146c85afae99e8b5a12023d69/transformed/classes/classes_dex/classes.dex b/node_modules/react-native-maps/android/build/.transforms/2f398fa146c85afae99e8b5a12023d69/transformed/classes/classes_dex/classes.dex
new file mode 100644
index 0000000..597b200
Binary files /dev/null and b/node_modules/react-native-maps/android/build/.transforms/2f398fa146c85afae99e8b5a12023d69/transformed/classes/classes_dex/classes.dex differ
diff --git a/node_modules/react-native-maps/android/build/generated/source/buildConfig/debug/com/rnmaps/maps/BuildConfig.java b/node_modules/react-native-maps/android/build/generated/source/buildConfig/debug/com/rnmaps/maps/BuildConfig.java
new file mode 100644
index 0000000..845e2d9
--- /dev/null
+++ b/node_modules/react-native-maps/android/build/generated/source/buildConfig/debug/com/rnmaps/maps/BuildConfig.java
@@ -0,0 +1,12 @@
+/**
+ * Automatically generated file. DO NOT MODIFY
+ */
+package com.rnmaps.maps;
+
+public final class BuildConfig {
+  public static final boolean DEBUG = Boolean.parseBoolean("true");
+  public static final String LIBRARY_PACKAGE_NAME = "com.rnmaps.maps";
+  public static final String BUILD_TYPE = "debug";
+  // Field from default config.
+  public static final boolean IS_NEW_ARCHITECTURE_ENABLED = false;
+}
diff --git a/node_modules/react-native-maps/android/build/intermediates/aapt_friendly_merged_manifests/debug/aapt/AndroidManifest.xml b/node_modules/react-native-maps/android/build/intermediates/aapt_friendly_merged_manifests/debug/aapt/AndroidManifest.xml
new file mode 100644
index 0000000..43b609f
--- /dev/null
+++ b/node_modules/react-native-maps/android/build/intermediates/aapt_friendly_merged_manifests/debug/aapt/AndroidManifest.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.rnmaps.maps" >
+
+    <uses-sdk android:minSdkVersion="23" />
+
+</manifest>
\ No newline at end of file
diff --git a/node_modules/react-native-maps/android/build/intermediates/aapt_friendly_merged_manifests/debug/aapt/output-metadata.json b/node_modules/react-native-maps/android/build/intermediates/aapt_friendly_merged_manifests/debug/aapt/output-metadata.json
new file mode 100644
index 0000000..578d892
--- /dev/null
+++ b/node_modules/react-native-maps/android/build/intermediates/aapt_friendly_merged_manifests/debug/aapt/output-metadata.json
@@ -0,0 +1,18 @@
+{
+  "version": 3,
+  "artifactType": {
+    "type": "AAPT_FRIENDLY_MERGED_MANIFESTS",
+    "kind": "Directory"
+  },
+  "applicationId": "com.rnmaps.maps",
+  "variantName": "debug",
+  "elements": [
+    {
+      "type": "SINGLE",
+      "filters": [],
+      "attributes": [],
+      "outputFile": "AndroidManifest.xml"
+    }
+  ],
+  "elementType": "File"
+}
\ No newline at end of file
diff --git a/node_modules/react-native-maps/android/build/intermediates/aar_metadata/debug/aar-metadata.properties b/node_modules/react-native-maps/android/build/intermediates/aar_metadata/debug/aar-metadata.properties
new file mode 100644
index 0000000..1211b1e
--- /dev/null
+++ b/node_modules/react-native-maps/android/build/intermediates/aar_metadata/debug/aar-metadata.properties
@@ -0,0 +1,6 @@
+aarFormatVersion=1.0
+aarMetadataVersion=1.0
+minCompileSdk=1
+minCompileSdkExtension=0
+minAndroidGradlePluginVersion=1.0.0
+coreLibraryDesugaringEnabled=false
diff --git a/node_modules/react-native-maps/android/build/intermediates/annotation_processor_list/debug/annotationProcessors.json b/node_modules/react-native-maps/android/build/intermediates/annotation_processor_list/debug/annotationProcessors.json
new file mode 100644
index 0000000..9e26dfe
--- /dev/null
+++ b/node_modules/react-native-maps/android/build/intermediates/annotation_processor_list/debug/annotationProcessors.json
@@ -0,0 +1 @@
+{}
\ No newline at end of file
diff --git a/node_modules/react-native-maps/android/build/intermediates/compile_library_classes_jar/debug/classes.jar b/node_modules/react-native-maps/android/build/intermediates/compile_library_classes_jar/debug/classes.jar
new file mode 100644
index 0000000..bf3f7fa
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/compile_library_classes_jar/debug/classes.jar differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/compile_r_class_jar/debug/R.jar b/node_modules/react-native-maps/android/build/intermediates/compile_r_class_jar/debug/R.jar
new file mode 100644
index 0000000..588cd91
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/compile_r_class_jar/debug/R.jar differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/compile_symbol_list/debug/R.txt b/node_modules/react-native-maps/android/build/intermediates/compile_symbol_list/debug/R.txt
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/react-native-maps/android/build/intermediates/incremental/debug/packageDebugResources/compile-file-map.properties b/node_modules/react-native-maps/android/build/intermediates/incremental/debug/packageDebugResources/compile-file-map.properties
new file mode 100644
index 0000000..2b35095
--- /dev/null
+++ b/node_modules/react-native-maps/android/build/intermediates/incremental/debug/packageDebugResources/compile-file-map.properties
@@ -0,0 +1 @@
+#Wed Jun 25 18:09:59 JST 2025
diff --git a/node_modules/react-native-maps/android/build/intermediates/incremental/debug/packageDebugResources/merger.xml b/node_modules/react-native-maps/android/build/intermediates/incremental/debug/packageDebugResources/merger.xml
new file mode 100644
index 0000000..a3bedc4
--- /dev/null
+++ b/node_modules/react-native-maps/android/build/intermediates/incremental/debug/packageDebugResources/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="main$Generated" generated="true" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Users/mizutani/prg/ecorismap/ecorismap/node_modules/react-native-maps/android/src/main/res"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="main" generated-set="main$Generated" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Users/mizutani/prg/ecorismap/ecorismap/node_modules/react-native-maps/android/src/main/res"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="debug$Generated" generated="true" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Users/mizutani/prg/ecorismap/ecorismap/node_modules/react-native-maps/android/src/debug/res"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="debug" generated-set="debug$Generated" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Users/mizutani/prg/ecorismap/ecorismap/node_modules/react-native-maps/android/src/debug/res"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="generated$Generated" generated="true" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Users/mizutani/prg/ecorismap/ecorismap/node_modules/react-native-maps/android/build/generated/res/resValues/debug"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="generated" generated-set="generated$Generated" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Users/mizutani/prg/ecorismap/ecorismap/node_modules/react-native-maps/android/build/generated/res/resValues/debug"/></dataSet><mergedItems/></merger>
\ No newline at end of file
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/BufferPosition.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/BufferPosition.class
new file mode 100644
index 0000000..8e0666f
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/BufferPosition.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/Cache.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/Cache.class
new file mode 100644
index 0000000..d7452b5
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/Cache.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/Compression.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/Compression.class
new file mode 100644
index 0000000..a3ccea2
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/Compression.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/Decompress.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/Decompress.class
new file mode 100644
index 0000000..2ab8bfe
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/Decompress.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/DecompressFunc.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/DecompressFunc.class
new file mode 100644
index 0000000..c902801
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/DecompressFunc.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/Entry.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/Entry.class
new file mode 100644
index 0000000..3c6cf5f
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/Entry.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/EtagMismatch.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/EtagMismatch.class
new file mode 100644
index 0000000..9349c40
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/EtagMismatch.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/FetchSource.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/FetchSource.class
new file mode 100644
index 0000000..e1912a8
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/FetchSource.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/Header.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/Header.class
new file mode 100644
index 0000000..be3c34c
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/Header.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/Metadata.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/Metadata.class
new file mode 100644
index 0000000..f2f453b
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/Metadata.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/PMTiles.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/PMTiles.class
new file mode 100644
index 0000000..3083629
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/PMTiles.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/PMTilesUtils.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/PMTilesUtils.class
new file mode 100644
index 0000000..ec6dc28
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/PMTilesUtils.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/RangeResponse.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/RangeResponse.class
new file mode 100644
index 0000000..81bd6c7
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/RangeResponse.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/RootDirData.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/RootDirData.class
new file mode 100644
index 0000000..66315fd
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/RootDirData.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/SharedPromiseCache.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/SharedPromiseCache.class
new file mode 100644
index 0000000..27779e2
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/SharedPromiseCache.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/SharedPromiseCacheValue.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/SharedPromiseCacheValue.class
new file mode 100644
index 0000000..0969ecb
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/SharedPromiseCacheValue.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/Source.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/Source.class
new file mode 100644
index 0000000..2e49c92
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/Source.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/TileType.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/TileType.class
new file mode 100644
index 0000000..9e81c16
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/TileType.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/VectorLayer.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/VectorLayer.class
new file mode 100644
index 0000000..ab3cbb6
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/PMTiles/VectorLayer.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/VectorTileStyle/LayerStyle.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/VectorTileStyle/LayerStyle.class
new file mode 100644
index 0000000..1f2366d
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/VectorTileStyle/LayerStyle.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/VectorTileStyle/LayoutStyle.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/VectorTileStyle/LayoutStyle.class
new file mode 100644
index 0000000..ebd6723
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/VectorTileStyle/LayoutStyle.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/VectorTileStyle/PaintStyle.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/VectorTileStyle/PaintStyle.class
new file mode 100644
index 0000000..cba99f1
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/VectorTileStyle/PaintStyle.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/VectorTileStyle/VectorStyle.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/VectorTileStyle/VectorStyle.class
new file mode 100644
index 0000000..79f1765
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/VectorTileStyle/VectorStyle.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/VectorTileStyleManager/VectorTileStyleManager$1.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/VectorTileStyleManager/VectorTileStyleManager$1.class
new file mode 100644
index 0000000..a12e997
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/VectorTileStyleManager/VectorTileStyleManager$1.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/VectorTileStyleManager/VectorTileStyleManager$2.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/VectorTileStyleManager/VectorTileStyleManager$2.class
new file mode 100644
index 0000000..693909f
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/VectorTileStyleManager/VectorTileStyleManager$2.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/VectorTileStyleManager/VectorTileStyleManager.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/VectorTileStyleManager/VectorTileStyleManager.class
new file mode 100644
index 0000000..c03f221
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/VectorTileStyleManager/VectorTileStyleManager.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/BuildConfig.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/BuildConfig.class
new file mode 100644
index 0000000..f869e4a
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/BuildConfig.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/FileUtil.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/FileUtil.class
new file mode 100644
index 0000000..2ddef0c
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/FileUtil.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/FusedLocationSource$1.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/FusedLocationSource$1.class
new file mode 100644
index 0000000..dc8b8ac
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/FusedLocationSource$1.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/FusedLocationSource$2.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/FusedLocationSource$2.class
new file mode 100644
index 0000000..4794f5f
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/FusedLocationSource$2.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/FusedLocationSource.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/FusedLocationSource.class
new file mode 100644
index 0000000..db43dc5
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/FusedLocationSource.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/ImageReadable.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/ImageReadable.class
new file mode 100644
index 0000000..696cc70
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/ImageReadable.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/ImageReader$1.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/ImageReader$1.class
new file mode 100644
index 0000000..43ccaa7
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/ImageReader$1.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/ImageReader.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/ImageReader.class
new file mode 100644
index 0000000..9490744
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/ImageReader.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/ImageUtil.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/ImageUtil.class
new file mode 100644
index 0000000..23b41bc
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/ImageUtil.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/LatLngBoundsUtils.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/LatLngBoundsUtils.class
new file mode 100644
index 0000000..c0e7aa9
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/LatLngBoundsUtils.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapCallout.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapCallout.class
new file mode 100644
index 0000000..5312da6
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapCallout.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapCalloutManager.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapCalloutManager.class
new file mode 100644
index 0000000..84b5ed7
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapCalloutManager.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapCircle.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapCircle.class
new file mode 100644
index 0000000..e76b618
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapCircle.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapCircleManager.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapCircleManager.class
new file mode 100644
index 0000000..e402cb2
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapCircleManager.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapDEMTileProvider$1.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapDEMTileProvider$1.class
new file mode 100644
index 0000000..a0daddd
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapDEMTileProvider$1.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapDEMTileProvider.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapDEMTileProvider.class
new file mode 100644
index 0000000..e5a7f2e
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapDEMTileProvider.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapFeature.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapFeature.class
new file mode 100644
index 0000000..1753e54
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapFeature.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapGradientPolyline$AirMapGradientPolylineProvider.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapGradientPolyline$AirMapGradientPolylineProvider.class
new file mode 100644
index 0000000..18cb525
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapGradientPolyline$AirMapGradientPolylineProvider.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapGradientPolyline$MutPoint.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapGradientPolyline$MutPoint.class
new file mode 100644
index 0000000..0a166ce
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapGradientPolyline$MutPoint.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapGradientPolyline.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapGradientPolyline.class
new file mode 100644
index 0000000..0b8bc6e
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapGradientPolyline.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapGradientPolylineManager.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapGradientPolylineManager.class
new file mode 100644
index 0000000..b77919f
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapGradientPolylineManager.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapHeatmap.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapHeatmap.class
new file mode 100644
index 0000000..499244e
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapHeatmap.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapHeatmapManager.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapHeatmapManager.class
new file mode 100644
index 0000000..1609b2d
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapHeatmapManager.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapLocalTile$AIRMapLocalTileProvider.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapLocalTile$AIRMapLocalTileProvider.class
new file mode 100644
index 0000000..bbf9445
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapLocalTile$AIRMapLocalTileProvider.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapLocalTile.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapLocalTile.class
new file mode 100644
index 0000000..e9f8b1e
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapLocalTile.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapLocalTileManager.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapLocalTileManager.class
new file mode 100644
index 0000000..210202e
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapLocalTileManager.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapManager.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapManager.class
new file mode 100644
index 0000000..4d2ed93
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapManager.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapMarker$1.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapMarker$1.class
new file mode 100644
index 0000000..bba1e68
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapMarker$1.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapMarker$2.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapMarker$2.class
new file mode 100644
index 0000000..7b59afd
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapMarker$2.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapMarker.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapMarker.class
new file mode 100644
index 0000000..92e4f3a
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapMarker.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapMarkerManager$AirMapMarkerSharedIcon.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapMarkerManager$AirMapMarkerSharedIcon.class
new file mode 100644
index 0000000..1af3452
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapMarkerManager$AirMapMarkerSharedIcon.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapMarkerManager.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapMarkerManager.class
new file mode 100644
index 0000000..5afc495
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapMarkerManager.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule$1$1.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule$1$1.class
new file mode 100644
index 0000000..73dc73a
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule$1$1.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule$1.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule$1.class
new file mode 100644
index 0000000..55af0dd
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule$1.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule$2.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule$2.class
new file mode 100644
index 0000000..5ee8eb5
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule$2.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule$3.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule$3.class
new file mode 100644
index 0000000..b23fcb5
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule$3.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule$4.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule$4.class
new file mode 100644
index 0000000..0de9de5
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule$4.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule$5.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule$5.class
new file mode 100644
index 0000000..ff71d50
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule$5.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule$6.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule$6.class
new file mode 100644
index 0000000..0d10a90
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule$6.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule.class
new file mode 100644
index 0000000..a860330
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapModule.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapOverlay.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapOverlay.class
new file mode 100644
index 0000000..4a0af12
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapOverlay.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapOverlayManager.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapOverlayManager.class
new file mode 100644
index 0000000..14c7202
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapOverlayManager.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTile.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTile.class
new file mode 100644
index 0000000..d299c2d
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTile.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTileManager.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTileManager.class
new file mode 100644
index 0000000..0d0d78c
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTileManager.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTileProvider$FeatureData.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTileProvider$FeatureData.class
new file mode 100644
index 0000000..a3d058b
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTileProvider$FeatureData.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTileProvider$LineData.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTileProvider$LineData.class
new file mode 100644
index 0000000..3960e5c
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTileProvider$LineData.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTileProvider$PointData.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTileProvider$PointData.class
new file mode 100644
index 0000000..0fb6420
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTileProvider$PointData.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTileProvider$PolygonData.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTileProvider$PolygonData.class
new file mode 100644
index 0000000..0a1067e
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTileProvider$PolygonData.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTileProvider$VectorSource.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTileProvider$VectorSource.class
new file mode 100644
index 0000000..daf8cd1
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTileProvider$VectorSource.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTileProvider.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTileProvider.class
new file mode 100644
index 0000000..80066b7
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPMTileProvider.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPolygon.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPolygon.class
new file mode 100644
index 0000000..2cd2c81
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPolygon.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPolygonManager.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPolygonManager.class
new file mode 100644
index 0000000..aaf30b2
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPolygonManager.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPolyline.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPolyline.class
new file mode 100644
index 0000000..9752dd6
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPolyline.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPolylineManager.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPolylineManager.class
new file mode 100644
index 0000000..8dec163
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapPolylineManager.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapTileProvider$AIRMapUrlTileProvider.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapTileProvider$AIRMapUrlTileProvider.class
new file mode 100644
index 0000000..74a61a3
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapTileProvider$AIRMapUrlTileProvider.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapTileProvider.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapTileProvider.class
new file mode 100644
index 0000000..b2169a6
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapTileProvider.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapTileWorker.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapTileWorker.class
new file mode 100644
index 0000000..408ff57
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapTileWorker.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapUrlTile$1.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapUrlTile$1.class
new file mode 100644
index 0000000..6f3e3b8
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapUrlTile$1.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapUrlTile$2.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapUrlTile$2.class
new file mode 100644
index 0000000..6aeb0d9
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapUrlTile$2.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapUrlTile$3.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapUrlTile$3.class
new file mode 100644
index 0000000..a3a8db1
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapUrlTile$3.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapUrlTile$4.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapUrlTile$4.class
new file mode 100644
index 0000000..18d59d0
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapUrlTile$4.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapUrlTile$5.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapUrlTile$5.class
new file mode 100644
index 0000000..1bc04d2
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapUrlTile$5.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapUrlTile.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapUrlTile.class
new file mode 100644
index 0000000..966d1a8
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapUrlTile.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapUrlTileManager.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapUrlTileManager.class
new file mode 100644
index 0000000..e4fd21f
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapUrlTileManager.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$1.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$1.class
new file mode 100644
index 0000000..4c5b056
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$1.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$10.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$10.class
new file mode 100644
index 0000000..fa610c0
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$10.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$11.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$11.class
new file mode 100644
index 0000000..7b20697
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$11.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$12.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$12.class
new file mode 100644
index 0000000..5b7e4b0
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$12.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$13.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$13.class
new file mode 100644
index 0000000..77a687e
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$13.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$14.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$14.class
new file mode 100644
index 0000000..9fd0fe0
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$14.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$15.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$15.class
new file mode 100644
index 0000000..400fb54
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$15.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$16.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$16.class
new file mode 100644
index 0000000..039c7cf
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$16.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$17.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$17.class
new file mode 100644
index 0000000..97d90ee
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$17.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$2.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$2.class
new file mode 100644
index 0000000..510d918
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$2.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$3.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$3.class
new file mode 100644
index 0000000..ecea029
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$3.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$4.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$4.class
new file mode 100644
index 0000000..9d50aeb
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$4.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$5.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$5.class
new file mode 100644
index 0000000..8ab568c
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$5.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$6.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$6.class
new file mode 100644
index 0000000..5195e1a
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$6.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$7.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$7.class
new file mode 100644
index 0000000..108343d
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$7.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$8.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$8.class
new file mode 100644
index 0000000..ac81330
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$8.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$9.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$9.class
new file mode 100644
index 0000000..9081178
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView$9.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView.class
new file mode 100644
index 0000000..a95b1b6
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapView.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapWMSTile$AIRMapGSUrlTileProvider$AIRMapWMSTileProvider.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapWMSTile$AIRMapGSUrlTileProvider$AIRMapWMSTileProvider.class
new file mode 100644
index 0000000..91f29e1
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapWMSTile$AIRMapGSUrlTileProvider$AIRMapWMSTileProvider.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapWMSTile$AIRMapGSUrlTileProvider.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapWMSTile$AIRMapGSUrlTileProvider.class
new file mode 100644
index 0000000..be52547
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapWMSTile$AIRMapGSUrlTileProvider.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapWMSTile.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapWMSTile.class
new file mode 100644
index 0000000..aafe4fe
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapWMSTile.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapWMSTileManager.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapWMSTileManager.class
new file mode 100644
index 0000000..bbafb04
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapWMSTileManager.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapsPackage.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapsPackage.class
new file mode 100644
index 0000000..1c86d8e
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/MapsPackage.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/RegionChangeEvent.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/RegionChangeEvent.class
new file mode 100644
index 0000000..6663566
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/RegionChangeEvent.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/SizeReportingShadowNode.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/SizeReportingShadowNode.class
new file mode 100644
index 0000000..efbf4b1
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/SizeReportingShadowNode.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/ViewAttacherGroup.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/ViewAttacherGroup.class
new file mode 100644
index 0000000..55b7b4e
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/ViewAttacherGroup.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/ViewChangesTracker$1.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/ViewChangesTracker$1.class
new file mode 100644
index 0000000..ba59812
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/ViewChangesTracker$1.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/ViewChangesTracker.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/ViewChangesTracker.class
new file mode 100644
index 0000000..e467567
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/com/rnmaps/maps/ViewChangesTracker.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$1.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$1.class
new file mode 100644
index 0000000..2fa0748
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$1.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$Builder.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$Builder.class
new file mode 100644
index 0000000..2c246e5
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$Builder.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$Feature$Builder.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$Feature$Builder.class
new file mode 100644
index 0000000..52d373d
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$Feature$Builder.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$Feature.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$Feature.class
new file mode 100644
index 0000000..c0881d5
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$Feature.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$FeatureOrBuilder.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$FeatureOrBuilder.class
new file mode 100644
index 0000000..bfe0de5
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$FeatureOrBuilder.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$GeomType$1.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$GeomType$1.class
new file mode 100644
index 0000000..fa165e0
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$GeomType$1.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$GeomType$GeomTypeVerifier.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$GeomType$GeomTypeVerifier.class
new file mode 100644
index 0000000..661a022
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$GeomType$GeomTypeVerifier.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$GeomType.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$GeomType.class
new file mode 100644
index 0000000..593ad37
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$GeomType.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$Layer$Builder.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$Layer$Builder.class
new file mode 100644
index 0000000..86a9085
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$Layer$Builder.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$Layer.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$Layer.class
new file mode 100644
index 0000000..ada317c
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$Layer.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$LayerOrBuilder.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$LayerOrBuilder.class
new file mode 100644
index 0000000..3519291
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$LayerOrBuilder.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$Value$Builder.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$Value$Builder.class
new file mode 100644
index 0000000..1dad9b2
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$Value$Builder.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$Value.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$Value.class
new file mode 100644
index 0000000..3daf5cb
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$Value.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$ValueOrBuilder.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$ValueOrBuilder.class
new file mode 100644
index 0000000..c02eff8
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile$ValueOrBuilder.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile.class
new file mode 100644
index 0000000..ed9ad84
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$Tile.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$TileOrBuilder.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$TileOrBuilder.class
new file mode 100644
index 0000000..46f4698
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile$TileOrBuilder.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile.class b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile.class
new file mode 100644
index 0000000..cccd881
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/javac/debug/classes/vector_tile/VectorTile.class differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/local_only_symbol_list/debug/R-def.txt b/node_modules/react-native-maps/android/build/intermediates/local_only_symbol_list/debug/R-def.txt
new file mode 100644
index 0000000..78ac5b8
--- /dev/null
+++ b/node_modules/react-native-maps/android/build/intermediates/local_only_symbol_list/debug/R-def.txt
@@ -0,0 +1,2 @@
+R_DEF: Internal format may change without notice
+local
diff --git a/node_modules/react-native-maps/android/build/intermediates/manifest_merge_blame_file/debug/manifest-merger-blame-debug-report.txt b/node_modules/react-native-maps/android/build/intermediates/manifest_merge_blame_file/debug/manifest-merger-blame-debug-report.txt
new file mode 100644
index 0000000..6c2d1a9
--- /dev/null
+++ b/node_modules/react-native-maps/android/build/intermediates/manifest_merge_blame_file/debug/manifest-merger-blame-debug-report.txt
@@ -0,0 +1,7 @@
+1<?xml version="1.0" encoding="utf-8"?>
+2<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+3    package="com.rnmaps.maps" >
+4
+5    <uses-sdk android:minSdkVersion="23" />
+6
+7</manifest>
diff --git a/node_modules/react-native-maps/android/build/intermediates/merged_manifest/debug/AndroidManifest.xml b/node_modules/react-native-maps/android/build/intermediates/merged_manifest/debug/AndroidManifest.xml
new file mode 100644
index 0000000..43b609f
--- /dev/null
+++ b/node_modules/react-native-maps/android/build/intermediates/merged_manifest/debug/AndroidManifest.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.rnmaps.maps" >
+
+    <uses-sdk android:minSdkVersion="23" />
+
+</manifest>
\ No newline at end of file
diff --git a/node_modules/react-native-maps/android/build/intermediates/navigation_json/debug/navigation.json b/node_modules/react-native-maps/android/build/intermediates/navigation_json/debug/navigation.json
new file mode 100644
index 0000000..0637a08
--- /dev/null
+++ b/node_modules/react-native-maps/android/build/intermediates/navigation_json/debug/navigation.json
@@ -0,0 +1 @@
+[]
\ No newline at end of file
diff --git a/node_modules/react-native-maps/android/build/intermediates/runtime_library_classes_jar/debug/classes.jar b/node_modules/react-native-maps/android/build/intermediates/runtime_library_classes_jar/debug/classes.jar
new file mode 100644
index 0000000..218780f
Binary files /dev/null and b/node_modules/react-native-maps/android/build/intermediates/runtime_library_classes_jar/debug/classes.jar differ
diff --git a/node_modules/react-native-maps/android/build/intermediates/symbol_list_with_package_name/debug/package-aware-r.txt b/node_modules/react-native-maps/android/build/intermediates/symbol_list_with_package_name/debug/package-aware-r.txt
new file mode 100644
index 0000000..d2faa16
--- /dev/null
+++ b/node_modules/react-native-maps/android/build/intermediates/symbol_list_with_package_name/debug/package-aware-r.txt
@@ -0,0 +1 @@
+com.rnmaps.maps
diff --git a/node_modules/react-native-maps/android/build/outputs/logs/manifest-merger-debug-report.txt b/node_modules/react-native-maps/android/build/outputs/logs/manifest-merger-debug-report.txt
new file mode 100644
index 0000000..9f52191
--- /dev/null
+++ b/node_modules/react-native-maps/android/build/outputs/logs/manifest-merger-debug-report.txt
@@ -0,0 +1,17 @@
+-- Merging decision tree log ---
+manifest
+ADDED from /Users/mizutani/prg/ecorismap/ecorismap/node_modules/react-native-maps/android/src/main/AndroidManifest.xml:1:1-3:12
+INJECTED from /Users/mizutani/prg/ecorismap/ecorismap/node_modules/react-native-maps/android/src/main/AndroidManifest.xml:1:1-3:12
+	package
+		ADDED from /Users/mizutani/prg/ecorismap/ecorismap/node_modules/react-native-maps/android/src/main/AndroidManifest.xml:2:5-30
+		INJECTED from /Users/mizutani/prg/ecorismap/ecorismap/node_modules/react-native-maps/android/src/main/AndroidManifest.xml
+	xmlns:android
+		ADDED from /Users/mizutani/prg/ecorismap/ecorismap/node_modules/react-native-maps/android/src/main/AndroidManifest.xml:1:11-69
+uses-sdk
+INJECTED from /Users/mizutani/prg/ecorismap/ecorismap/node_modules/react-native-maps/android/src/main/AndroidManifest.xml reason: use-sdk injection requested
+INJECTED from /Users/mizutani/prg/ecorismap/ecorismap/node_modules/react-native-maps/android/src/main/AndroidManifest.xml
+INJECTED from /Users/mizutani/prg/ecorismap/ecorismap/node_modules/react-native-maps/android/src/main/AndroidManifest.xml
+	android:targetSdkVersion
+		INJECTED from /Users/mizutani/prg/ecorismap/ecorismap/node_modules/react-native-maps/android/src/main/AndroidManifest.xml
+	android:minSdkVersion
+		INJECTED from /Users/mizutani/prg/ecorismap/ecorismap/node_modules/react-native-maps/android/src/main/AndroidManifest.xml
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapUrlTile$1.class.uniqueId9 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapUrlTile$1.class.uniqueId9
new file mode 100644
index 0000000..6f3e3b8
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapUrlTile$1.class.uniqueId9 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapUrlTile$2.class.uniqueId29 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapUrlTile$2.class.uniqueId29
new file mode 100644
index 0000000..0c8d52c
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapUrlTile$2.class.uniqueId29 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapUrlTile$3.class.uniqueId16 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapUrlTile$3.class.uniqueId16
new file mode 100644
index 0000000..5c36e6e
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapUrlTile$3.class.uniqueId16 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapUrlTile$4.class.uniqueId1 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapUrlTile$4.class.uniqueId1
new file mode 100644
index 0000000..2bb0606
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapUrlTile$4.class.uniqueId1 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapUrlTile$5.class.uniqueId20 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapUrlTile$5.class.uniqueId20
new file mode 100644
index 0000000..c30dab6
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapUrlTile$5.class.uniqueId20 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapUrlTile.class.uniqueId28 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapUrlTile.class.uniqueId28
new file mode 100644
index 0000000..6f4c317
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapUrlTile.class.uniqueId28 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapUrlTileManager.class.uniqueId14 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapUrlTileManager.class.uniqueId14
new file mode 100644
index 0000000..e4fd21f
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapUrlTileManager.class.uniqueId14 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$1.class.uniqueId5 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$1.class.uniqueId5
new file mode 100644
index 0000000..4c5b056
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$1.class.uniqueId5 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$10.class.uniqueId18 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$10.class.uniqueId18
new file mode 100644
index 0000000..fa610c0
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$10.class.uniqueId18 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$11.class.uniqueId3 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$11.class.uniqueId3
new file mode 100644
index 0000000..7b20697
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$11.class.uniqueId3 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$12.class.uniqueId7 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$12.class.uniqueId7
new file mode 100644
index 0000000..5b7e4b0
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$12.class.uniqueId7 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$13.class.uniqueId25 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$13.class.uniqueId25
new file mode 100644
index 0000000..77a687e
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$13.class.uniqueId25 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$14.class.uniqueId11 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$14.class.uniqueId11
new file mode 100644
index 0000000..9fd0fe0
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$14.class.uniqueId11 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$15.class.uniqueId22 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$15.class.uniqueId22
new file mode 100644
index 0000000..400fb54
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$15.class.uniqueId22 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$16.class.uniqueId0 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$16.class.uniqueId0
new file mode 100644
index 0000000..039c7cf
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$16.class.uniqueId0 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$17.class.uniqueId12 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$17.class.uniqueId12
new file mode 100644
index 0000000..97d90ee
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$17.class.uniqueId12 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$2.class.uniqueId27 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$2.class.uniqueId27
new file mode 100644
index 0000000..510d918
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$2.class.uniqueId27 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$3.class.uniqueId15 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$3.class.uniqueId15
new file mode 100644
index 0000000..ecea029
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$3.class.uniqueId15 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$4.class.uniqueId19 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$4.class.uniqueId19
new file mode 100644
index 0000000..9d50aeb
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$4.class.uniqueId19 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$5.class.uniqueId4 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$5.class.uniqueId4
new file mode 100644
index 0000000..8ab568c
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$5.class.uniqueId4 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$6.class.uniqueId10 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$6.class.uniqueId10
new file mode 100644
index 0000000..5195e1a
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$6.class.uniqueId10 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$7.class.uniqueId24 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$7.class.uniqueId24
new file mode 100644
index 0000000..108343d
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$7.class.uniqueId24 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$8.class.uniqueId13 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$8.class.uniqueId13
new file mode 100644
index 0000000..ac81330
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$8.class.uniqueId13 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$9.class.uniqueId21 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$9.class.uniqueId21
new file mode 100644
index 0000000..9081178
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView$9.class.uniqueId21 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView.class.uniqueId26 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView.class.uniqueId26
new file mode 100644
index 0000000..a95b1b6
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapView.class.uniqueId26 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapWMSTile$AIRMapGSUrlTileProvider$AIRMapWMSTileProvider.class.uniqueId17 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapWMSTile$AIRMapGSUrlTileProvider$AIRMapWMSTileProvider.class.uniqueId17
new file mode 100644
index 0000000..91f29e1
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapWMSTile$AIRMapGSUrlTileProvider$AIRMapWMSTileProvider.class.uniqueId17 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapWMSTile$AIRMapGSUrlTileProvider.class.uniqueId8 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapWMSTile$AIRMapGSUrlTileProvider.class.uniqueId8
new file mode 100644
index 0000000..be52547
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapWMSTile$AIRMapGSUrlTileProvider.class.uniqueId8 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapWMSTile.class.uniqueId23 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapWMSTile.class.uniqueId23
new file mode 100644
index 0000000..aafe4fe
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapWMSTile.class.uniqueId23 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapWMSTileManager.class.uniqueId6 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapWMSTileManager.class.uniqueId6
new file mode 100644
index 0000000..bbafb04
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapWMSTileManager.class.uniqueId6 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapsPackage.class.uniqueId2 b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapsPackage.class.uniqueId2
new file mode 100644
index 0000000..1c86d8e
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/compileTransaction/stash-dir/MapsPackage.class.uniqueId2 differ
diff --git a/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/previous-compilation-data.bin b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/previous-compilation-data.bin
new file mode 100644
index 0000000..eb6e00c
Binary files /dev/null and b/node_modules/react-native-maps/android/build/tmp/compileDebugJavaWithJavac/previous-compilation-data.bin differ
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapDEMTileProvider.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapDEMTileProvider.java
new file mode 100644
index 0000000..b2dc67b
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapDEMTileProvider.java
@@ -0,0 +1,328 @@
+package com.rnmaps.maps;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.util.Log;
+import android.util.LruCache;
+import com.google.android.gms.maps.GoogleMap;
+import com.google.android.gms.maps.model.CameraPosition;
+import com.google.android.gms.maps.model.Tile;
+import java.io.ByteArrayOutputStream;
+import java.lang.ref.WeakReference;
+
+/**
+ * DEM（数値標高モデル）タイル用のカスタムタイルプロバイダー
+ * MapTileProviderを継承し、DEMタイルのデコード機能を追加
+ */
+public class MapDEMTileProvider extends MapTileProvider {
+  
+  private static final String TAG = "MapDEMTileProvider";
+  private String encodingType = "mapbox"; // "mapbox" or "terrarium"
+  private WeakReference<GoogleMap> googleMapRef; // メモリリーク防止のためWeakReference使用
+  private int lastQuantizedBearing = 0; // 前回の量子化された回転角度
+  private volatile int currentBearing = 0; // 現在の回転角度（メインスレッドから更新）
+  
+  // ヒルシェードタイルのキャッシュ（キー: "x,y,zoom,bearing"）
+  private final LruCache<String, byte[]> hillshadeCache;
+  
+  public MapDEMTileProvider(
+    int tileSizet,
+    boolean doubleTileSize,
+    String urlTemplate,
+    int maximumZ,
+    int maximumNativeZ,
+    int minimumZ,
+    boolean flipY,
+    String tileCachePath,
+    int tileCacheMaxAge,
+    boolean offlineMode,
+    Context context,
+    boolean customMode
+  ) {
+    // superの呼び出しは最初に行う必要がある
+    super(tileSizet, doubleTileSize, 
+          cleanUrlTemplate(urlTemplate), 
+          maximumZ, maximumNativeZ, minimumZ, flipY, tileCachePath, tileCacheMaxAge, offlineMode, context, customMode);
+    
+    // URLからエンコーディングタイプを判定
+    if (urlTemplate.startsWith("hillshade-terrarium://")) {
+      this.encodingType = "terrarium";
+      Log.d(TAG, "Using Terrarium encoding for DEM tiles");
+    } else {
+      this.encodingType = "mapbox";
+      Log.d(TAG, "Using Mapbox Terrain RGB encoding for DEM tiles");
+    }
+    
+    // キャッシュの初期化（最大50MBのメモリを使用）
+    final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);
+    final int cacheSize = Math.min(maxMemory / 8, 50 * 1024); // 最大50MB
+    
+    this.hillshadeCache = new LruCache<String, byte[]>(cacheSize) {
+      @Override
+      protected int sizeOf(String key, byte[] value) {
+        // キャッシュサイズをKB単位で返す
+        return value.length / 1024;
+      }
+    };
+    
+    Log.d(TAG, "Cleaned URL: " + cleanUrlTemplate(urlTemplate) + ", Cache size: " + cacheSize + "KB");
+  }
+  
+  // URLテンプレートからプレフィックスを除去するヘルパーメソッド
+  private static String cleanUrlTemplate(String urlTemplate) {
+    if (urlTemplate.startsWith("hillshade://")) {
+      return urlTemplate.substring("hillshade://".length());
+    } else if (urlTemplate.startsWith("hillshade-terrarium://")) {
+      return urlTemplate.substring("hillshade-terrarium://".length());
+    }
+    return urlTemplate;
+  }
+  
+  /**
+   * GoogleMapの参照を設定
+   * @param googleMap GoogleMapインスタンス（nullも可）
+   */
+  public void setGoogleMap(GoogleMap googleMap) {
+    this.googleMapRef = googleMap != null ? new WeakReference<>(googleMap) : null;
+  }
+  
+  /**
+   * 現在の回転角度を更新（メインスレッドから呼び出す）
+   * @param bearing 回転角度（度）
+   */
+  public void updateBearing(float bearing) {
+    // 15度単位で量子化
+    int newBearing = Math.round(bearing / 15.0f) * 15;
+    
+    // 角度が変わった場合のみ更新
+    if (this.currentBearing != newBearing) {
+      this.currentBearing = newBearing;
+      Log.d(TAG, "Bearing updated to: " + this.currentBearing);
+      
+      // 隣接する角度のタイルを事前にキャッシュするためのフラグ
+      // （将来的な実装のためのプレースホルダー）
+    }
+  }
+  
+  /**
+   * 現在の地図の回転角度を取得（量子化済み）
+   * @return 15度単位で量子化された回転角度
+   */
+  private int getQuantizedBearing() {
+    // メインスレッドから更新された値を使用
+    return this.currentBearing;
+  }
+  
+  @Override
+  public Tile getTile(int x, int y, int zoom) {
+    // 量子化された回転角度を取得
+    int quantizedBearing = getQuantizedBearing();
+    
+    // キャッシュキーを生成
+    String cacheKey = String.format("%d,%d,%d,%d", x, y, zoom, quantizedBearing);
+    
+    // キャッシュから取得を試みる
+    byte[] cachedData = hillshadeCache.get(cacheKey);
+    if (cachedData != null) {
+      Log.d(TAG, "Using cached hillshade for: " + cacheKey);
+      return new Tile(this.tileSize, this.tileSize, cachedData);
+    }
+    
+    Log.d(TAG, String.format("Getting DEM tile: x=%d, y=%d, zoom=%d, bearing=%d", x, y, zoom, quantizedBearing));
+    
+    // まず親クラスのgetTileメソッドを呼び出してDEMタイルデータを取得
+    Tile demTile = super.getTile(x, y, zoom);
+    
+    if (demTile == null) {
+      Log.d(TAG, "No DEM tile available from parent");
+      return null;
+    }
+    
+    // NO_TILEの場合はdataがnullなのでチェック
+    if (demTile.data == null) {
+      Log.d(TAG, "DEM tile has no data (NO_TILE)");
+      return demTile;
+    }
+    
+    // DEMタイルから陰影図を作成（回転角度を渡す）
+    byte[] processedData = createHillshade(demTile.data, zoom, quantizedBearing);
+    
+    if (processedData == null) {
+      Log.e(TAG, "Failed to create hillshade");
+      return null;
+    }
+    
+    // キャッシュに保存
+    hillshadeCache.put(cacheKey, processedData);
+    
+    // 処理済みのタイルを返す
+    return new Tile(demTile.width, demTile.height, processedData);
+  }
+  
+  /**
+   * DEMタイルから陰影図（ヒルシェード）を作成
+   * @param tileData 元のDEMタイルデータ
+   * @param zoom ズームレベル
+   * @param mapBearing 地図の回転角度（度、量子化済み）
+   * @return 陰影図のタイルデータ
+   */
+  private byte[] createHillshade(byte[] tileData, int zoom, int mapBearing) {
+    try {
+      // タイルデータをBitmapに変換
+      Bitmap sourceBitmap = BitmapFactory.decodeByteArray(tileData, 0, tileData.length);
+      if (sourceBitmap == null) {
+        Log.e(TAG, "Failed to decode tile data to bitmap");
+        return null;
+      }
+      
+      int width = sourceBitmap.getWidth();
+      int height = sourceBitmap.getHeight();
+      Log.d(TAG, String.format("Creating hillshade: width=%d, height=%d", width, height));
+      
+      // 標高データを2次元配列に格納
+      float[][] elevations = new float[height][width];
+      for (int y = 0; y < height; y++) {
+        for (int x = 0; x < width; x++) {
+          int pixel = sourceBitmap.getPixel(x, y);
+          int r = (pixel >> 16) & 0xff;
+          int g = (pixel >> 8) & 0xff;
+          int b = pixel & 0xff;
+          elevations[y][x] = decodeElevation(r, g, b);
+        }
+      }
+      
+      // 陰影図を作成
+      Bitmap hillshadeBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
+      
+      // MapLibreと同じパラメータ
+      // 画面固定の光源方向（南東方向に変更）
+      float screenAzimuth = 135.0f; // 画面に対する光源の方位角（度）- 南東
+      float altitude = 45.0f; // 仰角（度）
+      float exaggeration = 0.5f; // 誇張率（MapLibreのデフォルト値）
+      
+      // 地図の回転を補正して、画面に対して固定された光源を実現
+      float adjustedAzimuth = screenAzimuth - mapBearing;
+      Log.d(TAG, String.format("Light source: screen=%f, map rotation=%d, adjusted=%f", 
+                               screenAzimuth, mapBearing, adjustedAzimuth));
+      
+      // 光源ベクトルの計算
+      // 地理座標系（北が0度、時計回り）での計算
+      double azimuthRad = Math.toRadians(90 - adjustedAzimuth); // 東が0度から北が0度に変換
+      double altitudeRad = Math.toRadians(altitude);
+      float lightX = (float)(Math.cos(azimuthRad) * Math.cos(altitudeRad));
+      float lightY = (float)(Math.sin(azimuthRad) * Math.cos(altitudeRad));
+      float lightZ = (float)Math.sin(altitudeRad);
+      
+      // ピクセルあたりのメートル数を計算（ズームレベルに依存）
+      // 256ピクセルのタイルで、赤道での計算
+      double metersPerPixel = 40075016.686 / (Math.pow(2, zoom) * 256);
+      float scale = (float)(1.0 / metersPerPixel);
+      
+      // 各ピクセルの陰影を計算（エッジも含めて処理）
+      for (int y = 0; y < height; y++) {
+        for (int x = 0; x < width; x++) {
+          // エッジピクセルの場合は、利用可能な隣接ピクセルで計算
+          float tl, tm, tr, ml, mr, bl, bm, br;
+          
+          // 境界チェックしながら隣接ピクセルの値を取得
+          // エッジの場合は最も近い有効なピクセルの値を使用
+          tl = (y > 0 && x > 0) ? elevations[y-1][x-1] : elevations[Math.max(0, y-1)][Math.max(0, x-1)];
+          tm = (y > 0) ? elevations[y-1][x] : elevations[0][x];
+          tr = (y > 0 && x < width-1) ? elevations[y-1][x+1] : elevations[Math.max(0, y-1)][Math.min(width-1, x+1)];
+          ml = (x > 0) ? elevations[y][x-1] : elevations[y][0];
+          mr = (x < width-1) ? elevations[y][x+1] : elevations[y][width-1];
+          bl = (y < height-1 && x > 0) ? elevations[y+1][x-1] : elevations[Math.min(height-1, y+1)][Math.max(0, x-1)];
+          bm = (y < height-1) ? elevations[y+1][x] : elevations[height-1][x];
+          br = (y < height-1 && x < width-1) ? elevations[y+1][x+1] : elevations[Math.min(height-1, y+1)][Math.min(width-1, x+1)];
+          
+          // 勾配の計算（MapLibre方式）
+          // X方向の勾配（右が正）
+          float dzdx = ((tr + 2 * mr + br) - (tl + 2 * ml + bl)) / 8.0f;
+          // Y方向の勾配（下が正なので符号を反転）
+          float dzdy = -((bl + 2 * bm + br) - (tl + 2 * tm + tr)) / 8.0f;
+          
+          // スケールと誇張率を適用
+          dzdx = dzdx * scale * exaggeration;
+          dzdy = dzdy * scale * exaggeration;
+          
+          // 法線ベクトルの計算
+          float slope = (float)Math.sqrt(dzdx * dzdx + dzdy * dzdy);
+          float aspect = (float)Math.atan2(dzdy, -dzdx);
+          
+          // 傾斜角の計算
+          float slopeRad = (float)Math.atan(slope);
+          
+          // 陰影の計算（MapLibre方式）
+          float shade = Math.max(0.0f, 
+            (float)(Math.cos(slopeRad) * Math.sin(altitudeRad) + 
+                    Math.sin(slopeRad) * Math.cos(altitudeRad) * 
+                    Math.cos(azimuthRad - aspect)));
+          
+          // シェード値を調整（0.0〜1.0）
+          // より明るい陰影にするため、範囲を調整
+          // 元の値: 0.0〜1.0 → 調整後: 0.5〜1.0（より明るく）
+          shade = shade * 0.5f + 0.5f;
+          
+          int intensity = (int)(shade * 255);
+          intensity = Math.max(0, Math.min(255, intensity));
+          
+          int color = Color.argb(255, intensity, intensity, intensity);
+          hillshadeBitmap.setPixel(x, y, color);
+        }
+      }
+      
+      // Bitmapをbyte配列に変換
+      ByteArrayOutputStream stream = new ByteArrayOutputStream();
+      hillshadeBitmap.compress(Bitmap.CompressFormat.PNG, 100, stream);
+      byte[] result = stream.toByteArray();
+      
+      // リソースをクリーンアップ
+      sourceBitmap.recycle();
+      hillshadeBitmap.recycle();
+      
+      Log.d(TAG, "Successfully created hillshade");
+      return result;
+      
+    } catch (Exception e) {
+      Log.e(TAG, "Error creating hillshade", e);
+      return null;
+    }
+  }
+  
+  /**
+   * RGB値から標高を計算
+   * @param r Red値
+   * @param g Green値
+   * @param b Blue値
+   * @return 標高（メートル）
+   */
+  private float decodeElevation(int r, int g, int b) {
+    if (encodingType.equals("terrarium")) {
+      // Terrarium encoding: elevation = (R * 256 + G + B / 256) - 32768
+      return (float) ((r * 256.0 + g + b / 256.0) - 32768.0);
+    } else {
+      // Mapbox Terrain RGB encoding: elevation = -10000 + ((R * 256 * 256 + G * 256 + B) * 0.1)
+      return (float) (-10000 + ((r * 256 * 256 + g * 256 + b) * 0.1));
+    }
+  }
+  
+  @Override
+  public void setUrlTemplate(String urlTemplate) {
+    // URLテンプレートからプレフィックスを除去
+    String cleanedUrl = urlTemplate;
+    if (urlTemplate.startsWith("hillshade://")) {
+      cleanedUrl = urlTemplate.substring("hillshade://".length());
+      this.encodingType = "mapbox";
+    } else if (urlTemplate.startsWith("hillshade-terrarium://")) {
+      cleanedUrl = urlTemplate.substring("hillshade-terrarium://".length());
+      this.encodingType = "terrarium";
+    }
+    
+    super.setUrlTemplate(cleanedUrl);
+    Log.d(TAG, "URL template updated: " + cleanedUrl + ", encoding: " + encodingType);
+  }
+}
\ No newline at end of file
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapPMTile.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapPMTile.java
new file mode 100644
index 0000000..0452e29
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapPMTile.java
@@ -0,0 +1,241 @@
+package com.rnmaps.maps;
+
+import android.content.Context;
+import android.util.Log;
+import com.google.android.gms.maps.GoogleMap;
+import com.google.android.gms.maps.model.TileOverlay;
+import com.google.android.gms.maps.model.TileOverlayOptions;
+import java.net.MalformedURLException;
+import java.net.URL;
+
+public class MapPMTile extends MapFeature {
+
+  protected TileOverlayOptions tileOverlayOptions;
+  protected TileOverlay tileOverlay;
+  protected MapPMTileProvider tileProvider;
+
+  protected String urlTemplate;
+  protected String styleURL;
+  protected float zIndex;
+  protected float maximumZ;
+  protected float maximumNativeZ = 100;
+  protected float minimumZ;
+  protected boolean flipY = false;
+  protected float tileSize = 256;
+  protected boolean doubleTileSize = false;
+  protected String tileCachePath;
+  protected float tileCacheMaxAge;
+  protected boolean offlineMode = false;
+  protected boolean isVector = false;
+  protected float opacity = 1;
+  protected Context context;
+  protected boolean customTileProviderNeeded = false;
+
+  public MapPMTile(Context context) {
+    super(context);
+    this.context = context;
+  }
+
+  public void setUrlTemplate(String urlTemplate) {
+    this.urlTemplate = urlTemplate;
+    if (tileProvider != null) {
+      tileProvider.setUrlTemplate(urlTemplate);
+    }
+    if (tileOverlay != null) {
+      tileOverlay.clearTileCache();
+    }
+  }
+
+  public void setStyleURL(String styleURL) {
+    this.styleURL = styleURL;
+    if (tileProvider != null) {
+      tileProvider.setStyleURL(styleURL);
+    }
+    if (tileOverlay != null) {
+      tileOverlay.clearTileCache();
+    }
+  }
+
+  public void setZIndex(float zIndex) {
+    this.zIndex = zIndex;
+    if (tileOverlay != null) {
+      tileOverlay.setZIndex(zIndex);
+    }
+  }
+
+  public void setMaximumZ(float maximumZ) {
+    this.maximumZ = maximumZ;
+    if (tileProvider != null) {
+      tileProvider.setMaximumZ((int) maximumZ);
+    }
+    if (tileOverlay != null) {
+      tileOverlay.clearTileCache();
+    }
+  }
+
+  public void setMaximumNativeZ(float maximumNativeZ) {
+    this.maximumNativeZ = maximumNativeZ;
+    if (tileProvider != null) {
+      tileProvider.setMaximumNativeZ((int) maximumNativeZ);
+    }
+    setCustomTileProviderMode();
+    if (tileOverlay != null) {
+      tileOverlay.clearTileCache();
+    }
+  }
+
+  public void setMinimumZ(float minimumZ) {
+    this.minimumZ = minimumZ;
+    if (tileProvider != null) {
+      tileProvider.setMinimumZ((int) minimumZ);
+    }
+    if (tileOverlay != null) {
+      tileOverlay.clearTileCache();
+    }
+  }
+
+  public void setFlipY(boolean flipY) {
+    this.flipY = flipY;
+    if (tileProvider != null) {
+      tileProvider.setFlipY(flipY);
+    }
+    if (tileOverlay != null) {
+      tileOverlay.clearTileCache();
+    }
+  }
+
+  public void setDoubleTileSize(boolean doubleTileSize) {
+    this.doubleTileSize = doubleTileSize;
+    if (tileProvider != null) {
+      tileProvider.setDoubleTileSize(doubleTileSize);
+    }
+    setCustomTileProviderMode();
+    if (tileOverlay != null) {
+      tileOverlay.clearTileCache();
+    }
+  }
+
+  public void setTileSize(float tileSize) {
+    this.tileSize = tileSize;
+    if (tileProvider != null) {
+      tileProvider.setTileSize((int) tileSize);
+    }
+    if (tileOverlay != null) {
+      tileOverlay.clearTileCache();
+    }
+  }
+
+  public void setTileCachePath(String tileCachePath) {
+    if (tileCachePath == null || tileCachePath.isEmpty()) return;
+
+    try {
+      URL url = new URL(tileCachePath);
+      this.tileCachePath = url.getPath();
+    } catch (MalformedURLException e) {
+      this.tileCachePath = tileCachePath;
+    } catch (Exception e) {
+      return;
+    }
+
+    if (tileProvider != null) {
+      tileProvider.setTileCachePath(tileCachePath);
+    }
+    setCustomTileProviderMode();
+    if (tileOverlay != null) {
+      tileOverlay.clearTileCache();
+    }
+  }
+
+  public void setTileCacheMaxAge(float tileCacheMaxAge) {
+    this.tileCacheMaxAge = tileCacheMaxAge;
+    if (tileProvider != null) {
+      tileProvider.setTileCacheMaxAge((int) tileCacheMaxAge);
+    }
+    if (tileOverlay != null) {
+      tileOverlay.clearTileCache();
+    }
+  }
+
+  public void setOfflineMode(boolean offlineMode) {
+    this.offlineMode = offlineMode;
+    if (tileProvider != null) {
+      tileProvider.setOfflineMode(offlineMode);
+    }
+    if (tileOverlay != null) {
+      tileOverlay.clearTileCache();
+    }
+  }
+
+  public void setIsVector(boolean isVector) {
+    this.isVector = isVector;
+    if (tileProvider != null) {
+      tileProvider.setIsVector(isVector);
+    }
+    if (tileOverlay != null) {
+      tileOverlay.clearTileCache();
+    }
+  }
+
+  public void setOpacity(float opacity) {
+    this.opacity = opacity;
+    if (tileOverlay != null) {
+      tileOverlay.setTransparency(1 - opacity);
+    }
+  }
+
+  public TileOverlayOptions getTileOverlayOptions() {
+    if (tileOverlayOptions == null) {
+      tileOverlayOptions = createTileOverlayOptions();
+    }
+    return tileOverlayOptions;
+  }
+
+  protected void setCustomTileProviderMode() {
+    Log.d("urlTile ", "creating new mode TileProvider");
+    this.customTileProviderNeeded = true;
+    if (tileProvider != null) {
+      tileProvider.setCustomMode();
+    }
+  }
+
+  protected TileOverlayOptions createTileOverlayOptions() {
+    Log.d("urlTile ", "creating TileProvider");
+    TileOverlayOptions options = new TileOverlayOptions();
+    options.zIndex(zIndex);
+    options.transparency(1 - this.opacity);
+    this.tileProvider =
+      new MapPMTileProvider(
+        (int) this.tileSize,
+        this.doubleTileSize,
+        this.urlTemplate,
+        this.styleURL,
+        (int) this.maximumZ,
+        (int) this.maximumNativeZ,
+        (int) this.minimumZ,
+        this.flipY,
+        this.tileCachePath,
+        (int) this.tileCacheMaxAge,
+        this.offlineMode,
+        this.isVector,
+        this.context,
+        this.customTileProviderNeeded
+      );
+    options.tileProvider(this.tileProvider);
+    return options;
+  }
+
+  @Override
+  public Object getFeature() {
+    return tileOverlay;
+  }
+
+  @Override
+  public void addToMap(Object map) {
+    this.tileOverlay = ((GoogleMap) map).addTileOverlay(getTileOverlayOptions());
+  }
+
+  @Override
+  public void removeFromMap(Object map) {
+    tileOverlay.remove();
+  }
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapPMTileManager.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapPMTileManager.java
new file mode 100644
index 0000000..fa156d6
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapPMTileManager.java
@@ -0,0 +1,98 @@
+package com.rnmaps.maps;
+
+import android.content.Context;
+import android.util.DisplayMetrics;
+import android.view.WindowManager;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.uimanager.ThemedReactContext;
+import com.facebook.react.uimanager.ViewGroupManager;
+import com.facebook.react.uimanager.annotations.ReactProp;
+
+public class MapPMTileManager extends ViewGroupManager<MapPMTile> {
+
+  public MapPMTileManager(ReactApplicationContext reactContext) {
+    super();
+    DisplayMetrics metrics = new DisplayMetrics();
+    ((WindowManager) reactContext.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getRealMetrics(metrics);
+  }
+
+  @Override
+  public String getName() {
+    return "AIRMapPMTile";
+  }
+
+  @Override
+  public MapPMTile createViewInstance(ThemedReactContext context) {
+    return new MapPMTile(context);
+  }
+
+  @ReactProp(name = "urlTemplate")
+  public void setUrlTemplate(MapPMTile view, String urlTemplate) {
+    view.setUrlTemplate(urlTemplate);
+  }
+
+  @ReactProp(name = "styleURL")
+  public void setStyleURL(MapPMTile view, String styleURL) {
+    view.setStyleURL(styleURL);
+  }
+
+  @ReactProp(name = "zIndex", defaultFloat = -1.0f)
+  public void setZIndex(MapPMTile view, float zIndex) {
+    view.setZIndex(zIndex);
+  }
+
+  @ReactProp(name = "minimumZ", defaultFloat = 0.0f)
+  public void setMinimumZ(MapPMTile view, float minimumZ) {
+    view.setMinimumZ(minimumZ);
+  }
+
+  @ReactProp(name = "maximumZ", defaultFloat = 100.0f)
+  public void setMaximumZ(MapPMTile view, float maximumZ) {
+    view.setMaximumZ(maximumZ);
+  }
+
+  @ReactProp(name = "maximumNativeZ", defaultFloat = 100.0f)
+  public void setMaximumNativeZ(MapPMTile view, float maximumNativeZ) {
+    view.setMaximumNativeZ(maximumNativeZ);
+  }
+
+  @ReactProp(name = "flipY", defaultBoolean = false)
+  public void setFlipY(MapPMTile view, boolean flipY) {
+    view.setFlipY(flipY);
+  }
+
+  @ReactProp(name = "tileSize", defaultFloat = 256.0f)
+  public void setTileSize(MapPMTile view, float tileSize) {
+    view.setTileSize(tileSize);
+  }
+
+  @ReactProp(name = "doubleTileSize", defaultBoolean = false)
+  public void setDoubleTileSize(MapPMTile view, boolean doubleTileSize) {
+    view.setDoubleTileSize(doubleTileSize);
+  }
+
+  @ReactProp(name = "tileCachePath")
+  public void setTileCachePath(MapPMTile view, String tileCachePath) {
+    view.setTileCachePath(tileCachePath);
+  }
+
+  @ReactProp(name = "tileCacheMaxAge", defaultFloat = 0.0f)
+  public void setTileCacheMaxAge(MapPMTile view, float tileCacheMaxAge) {
+    view.setTileCacheMaxAge(tileCacheMaxAge);
+  }
+
+  @ReactProp(name = "offlineMode", defaultBoolean = false)
+  public void setOfflineMode(MapPMTile view, boolean offlineMode) {
+    view.setOfflineMode(offlineMode);
+  }
+
+  @ReactProp(name = "isVector", defaultBoolean = false)
+  public void setIsVector(MapPMTile view, boolean isVector) {
+    view.setIsVector(isVector);
+  }
+
+  @ReactProp(name = "opacity", defaultFloat = 1.0f)
+  public void setOpacity(MapPMTile view, float opacity) {
+    view.setOpacity(opacity);
+  }
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapPMTileProvider.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapPMTileProvider.java
new file mode 100644
index 0000000..3faff7b
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapPMTileProvider.java
@@ -0,0 +1,1301 @@
+package com.rnmaps.maps;
+
+import PMTiles.Metadata;
+import PMTiles.PMTiles;
+import PMTiles.RangeResponse;
+import VectorTileStyle.LayerStyle;
+import VectorTileStyle.PaintStyle;
+import VectorTileStyle.VectorStyle;
+import VectorTileStyleManager.VectorTileStyleManager;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Path;
+import android.graphics.PointF;
+import android.graphics.Rect;
+import android.graphics.Typeface;
+import android.util.Log;
+import androidx.annotation.NonNull;
+import com.google.android.gms.maps.GoogleMap;
+import com.google.android.gms.maps.model.Tile;
+import com.google.android.gms.maps.model.TileOverlay;
+import com.google.android.gms.maps.model.TileOverlayOptions;
+import com.google.android.gms.maps.model.TileProvider;
+import com.google.protobuf.InvalidProtocolBufferException;
+import java.io.BufferedReader;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.lang.System;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URL;
+import java.net.URLConnection;
+import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Base64;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.Random;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import vector_tile.VectorTile;
+import vector_tile.VectorTile.Tile.Feature;
+import vector_tile.VectorTile.Tile.GeomType;
+import vector_tile.VectorTile.Tile.Layer;
+import vector_tile.VectorTile.Tile.Value;
+
+public class MapPMTileProvider implements TileProvider {
+
+  protected static final int BUFFER_SIZE = 16 * 1024;
+  protected static final int TARGET_TILE_SIZE = 512;
+  protected String urlTemplate;
+  protected String styleURL;
+  protected int tileSize;
+  protected boolean doubleTileSize;
+  protected int maximumZ;
+  protected int maximumNativeZ;
+  protected int minimumZ;
+  protected boolean flipY;
+  protected String tileCachePath;
+  protected int tileCacheMaxAge;
+  protected boolean offlineMode;
+  protected boolean isVector;
+  protected Context context;
+  protected boolean customMode;
+  protected PMTiles pmtiles;
+  protected Metadata metadata;
+  protected VectorTileStyleManager styleManager;
+  protected int tileType;
+
+  public MapPMTileProvider(
+    int tileSizet,
+    boolean doubleTileSize,
+    String urlTemplate,
+    String styleURL,
+    int maximumZ,
+    int maximumNativeZ,
+    int minimumZ,
+    boolean flipY,
+    String tileCachePath,
+    int tileCacheMaxAge,
+    boolean offlineMode,
+    boolean isVector,
+    Context context,
+    boolean customMode
+  ) {
+    this.tileSize = tileSizet;
+    this.doubleTileSize = doubleTileSize;
+    this.urlTemplate = urlTemplate;
+    this.styleURL = styleURL;
+    this.maximumZ = maximumZ;
+    this.maximumNativeZ = maximumNativeZ;
+    this.minimumZ = minimumZ;
+    this.flipY = flipY;
+    this.tileCachePath = tileCachePath;
+    this.tileCacheMaxAge = tileCacheMaxAge;
+    this.offlineMode = offlineMode && !urlTemplate.contains("file://");
+    this.isVector = isVector;
+    this.context = context;
+    this.customMode = customMode;
+    this.tileType = -1;
+
+    CompletableFuture<Void> pmtilesFuture = CompletableFuture.completedFuture(null); // Default to a completed future
+
+    if (urlTemplate.endsWith(".pbf")) {
+      this.tileType = 0;
+      this.tileSize = 512;
+    } else if (this.offlineMode) {
+      if (this.isVector) {
+        this.tileType = 1;
+        this.tileSize = 512;
+      } else {
+        this.tileType = 2;
+        this.tileSize = 256;
+      }
+    } else {
+      this.pmtiles = new PMTiles(urlTemplate, null, null);
+
+      pmtilesFuture =
+        this.pmtiles.getHeader()
+          .thenAccept(header -> {
+            if (header != null) {
+              this.tileType = header.getTileType();
+              this.tileSize = this.tileType == 1 ? 512 : 256;
+            }
+          })
+          .thenCompose(v -> this.pmtiles.getMetadata())
+          .exceptionally(ex -> {
+            return null;
+          })
+          .thenAccept(metadata -> {
+            this.metadata = metadata;
+          });
+    }
+
+    this.styleManager =
+      new VectorTileStyleManager(this.urlTemplate, this.tileCachePath, this.styleURL, this.offlineMode);
+    CompletableFuture<Void> styleManagerFuture = this.styleManager.initialize();
+
+    // Wait for both the pmtilesFuture and styleManagerFuture to complete
+    CompletableFuture.allOf(pmtilesFuture, styleManagerFuture).join();
+  }
+
+  @Override
+  public Tile getTile(int x, int y, int zoom) {
+    if (this.tileType == -1 && !this.offlineMode) return null;
+    byte[] image = null;
+    int maximumZ = this.maximumZ > 0 ? this.maximumZ : Integer.MAX_VALUE;
+
+    if (this.tileSize == 256 && this.doubleTileSize && zoom + 1 <= this.maximumNativeZ && zoom + 1 <= maximumZ) {
+      // Log.d("urlTile", "pullTilesFromHigherZoom");
+      image = pullTilesFromHigherZoom(x, y, zoom);
+    }
+
+    if (zoom > this.maximumNativeZ && zoom <= this.maximumNativeZ + 1) {
+      // Log.d("urlTile", "scaleLowerZoomTile");
+      image = scaleLowerZoomTile(x, y, zoom, this.maximumNativeZ);
+    }
+
+    if (image == null && zoom <= maximumZ) {
+      // Log.d("urlTile", "getTileImage");
+      image = getTileImage(x, y, zoom);
+    }
+
+    // if (image == null && this.tileCachePath != null && this.offlineMode) {
+    //   //Log.d("urlTile", "findLowerZoomTileForScaling");
+    //   int zoomLevelToStart = (zoom > this.maximumNativeZ) ? this.maximumNativeZ - 1 : zoom - 1;
+    //   int minimumZoomToSearch = this.minimumZ >= zoom - 3 ? this.minimumZ : zoom - 3;
+    //   for (int tryZoom = zoomLevelToStart; tryZoom >= minimumZoomToSearch; tryZoom--) {
+    //     image = scaleLowerZoomTile(x, y, zoom, tryZoom);
+    //     if (image != null) {
+    //       break;
+    //     }
+    //   }
+    // }
+
+    return image == null ? null : new Tile(this.tileSize, this.tileSize, image);
+  }
+
+  byte[] getTileImage(int x, int y, int zoom) {
+    byte[] image = null;
+    if (this.tileCachePath != null) {
+      image = readTileImage(x, y, zoom);
+      // if (image != null) {
+      //   //System.out.println("##read from cache" + zoom + "/" + x + "/" + y);
+      //   boolean needRefresh = checkForRefresh(x, y, zoom);
+      //   if (needRefresh) {
+      //     image = null;
+      //   }
+      // }
+    }
+    if (image == null && this.tileCachePath != null) {
+      // Log.d("urlTile", "Normal fetch");
+      image = fetchTile(x, y, zoom);
+      if (image != null) {
+        boolean success = writeTileImage(image, x, y, zoom);
+        //System.out.println("##fetch:" + zoom + "/" + x + "/" + y);
+      }
+    }
+    return image;
+  }
+
+  byte[] pullTilesFromHigherZoom(int x, int y, int zoom) {
+    byte[] data;
+    Bitmap image = getNewBitmap();
+    Canvas canvas = new Canvas(image);
+    Paint paint = new Paint();
+
+    x = x * 2;
+    y = y * 2;
+    byte[] leftTop = getTileImage(x, y, zoom + 1);
+    byte[] leftBottom = getTileImage(x, y + 1, zoom + 1);
+    byte[] rightTop = getTileImage(x + 1, y, zoom + 1);
+    byte[] rightBottom = getTileImage(x + 1, y + 1, zoom + 1);
+
+    if (leftTop == null && leftBottom == null && rightTop == null && rightBottom == null) {
+      return null;
+    }
+
+    Bitmap bitmap;
+    if (leftTop != null) {
+      bitmap = BitmapFactory.decodeByteArray(leftTop, 0, leftTop.length);
+      canvas.drawBitmap(bitmap, 0, 0, paint);
+      bitmap.recycle();
+    }
+    if (leftBottom != null) {
+      bitmap = BitmapFactory.decodeByteArray(leftBottom, 0, leftBottom.length);
+      canvas.drawBitmap(bitmap, 0, 256, paint);
+      bitmap.recycle();
+    }
+    if (rightTop != null) {
+      bitmap = BitmapFactory.decodeByteArray(rightTop, 0, rightTop.length);
+      canvas.drawBitmap(bitmap, 256, 0, paint);
+      bitmap.recycle();
+    }
+    if (rightBottom != null) {
+      bitmap = BitmapFactory.decodeByteArray(rightBottom, 0, rightBottom.length);
+      canvas.drawBitmap(bitmap, 256, 256, paint);
+      bitmap.recycle();
+    }
+    data = bitmapToByteArray(image);
+    image.recycle();
+    return data;
+  }
+
+  Bitmap getNewBitmap() {
+    Bitmap image = Bitmap.createBitmap(TARGET_TILE_SIZE, TARGET_TILE_SIZE, Bitmap.Config.ARGB_8888);
+    image.eraseColor(Color.TRANSPARENT);
+    return image;
+  }
+
+  byte[] bitmapToByteArray(Bitmap bm) {
+    ByteArrayOutputStream bos = new ByteArrayOutputStream();
+    bm.compress(Bitmap.CompressFormat.PNG, 100, bos);
+
+    byte[] data = bos.toByteArray();
+    try {
+      bos.close();
+    } catch (Exception e) {
+      // e.printStackTrace();
+    }
+    return data;
+  }
+
+  byte[] scaleLowerZoomTile(int x, int y, int zoom, int maximumZoom) {
+    int overZoomLevel = zoom - maximumZoom;
+    int zoomFactor = 1 << overZoomLevel;
+
+    int xParent = x >> overZoomLevel;
+    int yParent = y >> overZoomLevel;
+    int zoomParent = zoom - overZoomLevel;
+
+    int xOffset = x % zoomFactor;
+    int yOffset = y % zoomFactor;
+    byte[] data;
+
+    Bitmap image = getNewBitmap();
+    Canvas canvas = new Canvas(image);
+    Paint paint = new Paint();
+    data = getTileImage(xParent, yParent, zoomParent);
+
+    if (data == null) return null;
+    Bitmap sourceImage;
+
+    sourceImage = BitmapFactory.decodeByteArray(data, 0, data.length);
+    int subTileSize = this.tileSize / zoomFactor;
+
+    Rect sourceRect = new Rect(
+      xOffset * subTileSize,
+      yOffset * subTileSize,
+      xOffset * subTileSize + subTileSize,
+      yOffset * subTileSize + subTileSize
+    );
+    Rect targetRect = new Rect(0, 0, TARGET_TILE_SIZE, TARGET_TILE_SIZE);
+    canvas.drawBitmap(sourceImage, sourceRect, targetRect, paint);
+    sourceImage.recycle();
+    data = bitmapToByteArray(image);
+
+    image.recycle();
+    return data;
+  }
+
+  boolean checkForRefresh(int x, int y, int zoom) {
+    String fileName = getTileFilename(x, y, zoom);
+    File file = new File(fileName);
+    long lastModified = file.lastModified();
+    long now = System.currentTimeMillis();
+    long styleLastUpdatedTime = styleManager.getLastUpdatedTime();
+    // System.out.println(
+    //   "##!" + x + "/" + y + "/" + zoom + ", " + styleLastUpdatedTime + ", " + lastModified + ", " + now
+    // );
+    if (styleLastUpdatedTime > lastModified || styleLastUpdatedTime == 0) {
+      //System.out.println("##!style updated" + x + "/" + y + "/" + zoom);
+      return true;
+    }
+    if ((now - lastModified) / 1000 > this.tileCacheMaxAge) {
+      //System.out.println("##cache expired");
+      return true;
+    }
+    //System.out.println("##!not update " + x + "/" + y + "/" + zoom);
+    return false;
+  }
+
+  void setColorByCategory(Paint paint, String categoryC) {
+    switch (categoryC) {
+      case "28":
+        paint.setColor(Color.CYAN);
+        break;
+      case "26":
+        paint.setColor(Color.GRAY);
+        break;
+      default:
+        paint.setColor(Color.WHITE);
+        break;
+    }
+  }
+
+  // メンバ変数として、colorMappingを定義
+  private HashMap<String, Integer> colorMapping = new HashMap<>();
+
+  // getColorToUse メソッドの定義
+  public int getColorToUse(Map<String, String> attributes, String key) {
+    String valueToUse = attributes.containsKey(key) ? (String) attributes.get(key) : "";
+
+    // すでに colorMapping で色が割り当てられている場合は、その色を使う
+    if (colorMapping.containsKey(valueToUse)) {
+      return colorMapping.get(valueToUse);
+    }
+
+    // ランダムな色を生成
+    Random rand = new Random();
+    float red = rand.nextInt(256) / 255.0f;
+    float green = rand.nextInt(256) / 255.0f;
+    float blue = rand.nextInt(256) / 255.0f;
+
+    int randomColor = Color.argb(255, (int) (red * 255), (int) (green * 255), (int) (blue * 255));
+
+    // valueToUseに基づいて色を選択
+    if ("28".equals(valueToUse)) {
+      randomColor = Color.argb(255, 135, 206, 250); // R: 0.53*255, G: 0.81*255, B: 0.98*255
+    }
+
+    // colorMapping に保存
+    colorMapping.put(valueToUse, randomColor);
+
+    return randomColor;
+  }
+
+  public HashMap<String, String> getFeatureAttributes(VectorTile.Tile.Layer layer, VectorTile.Tile.Feature feature) {
+    HashMap<String, String> attributeDict = new HashMap<>();
+    List<Integer> tagsArray = feature.getTagsList();
+    int tagsCount = tagsArray.size();
+
+    for (int i = 0; i < tagsCount; i += 2) {
+      int keyIndex = tagsArray.get(i);
+      int valueIndex = tagsArray.get(i + 1);
+
+      String key = layer.getKeys(keyIndex);
+      VectorTile.Tile.Value valueObj = layer.getValues(valueIndex);
+      String valueStr = "";
+
+      if (valueObj.hasStringValue()) {
+        valueStr = valueObj.getStringValue();
+      } else if (valueObj.hasIntValue()) {
+        valueStr = String.valueOf(valueObj.getIntValue());
+      } else if (valueObj.hasFloatValue()) {
+        valueStr = String.valueOf(valueObj.getFloatValue());
+      } else if (valueObj.hasDoubleValue()) {
+        valueStr = String.format("%.1f", valueObj.getDoubleValue()); // 小数点以下2桁
+      }
+      // 他の型についても同様に処理
+
+      attributeDict.put(key, valueStr);
+    }
+
+    return attributeDict;
+  }
+
+  public class PointData {
+
+    public float x;
+    public float y;
+
+    public PointData(float x, float y) {
+      this.x = x;
+      this.y = y;
+    }
+  }
+
+  public class PolygonData {
+
+    public Path path;
+    public float centerX;
+    public float centerY;
+
+    public PolygonData(Path path, float centerX, float centerY) {
+      this.path = path;
+      this.centerX = centerX;
+      this.centerY = centerY;
+    }
+  }
+
+  private List<PointData> createMultiPointData(List<Integer> geometryArray, float extent) {
+    List<PointData> points = new ArrayList<>();
+    int index = 0;
+    float cursorX = 0;
+    float cursorY = 0;
+    float scaleFactor = this.tileSize / extent;
+    while (index < geometryArray.size()) {
+      int commandInteger = geometryArray.get(index++);
+      int commandId = commandInteger & 0x7;
+      int commandCount = commandInteger >> 3;
+
+      for (int i = 0; i < commandCount; ++i) {
+        int dx = ((geometryArray.get(index++) >> 1) ^ (-(geometryArray.get(index - 1) & 1)));
+        int dy = ((geometryArray.get(index++) >> 1) ^ (-(geometryArray.get(index - 1) & 1)));
+        cursorX += dx;
+        cursorY += dy;
+
+        float scaledX = cursorX * scaleFactor;
+        float scaledY = cursorY * scaleFactor;
+
+        if (commandId == 1) { // MoveTo
+          points.add(new PointData(scaledX, scaledY));
+        }
+      }
+    }
+    return points;
+  }
+
+  public class LineData {
+
+    public Path path;
+    public float centerX;
+    public float centerY;
+
+    public LineData(Path path, float centerX, float centerY) {
+      this.path = path;
+      this.centerX = centerX;
+      this.centerY = centerY;
+    }
+  }
+
+  private LineData createLinePath(List<Integer> geometryArray, float extent) {
+    Path path = new Path();
+    List<PointF> points = new ArrayList<>();
+    float[] lengths = new float[geometryArray.size() / 2]; // Approximate allocation
+    int lengthIndex = 0;
+    int index = 0;
+    float cursorX = 0;
+    float cursorY = 0;
+    float totalLength = 0;
+    float scaleFactor = this.tileSize / extent;
+
+    while (index < geometryArray.size()) {
+      int commandInteger = geometryArray.get(index++);
+      int commandId = commandInteger & 0x7;
+      int commandCount = commandInteger >> 3;
+
+      for (int i = 0; i < commandCount; ++i) {
+        int dx = ((geometryArray.get(index++) >> 1) ^ (-(geometryArray.get(index - 1) & 1)));
+        int dy = ((geometryArray.get(index++) >> 1) ^ (-(geometryArray.get(index - 1) & 1)));
+        cursorX += dx;
+        cursorY += dy;
+
+        float scaledX = cursorX * scaleFactor;
+        float scaledY = cursorY * scaleFactor;
+
+        if (commandId == 2) { // LineTo
+          path.lineTo(scaledX, scaledY);
+          PointF lastPoint = points.isEmpty() ? new PointF(0, 0) : points.get(points.size() - 1);
+          float segmentLength = (float) Math.sqrt(
+            Math.pow(scaledX - lastPoint.x, 2) + Math.pow(scaledY - lastPoint.y, 2)
+          );
+          totalLength += segmentLength;
+          lengths[lengthIndex++] = totalLength;
+        } else if (commandId == 1) { // MoveTo
+          path.moveTo(scaledX, scaledY);
+        }
+        points.add(new PointF(scaledX, scaledY));
+      }
+    }
+
+    // Find the midpoint along the length of the line
+    float midLength = totalLength / 2;
+    PointF labelPoint = new PointF();
+    for (int i = 1; i < lengthIndex; i++) {
+      if (lengths[i] >= midLength) {
+        float ratio = (midLength - lengths[i - 1]) / (lengths[i] - lengths[i - 1]);
+        labelPoint.x = points.get(i - 1).x + ratio * (points.get(i).x - points.get(i - 1).x);
+        labelPoint.y = points.get(i - 1).y + ratio * (points.get(i).y - points.get(i - 1).y);
+        break;
+      }
+    }
+    return new LineData(path, labelPoint.x, labelPoint.y);
+  }
+
+  private PolygonData createPolygonPath(List<Integer> geometryArray, float extent) {
+    Path path = new Path();
+    path.setFillType(Path.FillType.EVEN_ODD);
+    float totalX = 0;
+    float totalY = 0;
+    int pointCount = 0;
+    int index = 0;
+    float cursorX = 0;
+    float cursorY = 0;
+    float scaleFactor = this.tileSize / extent; // タイルのサイズ / extent
+
+    while (index < geometryArray.size()) {
+      int commandInteger = geometryArray.get(index++);
+      int commandId = commandInteger & 0x7; // lower 3 bits
+      int commandCount = commandInteger >> 3; // higher bits
+
+      switch (commandId) {
+        case 1: // MoveTo
+          for (int i = 0; i < commandCount; ++i) {
+            int dx = (geometryArray.get(index++) >> 1) ^ -(geometryArray.get(index - 1) & 1);
+            int dy = (geometryArray.get(index++) >> 1) ^ -(geometryArray.get(index - 1) & 1);
+
+            cursorX += dx;
+            cursorY += dy;
+
+            float scaledX = cursorX * scaleFactor;
+            float scaledY = cursorY * scaleFactor;
+
+            path.moveTo(scaledX, scaledY);
+            totalX += scaledX;
+            totalY += scaledY;
+            pointCount++;
+          }
+          break;
+        case 2: // LineTo
+          for (int i = 0; i < commandCount; ++i) {
+            int dx = (geometryArray.get(index++) >> 1) ^ -(geometryArray.get(index - 1) & 1);
+            int dy = (geometryArray.get(index++) >> 1) ^ -(geometryArray.get(index - 1) & 1);
+
+            cursorX += dx;
+            cursorY += dy;
+
+            float scaledX = cursorX * scaleFactor;
+            float scaledY = cursorY * scaleFactor;
+
+            path.lineTo(scaledX, scaledY);
+            totalX += scaledX;
+            totalY += scaledY;
+            pointCount++;
+          }
+          break;
+        case 7: // ClosePath
+          path.close();
+          break;
+        default:
+          // Unknown command, handle error
+          break;
+      }
+    }
+
+    float centerX = totalX / pointCount;
+    float centerY = totalY / pointCount;
+
+    return new PolygonData(path, centerX, centerY);
+  }
+
+  private String evaluateExpression(List<?> expression, Map<String, String> attributes) {
+    if (expression == null || expression.isEmpty()) {
+      return "";
+    }
+    
+    String operator = (String) expression.get(0);
+    
+    if ("get".equals(operator) && expression.size() >= 2) {
+      // ["get", "field_name"]
+      String fieldName = (String) expression.get(1);
+      return attributes.getOrDefault(fieldName, "");
+    } else if ("slice".equals(operator) && expression.size() >= 4) {
+      // ["slice", string_expression, start, end]
+      String sourceValue;
+      Object sourceExpr = expression.get(1);
+      if (sourceExpr instanceof String) {
+        sourceValue = (String) sourceExpr;
+      } else if (sourceExpr instanceof List) {
+        sourceValue = evaluateExpression((List<?>) sourceExpr, attributes);
+      } else {
+        sourceValue = "";
+      }
+      
+      try {
+        int start = ((Number) expression.get(2)).intValue();
+        int end = ((Number) expression.get(3)).intValue();
+        
+        if (start < 0) start = 0;
+        if (end > sourceValue.length()) end = sourceValue.length();
+        if (start > end) return "";
+        
+        return sourceValue.substring(start, end);
+      } catch (Exception e) {
+        return "";
+      }
+    }
+    
+    return "";
+  }
+  
+  private boolean checkFilter(List<?> filter, Map<String, String> attributes) {
+    if (filter == null) return true;
+    if (filter.size() == 3) {
+      //System.out.println("##filter: " + filter);
+      String op = (String) filter.get(0);
+      
+      // Evaluate the left operand (could be a string key or an expression)
+      Object leftOperand = filter.get(1);
+      String leftValue;
+      if (leftOperand instanceof String) {
+        leftValue = attributes.getOrDefault((String) leftOperand, "");
+      } else if (leftOperand instanceof List) {
+        leftValue = evaluateExpression((List<?>) leftOperand, attributes);
+      } else {
+        leftValue = "";
+      }
+      
+      // Evaluate the right operand
+      Object rightOperand = filter.get(2);
+      String rightValue;
+      if (rightOperand instanceof String) {
+        rightValue = (String) rightOperand;
+      } else if (rightOperand instanceof List) {
+        rightValue = evaluateExpression((List<?>) rightOperand, attributes);
+      } else {
+        rightValue = String.valueOf(rightOperand);
+      }
+      
+      if ("==".equals(op)) {
+        return leftValue.equals(rightValue);
+      } else if ("!=".equals(op)) {
+        return !leftValue.equals(rightValue);
+      } else if (">".equals(op)) {
+        return Float.parseFloat(leftValue) > Float.parseFloat(rightValue);
+      } else if (">=".equals(op)) {
+        return Float.parseFloat(leftValue) >= Float.parseFloat(rightValue);
+      } else if ("<".equals(op)) {
+        return Float.parseFloat(leftValue) < Float.parseFloat(rightValue);
+      } else if ("<=".equals(op)) {
+        return Float.parseFloat(leftValue) <= Float.parseFloat(rightValue);
+      } else if ("in".equals(op)) {
+        return rightValue.contains(leftValue);
+      } else if ("!in".equals(op)) {
+        return !rightValue.contains(leftValue);
+      } else if ("has".equals(op)) {
+        return !leftValue.isEmpty();
+      } else if ("!has".equals(op)) {
+        return leftValue.isEmpty();
+      }
+    }
+    return false;
+  }
+
+  private String computeDynamicColor(List<?> colors, Map<String, String> attributes) {
+    if (colors.size() > 0 && "match".equals(colors.get(0))) {
+      List<?> conditions = colors.subList(2, colors.size() - 1);
+      List<?> getFieldList = (List<?>) colors.get(1);
+      String field = (String) getFieldList.get(1);
+      String value = attributes.getOrDefault(field, "");
+      String defaultColor = (String) colors.get(colors.size() - 1);
+
+      for (int i = 0; i < conditions.size(); i += 2) {
+        String key = (String) conditions.get(i);
+        if (key.equals(value)) {
+          return (String) conditions.get(i + 1);
+        }
+      }
+      return defaultColor;
+    }
+    return null;
+  }
+
+  public void applyStyle(Canvas canvas, LayerStyle styleLayer, VectorSource source) {
+    String type = styleLayer.type;
+    //System.out.println("##applyStyle: " + type);
+    if ("circle".equals(type)) {
+      Paint circlePaint = new Paint();
+      Paint circleOutlinePaint = new Paint(); // 追加：アウトライン用のPaint
+
+      for (FeatureData feature : source.features) {
+        if (!(feature.geometry instanceof List<?>)) return;
+        Map<String, String> attributes = feature.attributes;
+        if (!checkFilter((List<?>) styleLayer.filter, attributes)) continue;
+        String circleColor = "#ff0000";
+        if (styleLayer.paint.circleColor instanceof String) {
+          circleColor = (String) styleLayer.paint.circleColor;
+        } else if (styleLayer.paint.circleColor instanceof List<?>) {
+          String dynamicColor = computeDynamicColor((List<?>) styleLayer.paint.circleColor, attributes);
+          if (dynamicColor != null) {
+            circleColor = dynamicColor;
+          }
+        }
+
+        circlePaint.setColor(Color.parseColor(circleColor));
+        circlePaint.setStyle(Paint.Style.FILL);
+        String outlineColor = circleColor;
+        if (styleLayer.paint.circleStrokeColor != null && styleLayer.paint.circleStrokeColor instanceof String) {
+          outlineColor = (String) styleLayer.paint.circleStrokeColor;
+        }
+        float strokeWidth = (Float) styleLayer.paint.circleStrokeWidth == null
+          ? 0
+          : styleLayer.paint.circleStrokeWidth * 2;
+        circleOutlinePaint.setColor(Color.parseColor(outlineColor));
+        circleOutlinePaint.setStyle(Paint.Style.STROKE);
+        circleOutlinePaint.setStrokeWidth(strokeWidth); // アウトラインの太さ
+
+        float circleRadius = (Float) styleLayer.paint.circleRadius == null ? 10 : styleLayer.paint.circleRadius * 2;
+        List<PointData> points = (List<PointData>) feature.geometry;
+        for (PointData point : points) {
+          float scaledX = point.x;
+          float scaledY = point.y;
+          canvas.drawCircle(scaledX, scaledY, circleRadius, circlePaint);
+          canvas.drawCircle(scaledX, scaledY, circleRadius, circleOutlinePaint); // アウトラインを描画
+        }
+      }
+    } else if ("line".equals(type)) {
+      //System.out.println("!!applyStyle: " + source.name);
+      Paint linePaint = new Paint();
+      for (FeatureData feature : source.features) {
+        Map<String, String> attributes = feature.attributes;
+        if (!checkFilter((List<?>) styleLayer.filter, attributes)) continue;
+        Path path;
+        if (feature.geometry instanceof LineData) {
+          LineData line = (LineData) feature.geometry;
+          path = line.path;
+        } else if (feature.geometry instanceof PolygonData) {
+          PolygonData polygon = (PolygonData) feature.geometry;
+          path = polygon.path;
+        } else {
+          return;
+        }
+
+        String lineColor = "#ff0000";
+        if (styleLayer.paint.lineColor instanceof String) {
+          lineColor = (String) styleLayer.paint.lineColor;
+        } else if (styleLayer.paint.lineColor instanceof List) {
+          String dynamicColor = computeDynamicColor((List<?>) styleLayer.paint.lineColor, attributes);
+          if (dynamicColor != null) {
+            lineColor = dynamicColor;
+          }
+        }
+        float lineWidth = (Float) styleLayer.paint.lineWidth == null ? 1 : styleLayer.paint.lineWidth;
+
+        linePaint.setColor(Color.parseColor(lineColor));
+        linePaint.setStyle(Paint.Style.STROKE);
+        linePaint.setStrokeWidth(lineWidth);
+        canvas.drawPath(path, linePaint);
+      }
+    } else if ("fill".equals(type)) {
+      Paint fillPaint = new Paint();
+      Paint strokePaint = new Paint();
+      for (FeatureData feature : source.features) {
+        if (!(feature.geometry instanceof PolygonData)) return;
+        PolygonData polygon = (PolygonData) feature.geometry;
+        Map<String, String> attributes = feature.attributes;
+        if (!checkFilter((List<?>) styleLayer.filter, attributes)) continue;
+        String fillColor = "#ffffffff";
+        if (styleLayer.paint.fillColor instanceof String) {
+          fillColor = (String) styleLayer.paint.fillColor;
+        } else if (styleLayer.paint.fillColor instanceof List) {
+          String dynamicColor = computeDynamicColor((List<?>) styleLayer.paint.fillColor, attributes);
+          if (dynamicColor != null) {
+            fillColor = dynamicColor;
+          }
+        }
+
+        fillPaint.setColor(Color.parseColor(fillColor));
+
+        float fillOpacity = (Float) styleLayer.paint.fillOpacity == null ? 1f : styleLayer.paint.fillOpacity;
+        fillPaint.setAlpha((int) (fillOpacity * 255)); // Set fill opacity for fillPaint only, after setting the color
+
+        fillPaint.setStyle(Paint.Style.FILL);
+
+        String outlineColor = fillColor;
+        if (styleLayer.paint.fillOutlineColor != null && styleLayer.paint.fillOutlineColor instanceof String) {
+          outlineColor = (String) styleLayer.paint.fillOutlineColor;
+        }
+        strokePaint.setColor(Color.parseColor(outlineColor));
+        strokePaint.setStyle(Paint.Style.STROKE);
+        strokePaint.setStrokeWidth(1);
+
+        // Draw the path
+        canvas.drawPath(polygon.path, fillPaint); // 塗りつぶし
+        canvas.drawPath(polygon.path, strokePaint); // ストローク
+      }
+    } else if ("symbol".equals(type)) {
+      List<Rect> drawnTextBounds = new ArrayList<>();
+      Paint textStrokePaint = new Paint();
+      Paint textFillPaint = new Paint();
+
+      for (FeatureData feature : source.features) {
+        Map<String, String> attributes = feature.attributes;
+        if (!checkFilter((List<?>) styleLayer.filter, attributes)) continue;
+        float X = 0;
+        float Y = 0;
+        if ((feature.geometry instanceof List<?>)) {
+          List<PointData> multiPoints = (List<PointData>) feature.geometry;
+          X = multiPoints.get(0).x;
+          Y = multiPoints.get(0).y;
+        } else if ((feature.geometry instanceof LineData)) {
+          LineData line = (LineData) feature.geometry;
+          X = line.centerX;
+          Y = line.centerY;
+        } else if ((feature.geometry instanceof PolygonData)) {
+          PolygonData polygon = (PolygonData) feature.geometry;
+          X = polygon.centerX;
+          Y = polygon.centerY;
+        }
+
+        int labelSize = (Integer) styleLayer.layout.textSize == null ? 16 : styleLayer.layout.textSize;
+        String labelHaloColor = styleLayer.paint.textHaloColor != null &&
+          styleLayer.paint.textHaloColor instanceof String
+          ? styleLayer.paint.textHaloColor
+          : "#FFFFFF";
+
+        float labelHaloWidth = (Float) styleLayer.paint.textHaloWidth == null ? 0 : styleLayer.paint.textHaloWidth;
+        String labelField = styleLayer.layout.textField.get(1);
+        if (attributes == null) continue;
+        String label = attributes.getOrDefault(labelField, "");
+
+        String labelColor = "#000000";
+        if (styleLayer.paint.textColor instanceof String) {
+          labelColor = (String) styleLayer.paint.textColor;
+        } else if (styleLayer.paint.textColor instanceof List) {
+          String dynamicColor = computeDynamicColor((List<?>) styleLayer.paint.textColor, attributes);
+          if (dynamicColor != null) {
+            labelColor = dynamicColor;
+          }
+        }
+
+        textFillPaint.setColor(Color.parseColor(labelColor));
+        textFillPaint.setTextSize(labelSize);
+        textFillPaint.setStyle(Paint.Style.FILL);
+        textFillPaint.setTextAlign(Paint.Align.CENTER);
+
+        textStrokePaint.setColor(Color.parseColor(labelHaloColor));
+        textStrokePaint.setTextSize(labelSize);
+        textStrokePaint.setStyle(Paint.Style.STROKE);
+        textStrokePaint.setStrokeWidth(labelHaloWidth);
+        textStrokePaint.setTextAlign(Paint.Align.CENTER);
+
+        Rect textBounds = new Rect();
+        textFillPaint.getTextBounds(label, 0, label.length(), textBounds);
+
+        float textWidth = textBounds.width();
+        float textHeight = textBounds.height();
+        float textX = X - textWidth / 2;
+        float textY = Y - textHeight / 2;
+
+        Rect newTextBounds = new Rect((int) textX, (int) textY, (int) (textX + textWidth), (int) (textY + textHeight));
+
+        boolean overlaps = false;
+        for (Rect existingBounds : drawnTextBounds) {
+          if (Rect.intersects(existingBounds, newTextBounds)) {
+            overlaps = true;
+            break;
+          }
+        }
+
+        if (!overlaps) {
+          canvas.drawText(label, X, Y, textStrokePaint);
+          canvas.drawText(label, X, Y, textFillPaint);
+
+          drawnTextBounds.add(newTextBounds);
+        }
+      }
+    } else {
+      return;
+    }
+  }
+
+  public class VectorSource {
+
+    public String name;
+    public List<FeatureData> features;
+
+    public VectorSource(String name, List<FeatureData> features) {
+      this.name = name;
+      this.features = features;
+    }
+  }
+
+  public class FeatureData {
+
+    public Map<String, String> attributes;
+    public Object geometry;
+
+    public FeatureData(Map<String, String> attributes, Object geometry) {
+      this.attributes = attributes;
+      this.geometry = geometry;
+    }
+  }
+
+  public VectorSource getVectorSource(String layerName, List<VectorSource> sources) {
+    for (VectorSource source : sources) {
+      if (source.name.equals(layerName)) {
+        return source;
+      }
+    }
+    return null; // or throw new NoSuchElementException("No VectorSource found with name: " + layerName);
+  }
+
+  public Tile getVectorTile(int x, int y, int zoom) {
+    try {
+      byte[] pbfData = null;
+      if (this.tileCachePath != null) {
+        pbfData = readPbfData(x, y, zoom);
+        // if (pbfData != null && !this.offlineMode) {
+        //   boolean needRefresh = checkForRefresh(x, y, zoom);
+        //   if (needRefresh) {
+        //     pbfData = null;
+        //   }
+        // }
+      }
+      //Log.d("urlTile", pbfData == null ? "null" : "not null");
+      if (pbfData == null) {
+        if (this.offlineMode) return null;
+        if (this.tileType == 0) {
+          pbfData = fetchPbf(zoom, x, y);
+        } else {
+          CompletableFuture<Optional<RangeResponse>> futureTileData = pmtiles.getZxy(zoom, x, y);
+          Optional<RangeResponse> optionalRangeResponse = futureTileData.get();
+
+          if (!optionalRangeResponse.isPresent()) return null;
+          RangeResponse rangeResponse = optionalRangeResponse.get();
+          pbfData = rangeResponse.data.array();
+        }
+        if (pbfData != null) {
+          boolean success = writePbfData(pbfData, x, y, zoom);
+        }
+      }
+
+      List<VectorSource> sources = new ArrayList<>(); // Initialize sources list
+      try {
+        VectorTile.Tile decodedTile = VectorTile.Tile.parseFrom(pbfData);
+        for (VectorTile.Tile.Layer layer : decodedTile.getLayersList()) {
+          float layerExtent = layer.getExtent();
+          List<FeatureData> features = new ArrayList<>();
+          for (VectorTile.Tile.Feature feature : layer.getFeaturesList()) {
+            Map<String, String> attributes = getFeatureAttributes(layer, feature);
+            Object geometry = null;
+            if (feature.getType() == VectorTile.Tile.GeomType.POINT) {
+              geometry = createMultiPointData(feature.getGeometryList(), layerExtent);
+            } else if (feature.getType() == VectorTile.Tile.GeomType.LINESTRING) {
+              geometry = createLinePath(feature.getGeometryList(), layerExtent);
+            } else if (feature.getType() == VectorTile.Tile.GeomType.POLYGON) { // ポリゴンのみを処理
+              geometry = createPolygonPath(feature.getGeometryList(), layerExtent);
+            }
+            if (geometry != null) {
+              FeatureData featureData = new FeatureData(attributes, geometry);
+              features.add(featureData);
+            }
+          }
+          if (features.size() > 0) {
+            //Log.d("urlTile", "!!create source: " + layer.getName());
+            VectorSource newSource = new VectorSource(layer.getName(), features);
+            sources.add(newSource);
+          }
+        }
+      } catch (InvalidProtocolBufferException e) {
+        //e.printStackTrace();
+        //Log.d("urlTile", "!!create source error: " + e.getMessage());
+        // エラーハンドリングのロジック
+      }
+      Bitmap image = Bitmap.createBitmap(tileSize, tileSize, Bitmap.Config.ARGB_8888);
+      image.eraseColor(Color.TRANSPARENT);
+      Canvas canvas = new Canvas(image);
+      //Log.d("urlTile", "##" + sources.size());
+      List<LayerStyle> styles = styleManager.getStyleLayers();
+      if (styles.size() == 0) styles = styleManager.getDefaultStyleLayers(this.metadata);
+      for (LayerStyle styleLayer : styles) {
+        //Log.d("urlTile", "##" + styleLayer);
+        VectorSource source = getVectorSource(styleLayer.sourceLayer, sources);
+        if (source == null) continue;
+
+        double actualMinzoom = (Integer) styleLayer.minzoom != null ? styleLayer.minzoom : 0;
+        double actualMaxzoom = (Integer) styleLayer.maxzoom != null ? styleLayer.maxzoom : 22;
+
+        if (actualMinzoom > zoom || actualMaxzoom < zoom) continue;
+
+        applyStyle(canvas, styleLayer, source);
+      }
+      byte[] tileImage = bitmapToByteArray(image);
+      image.recycle();
+      return new Tile(tileSize, tileSize, tileImage);
+    } catch (Exception e) {
+      // CompletableFuture#get()の例外処理
+      //e.printStackTrace();
+      //Log.d("urlTile", "!!An error occurred: " + e.getMessage());
+      return null;
+    }
+  }
+
+  //ラスター用
+  public Tile getRasterTile(int x, int y, int zoom) {
+    CompletableFuture<Optional<RangeResponse>> futureTileData = pmtiles.getZxy(zoom, x, y);
+
+    try {
+      Optional<RangeResponse> optionalRangeResponse = futureTileData.get();
+
+      if (optionalRangeResponse.isPresent()) {
+        RangeResponse rangeResponse = optionalRangeResponse.get();
+        byte[] tileData = rangeResponse.data.array();
+
+        return new Tile(tileSize, tileSize, tileData);
+      } else {
+        return null;
+      }
+    } catch (InterruptedException | ExecutionException e) {
+      // CompletableFuture#get()の例外処理
+      e.printStackTrace();
+      return null;
+    }
+  }
+
+  byte[] fetchTile(int x, int y, int zoom) {
+    Tile tile = null;
+    if (this.tileType == 0 || this.tileType == 1) {
+      tile = getVectorTile(x, y, zoom);
+    } else if (this.tileType == 2 || this.tileType == 3) {
+      tile = getRasterTile(x, y, zoom);
+    }
+    if (Objects.isNull(tile)) {
+      // Log.d("urlTileA:NO_TILE", getTileFilename(x, y, zoom));
+      return null;
+    }
+    return tile.data;
+  }
+
+  byte[] fetchPbf(int zoom, int x, int y) {
+    String url =
+      this.urlTemplate.replace("{z}", Integer.toString(zoom))
+        .replace("{x}", Integer.toString(x))
+        .replace("{y}", Integer.toString(y));
+    // Log.d("urlTileA", url);
+    try {
+      URL urlObj = new URL(url);
+      HttpURLConnection connection = (HttpURLConnection) urlObj.openConnection();
+      connection.setRequestMethod("GET");
+      connection.setDoInput(true);
+      connection.connect();
+      InputStream input = connection.getInputStream();
+      ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+      byte[] data = new byte[BUFFER_SIZE];
+      int nRead;
+      while ((nRead = input.read(data, 0, BUFFER_SIZE)) != -1) {
+        buffer.write(data, 0, nRead);
+      }
+      buffer.flush();
+      return buffer.toByteArray();
+    } catch (IOException e) {
+      e.printStackTrace();
+      return null;
+    }
+  }
+
+  byte[] readPbfData(int x, int y, int zoom) {
+    String fileName = getPbfFilename(x, y, zoom); // このメソッドは実装による
+    if (fileName == null) {
+      return null;
+    }
+
+    File file = new File(fileName);
+
+    try {
+      StringBuilder stringBuilder = new StringBuilder();
+      try (
+        BufferedReader reader = new BufferedReader(
+          new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8)
+        )
+      ) {
+        String line;
+        while ((line = reader.readLine()) != null) {
+          stringBuilder.append(line);
+        }
+      }
+
+      // ここでBase64デコード
+      byte[] decodedData = Base64.getDecoder().decode(stringBuilder.toString());
+      return decodedData;
+    } catch (IOException e) {
+      e.printStackTrace();
+      return null;
+    }
+  }
+
+  byte[] readTileImage(int x, int y, int zoom) {
+    InputStream in = null;
+    ByteArrayOutputStream buffer = null;
+    String fileName = getTileFilename(x, y, zoom);
+    if (fileName == null) {
+      return null;
+    }
+
+    File file = new File(fileName);
+
+    try {
+      in = new FileInputStream(file);
+      buffer = new ByteArrayOutputStream();
+
+      int nRead;
+      byte[] data = new byte[BUFFER_SIZE];
+
+      while ((nRead = in.read(data, 0, BUFFER_SIZE)) != -1) {
+        buffer.write(data, 0, nRead);
+      }
+      buffer.flush();
+
+      if (this.tileCacheMaxAge == 0) {
+        file.setLastModified(System.currentTimeMillis());
+      }
+
+      return buffer.toByteArray();
+    } catch (IOException e) {
+      e.printStackTrace();
+      return null;
+    } catch (OutOfMemoryError e) {
+      e.printStackTrace();
+      return null;
+    } finally {
+      if (in != null) try {
+        in.close();
+      } catch (Exception ignored) {}
+      if (buffer != null) try {
+        buffer.close();
+      } catch (Exception ignored) {}
+    }
+  }
+
+  boolean writePbfData(byte[] pbf, int x, int y, int zoom) {
+    OutputStream out = null;
+    String fileName = getPbfFilename(x, y, zoom); // このメソッドは実装による
+    if (fileName == null) {
+      return false;
+    }
+
+    try {
+      // バイトデータをBase64でエンコード
+      String base64Image = Base64.getEncoder().encodeToString(pbf);
+
+      File file = new File(fileName);
+      file.getParentFile().mkdirs();
+      out = new FileOutputStream(file);
+
+      // Base64文字列をバイト配列に変換してファイルに書き出し
+      out.write(base64Image.getBytes());
+
+      return true;
+    } catch (IOException e) {
+      e.printStackTrace();
+      return false;
+    } finally {
+      if (out != null) try {
+        out.close();
+      } catch (Exception ignored) {}
+    }
+  }
+
+  boolean writeTileImage(byte[] image, int x, int y, int zoom) {
+    OutputStream out = null;
+    String fileName = getTileFilename(x, y, zoom);
+    if (fileName == null) {
+      return false;
+    }
+
+    try {
+      File file = new File(fileName);
+      file.getParentFile().mkdirs();
+      out = new FileOutputStream(file);
+      out.write(image);
+
+      return true;
+    } catch (IOException e) {
+      e.printStackTrace();
+      return false;
+    } catch (OutOfMemoryError e) {
+      e.printStackTrace();
+      return false;
+    } finally {
+      if (out != null) try {
+        out.close();
+      } catch (Exception ignored) {}
+    }
+  }
+
+  String getPbfFilename(int x, int y, int zoom) {
+    if (this.tileCachePath == null) {
+      return null;
+    }
+    String s =
+      this.tileCachePath +
+      '/' +
+      Integer.toString(zoom) +
+      "/" +
+      Integer.toString(x) +
+      "/" +
+      Integer.toString(y) +
+      ".pbf";
+    return s;
+  }
+
+  String getTileFilename(int x, int y, int zoom) {
+    if (this.tileCachePath == null) {
+      return null;
+    }
+    String s =
+      this.tileCachePath + '/' + Integer.toString(zoom) + "/" + Integer.toString(x) + "/" + Integer.toString(y);
+    return s;
+  }
+
+  public void setUrlTemplate(String urlTemplate) {
+    this.urlTemplate = urlTemplate;
+  }
+
+  public void setStyleURL(String styleURL) {
+    this.styleURL = styleURL;
+  }
+
+  public void setTileSize(int tileSize) {
+    this.tileSize = tileSize;
+  }
+
+  public void setDoubleTileSize(boolean doubleTileSize) {
+    this.doubleTileSize = doubleTileSize;
+  }
+
+  public void setMaximumZ(int maximumZ) {
+    this.maximumZ = maximumZ;
+  }
+
+  public void setMaximumNativeZ(int maximumNativeZ) {
+    this.maximumNativeZ = maximumNativeZ;
+  }
+
+  public void setMinimumZ(int minimumZ) {
+    this.minimumZ = minimumZ;
+  }
+
+  public void setFlipY(boolean flipY) {
+    this.flipY = flipY;
+  }
+
+  public void setTileCachePath(String tileCachePath) {
+    this.tileCachePath = tileCachePath;
+  }
+
+  public void setTileCacheMaxAge(int tileCacheMaxAge) {
+    this.tileCacheMaxAge = tileCacheMaxAge;
+  }
+
+  public void setOfflineMode(boolean offlineMode) {
+    this.offlineMode = offlineMode;
+  }
+
+  public void setIsVector(boolean isVector) {
+    this.isVector = isVector;
+  }
+
+  public void setCustomMode() {
+    this.customMode = customMode;
+  }
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapTileProvider.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapTileProvider.java
index 2b1a646..044c72e 100644
--- a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapTileProvider.java
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapTileProvider.java
@@ -1,49 +1,52 @@
 package com.rnmaps.maps;
 
 import android.content.Context;
-
-import android.util.Log;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.Future;
-import java.util.List;
-
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.graphics.Canvas;
 import android.graphics.Color;
 import android.graphics.Paint;
 import android.graphics.Rect;
-
-import androidx.work.OneTimeWorkRequest;
-import androidx.work.WorkManager;
-import androidx.work.Data;
+import android.util.Log;
+import androidx.annotation.NonNull;
 import androidx.work.Constraints;
-import androidx.work.NetworkType;
+import androidx.work.Data;
 import androidx.work.ExistingWorkPolicy;
+import androidx.work.NetworkType;
+import androidx.work.OneTimeWorkRequest;
 import androidx.work.Operation;
 import androidx.work.WorkInfo;
-
+import androidx.work.WorkManager;
+import androidx.work.WorkRequest;
+import androidx.work.Worker;
+import androidx.work.WorkerParameters;
+import com.google.android.gms.maps.GoogleMap;
 import com.google.android.gms.maps.model.Tile;
+import com.google.android.gms.maps.model.TileOverlay;
+import com.google.android.gms.maps.model.TileOverlayOptions;
 import com.google.android.gms.maps.model.TileProvider;
 import com.google.android.gms.maps.model.UrlTileProvider;
-
-import java.lang.System;
-
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
+import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.io.IOException;
-
+import java.lang.System;
+import java.net.HttpURLConnection;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.net.URLConnection;
+import java.util.List;
+import java.util.Objects;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
 
 public class MapTileProvider implements TileProvider {
 
-	class AIRMapUrlTileProvider extends UrlTileProvider {
+  class AIRMapUrlTileProvider extends UrlTileProvider {
+
     private String urlTemplate;
 
     public AIRMapUrlTileProvider(int width, int height, String urlTemplate) {
@@ -53,23 +56,22 @@ public class MapTileProvider implements TileProvider {
 
     @Override
     public URL getTileUrl(int x, int y, int zoom) {
-
-      if (MapTileProvider.this.flipY) {
+      if (MapTileProvider.this.flipY == true) {
         y = (1 << zoom) - y - 1;
       }
 
-      String s = this.urlTemplate
-          .replace("{x}", Integer.toString(x))
+      String s =
+        this.urlTemplate.replace("{x}", Integer.toString(x))
           .replace("{y}", Integer.toString(y))
           .replace("{z}", Integer.toString(zoom));
-      URL url;
+      URL url = null;
 
-      if(MapTileProvider.this.maximumZ > 0 && zoom > MapTileProvider.this.maximumZ) {
-        return null;
+      if (MapTileProvider.this.maximumZ > 0 && zoom > MapTileProvider.this.maximumZ) {
+        return url;
       }
 
-      if(MapTileProvider.this.minimumZ > 0 && zoom < MapTileProvider.this.minimumZ) {
-        return null;
+      if (MapTileProvider.this.minimumZ > 0 && zoom < MapTileProvider.this.minimumZ) {
+        return url;
       }
 
       try {
@@ -85,188 +87,236 @@ public class MapTileProvider implements TileProvider {
     }
   }
 
-	protected static final int BUFFER_SIZE = 16 * 1024;
-	protected static final int TARGET_TILE_SIZE = 512;
-	protected UrlTileProvider tileProvider;
-	protected String urlTemplate;
-	protected int tileSize;
+  protected static final int BUFFER_SIZE = 16 * 1024;
+  // protected static final int TARGET_TILE_SIZE = 512;
+  protected UrlTileProvider tileProvider;
+  protected String urlTemplate;
+  protected int tileSize;
   protected boolean doubleTileSize;
-	protected int maximumZ;
+  protected int maximumZ;
   protected int maximumNativeZ;
   protected int minimumZ;
   protected boolean flipY;
-	protected String tileCachePath;
-	protected int tileCacheMaxAge;
+  protected String tileCachePath;
+  protected int tileCacheMaxAge;
   protected boolean offlineMode;
-	protected Context context;
-	protected boolean customMode;
-
-	public MapTileProvider(int tileSizet, boolean doubleTileSize, String urlTemplate,
-                           int maximumZ, int maximumNativeZ, int minimumZ, boolean flipY, String tileCachePath,
-                           int tileCacheMaxAge, boolean offlineMode, Context context, boolean customMode) {
-		this.tileProvider = new AIRMapUrlTileProvider(tileSizet, tileSizet, urlTemplate);
-
-		this.tileSize = tileSizet;
+  protected Context context;
+  protected boolean customMode;
+
+  public MapTileProvider(
+    int tileSizet,
+    boolean doubleTileSize,
+    String urlTemplate,
+    int maximumZ,
+    int maximumNativeZ,
+    int minimumZ,
+    boolean flipY,
+    String tileCachePath,
+    int tileCacheMaxAge,
+    boolean offlineMode,
+    Context context,
+    boolean customMode
+  ) {
+    this.tileProvider = new AIRMapUrlTileProvider(tileSizet, tileSizet, urlTemplate);
+
+    this.tileSize = tileSizet;
     this.doubleTileSize = doubleTileSize;
-		this.urlTemplate = urlTemplate;
-		this.maximumZ = maximumZ;
+    this.urlTemplate = urlTemplate;
+    this.maximumZ = maximumZ;
     this.maximumNativeZ = maximumNativeZ;
-		this.minimumZ = minimumZ;
-		this.flipY = flipY;
-		this.tileCachePath = tileCachePath;
-		this.tileCacheMaxAge = tileCacheMaxAge;
+    this.minimumZ = minimumZ;
+    this.flipY = flipY;
+    this.tileCachePath = tileCachePath;
+    this.tileCacheMaxAge = tileCacheMaxAge;
     this.offlineMode = offlineMode;
-		this.context = context;
-		this.customMode = customMode;
-	}
-
-	@Override
-	public Tile getTile(int x, int y, int zoom) {
-		if (!this.customMode) return this.tileProvider.getTile(x, y, zoom);
-
-		byte[] image = null;
-		int maximumZ = this.maximumZ > 0 ? this.maximumZ : Integer.MAX_VALUE;
-		
-		if (this.tileSize == 256 && this.doubleTileSize && zoom + 1 <= this.maximumNativeZ && zoom + 1 <= maximumZ) {
-      Log.d("urlTile", "pullTilesFromHigherZoom");
-			image = pullTilesFromHigherZoom(x, y, zoom);      
-		} 
-
-    if (zoom > this.maximumNativeZ) {
-      Log.d("urlTile", "scaleLowerZoomTile");
-			image = scaleLowerZoomTile(x, y, zoom, this.maximumNativeZ);
-		}
-
-    if (image == null && zoom <= maximumZ) {
-      Log.d("urlTile", "getTileImage");
-			image = getTileImage(x, y, zoom);
-		}
-
-    if (image == null && this.tileCachePath != null && this.offlineMode) {
-      Log.d("urlTile", "findLowerZoomTileForScaling");
-      int zoomLevelToStart = (zoom > this.maximumNativeZ) ? this.maximumNativeZ - 1 : zoom - 1; 
-      int minimumZoomToSearch = Math.max(this.minimumZ, zoom - 3);
-      for (int tryZoom = zoomLevelToStart; tryZoom >= minimumZoomToSearch; tryZoom--) {
-  			image = scaleLowerZoomTile(x, y, zoom, tryZoom);
-	  		if (image != null) {
-		  		break;
-			  }
+    this.context = context;
+    this.customMode = customMode;
+  }
+
+  @Override
+  public Tile getTile(int x, int y, int zoom) {
+    if (!this.customMode) return this.tileProvider.getTile(x, y, zoom);
+
+    byte[] image = null;
+    int maximumZ = this.maximumZ > 0 ? this.maximumZ : Integer.MAX_VALUE;
+
+    if (this.maximumZ == 0 || zoom > this.maximumZ) return null;
+    int drawType = 0; // 0:original 1:high-resolution 2:overzoom
+    if (zoom < this.minimumZ) {
+      //Log.d("RNM:", "A");
+      image = generateTileFromHigherZoom(x, y, zoom);
+      drawType = 1;
+    } else if (zoom > this.maximumNativeZ && !this.doubleTileSize) {
+      //Log.d("RNM:", "B");
+      image = drawOverZoomTile(x, y, zoom, this.maximumNativeZ);
+      drawType = 2;
+    } else if (zoom > this.maximumNativeZ - 1 && this.doubleTileSize) {
+      //Log.d("RNM:", "C");
+      image = drawOverZoomTile(x, y, zoom, this.maximumNativeZ);
+      drawType = 2;
+    } else if (zoom <= maximumZ && !this.doubleTileSize) {
+      //Log.d("RNM:", "D");
+      image = getTileImage(x, y, zoom);
+      drawType = 0;
+    } else if (zoom <= this.maximumNativeZ - 1 && this.doubleTileSize) {
+      //Log.d("RNM:", "E");
+      image = drawDoubleSizeTile(x, y, zoom);
+      drawType = 0;
+    }
+
+    // if (image == null && this.tileCachePath != null && this.offlineMode && drawType == 0) {
+    //   //Log.d("urlTile", "findLowerZoomTileForScaling");
+    //   int zoomLevelToStart = (zoom > this.maximumNativeZ) ? this.maximumNativeZ - 1 : zoom - 1;
+    //   int minimumZoomToSearch = this.minimumZ >= zoom - 3 ? this.minimumZ : zoom - 3;
+    //   for (int tryZoom = zoomLevelToStart; tryZoom >= minimumZoomToSearch; tryZoom--) {
+    //     image = drawOverZoomTile(x, y, zoom, tryZoom);
+    //     if (image != null) {
+    //       break;
+    //     }
+    //   }
+    // }
+
+    return image == null ? null : new Tile(this.tileSize, this.tileSize, image);
+  }
+
+  byte[] getTileImage(int x, int y, int zoom) {
+    byte[] image = null;
+    if (this.tileCachePath != null) {
+      image = readTileImage(x, y, zoom);
+      // if (image != null && !this.offlineMode) {
+      //   boolean needRefresh = checkForRefresh(x, y, zoom);
+      //   if (needRefresh) {
+      //     image = null;
+      //   }
+      // }
+    }
+    if (image == null && !this.offlineMode && this.tileCachePath != null) {
+      // Log.d("urlTile", "Normal fetch");
+      image = fetchTile(x, y, zoom);
+      if (image != null) {
+        boolean success = writeTileImage(image, x, y, zoom);
       }
-		}
-
-		return image == null ? null : new Tile(this.tileSize, this.tileSize, image);
-	}
-
-	byte[] getTileImage(int x, int y, int zoom) {
-		byte[] image = null;
-
-		if (this.tileCachePath != null) {
-			image = readTileImage(x, y, zoom);
-			if (image != null) {
-				Log.d("urlTile", "tile cache HIT for " + zoom +
-					"/" + x + "/" + y);
-			} else {
-				Log.d("urlTile", "tile cache MISS for " + zoom +
-        	"/" + x + "/" + y);
-			}
-			if (image != null && !this.offlineMode) {
-				checkForRefresh(x, y, zoom);
-			}
-		}
-
-		if (image == null && !this.offlineMode && this.tileCachePath != null) {
-			String fileName = getTileFilename(x, y, zoom);
-			Constraints constraints = new Constraints.Builder()
-				.setRequiredNetworkType(NetworkType.CONNECTED)
-				.build();
-			OneTimeWorkRequest tileRefreshWorkRequest = new OneTimeWorkRequest.Builder(MapTileWorker.class)
-				.setConstraints(constraints)
-				.addTag(fileName)
-				.setInputData(
-					new Data.Builder()
-						.putString("url", getTileUrl(x, y, zoom).toString())
-						.putString("filename", fileName)
-						.putInt("maxAge", -1)
-						.build()
-					)
-				.build();
-			WorkManager workManager = WorkManager.getInstance(this.context.getApplicationContext());
-			Operation fetchOperation = workManager
-				.enqueueUniqueWork(fileName, ExistingWorkPolicy.KEEP, tileRefreshWorkRequest);
-			Future<Operation.State.SUCCESS> operationFuture = fetchOperation.getResult();
-			try {
-				operationFuture.get(1L, TimeUnit.SECONDS);
-				Thread.sleep(500);
-				Future<List<WorkInfo>> fetchFuture = workManager.getWorkInfosByTag(fileName);
-				List<WorkInfo> workInfo = fetchFuture.get(1L, TimeUnit.SECONDS);
-				Log.d("urlTile: ", workInfo.get(0).toString());
-				if (this.tileCachePath != null) {
-					image = readTileImage(x, y, zoom);
-					if (image != null) {
-						Log.d("urlTile","tile cache fetch HIT for " + zoom +
-							"/" + x + "/" + y);
-					} else {
-							Log.d("urlTile","tile cache fetch MISS for " + zoom +
-								"/" + x + "/" + y);
-					}
-				}
-			} catch (Exception e) {
-			  e.printStackTrace();
-			}
-		} else if (image == null && !this.offlineMode) {
-			Log.d("urlTile", "Normal fetch");
-			image = fetchTile(x, y, zoom);
-			if (image == null) {
-				Log.d("urlTile", "tile fetch TIMEOUT / FAIL for " + zoom +
-					"/" + x + "/" + y);
-			}
-		}
-
-		return image;
-	}
-
-	byte[] pullTilesFromHigherZoom(int x, int y, int zoom) {
+    }
+    return image;
+  }
+
+  byte[] drawDoubleSizeTile(int x, int y, int zoom) {
     byte[] data;
-    Bitmap image = getNewBitmap();
+    Bitmap image = getNewBitmap(this.tileSize * 2, this.tileSize * 2);
     Canvas canvas = new Canvas(image);
     Paint paint = new Paint();
 
-    x = x * 2;
-    y = y * 2;
-    byte[] leftTop = getTileImage(x, y, zoom + 1);
-    byte[] leftBottom = getTileImage(x, y + 1, zoom + 1);
-    byte[] rightTop = getTileImage(x + 1, y, zoom + 1);
-    byte[] rightBottom = getTileImage(x + 1, y + 1, zoom + 1);
+    int X = x * 2;
+    int Y = y * 2;
+    int Z = zoom + 1;
+    byte[] leftTop = getTileImage(X, Y, Z);
+    byte[] leftBottom = getTileImage(X, Y + 1, Z);
+    byte[] rightTop = getTileImage(X + 1, Y, Z);
+    byte[] rightBottom = getTileImage(X + 1, Y + 1, Z);
 
-    if (leftTop == null || leftBottom == null || rightTop == null || rightBottom == null) {
+    if (leftTop == null && leftBottom == null && rightTop == null && rightBottom == null) {
       return null;
     }
 
     Bitmap bitmap;
+    if (leftTop != null) {
+      bitmap = BitmapFactory.decodeByteArray(leftTop, 0, leftTop.length);
+      if (bitmap != null) {
+        canvas.drawBitmap(bitmap, 0, 0, paint);
+        bitmap.recycle();
+      }
+    }
+    if (leftBottom != null) {
+      bitmap = BitmapFactory.decodeByteArray(leftBottom, 0, leftBottom.length);
+      if (bitmap != null) {
+        canvas.drawBitmap(bitmap, 0, this.tileSize, paint);
+        bitmap.recycle();
+      }
+    }
+    if (rightTop != null) {
+      bitmap = BitmapFactory.decodeByteArray(rightTop, 0, rightTop.length);
+      if (bitmap != null) {
+        canvas.drawBitmap(bitmap, this.tileSize, 0, paint);
+        bitmap.recycle();
+      }
+    }
+    if (rightBottom != null) {
+      bitmap = BitmapFactory.decodeByteArray(rightBottom, 0, rightBottom.length);
+      if (bitmap != null) {
+        canvas.drawBitmap(bitmap, this.tileSize, this.tileSize, paint);
+        bitmap.recycle();
+      }
+    }
+    data = bitmapToByteArray(image);
+    image.recycle();
+    return data;
+  }
 
-    bitmap = BitmapFactory.decodeByteArray(leftTop, 0, leftTop.length);
-    canvas.drawBitmap(bitmap, 0, 0, paint);
-    bitmap.recycle();
+  byte[] generateTileFromHigherZoom(int x, int y, int zoom) {
+    int X = x * 2;
+    int Y = y * 2;
+    int Z = zoom + 1;
+    byte[] leftTop = getTileImage(X, Y, Z);
+    byte[] leftBottom = getTileImage(X, Y + 1, Z);
+    byte[] rightTop = getTileImage(X + 1, Y, Z);
+    byte[] rightBottom = getTileImage(X + 1, Y + 1, Z);
+    // Log.d(
+    //   "urlTile",
+    //   "##" + x + " " + y + " " + zoom + " " + leftTop + " " + leftBottom + " " + rightTop + " " + rightBottom
+    // );
+
+    if (leftTop == null && leftBottom == null && rightTop == null && rightBottom == null) {
+      // Log.d("urlTile", "generateTileFromHigherZoom: null " + x + " " + y + " " + zoom);
+      return null;
+    }
     
-    bitmap = BitmapFactory.decodeByteArray(leftBottom, 0, leftBottom.length);
-    canvas.drawBitmap(bitmap, 0, 256, paint);
-    bitmap.recycle();
+    int width = this.tileSize;
+    int height = this.tileSize;
+    //Log.d("######urlTile 2", width + " " + height);
+    byte[] data;
+    Paint paint = new Paint();
+    Bitmap combinedBitmap = getNewBitmap(width, height);
+    Canvas canvas = new Canvas(combinedBitmap);
+
+    if (leftTop != null) {
+      //Log.d("urlTile", "$$" + X + " " + Y + " " + Z);
+      Bitmap bitmapLeftTop = BitmapFactory.decodeByteArray(leftTop, 0, leftTop.length);
+      if (bitmapLeftTop != null) {
+        canvas.drawBitmap(bitmapLeftTop, null, new Rect(0, 0, width / 2, height / 2), paint);
+      }
+    }
+    if (leftBottom != null) {
+      //Log.d("urlTile", "$$" + X + " " + (Y + 1) + " " + Z + " " + leftBottom.length);
+      Bitmap bitmapLeftBottom = BitmapFactory.decodeByteArray(leftBottom, 0, leftBottom.length);
+      if (bitmapLeftBottom != null) {
+        canvas.drawBitmap(bitmapLeftBottom, null, new Rect(0, height / 2, width / 2, height), paint);
+      }
+    }
+    if (rightTop != null) {
+      //Log.d("urlTile", "$$" + (X + 1) + " " + Y + " " + Z + " " + rightTop.length);
+      Bitmap bitmapRightTop = BitmapFactory.decodeByteArray(rightTop, 0, rightTop.length);
+      if (bitmapRightTop != null) {
+        canvas.drawBitmap(bitmapRightTop, null, new Rect(width / 2, 0, width, height / 2), paint);
+      }
+    }
+    if (rightBottom != null) {
+      //Log.d("urlTile", "$$" + (X + 1) + " " + (Y + 1) + " " + Z + " " + rightBottom.length);
+      Bitmap bitmapRightBottom = BitmapFactory.decodeByteArray(rightBottom, 0, rightBottom.length);
+      if (bitmapRightBottom != null) {
+        canvas.drawBitmap(bitmapRightBottom, null, new Rect(width / 2, height / 2, width, height), paint);
+      }
+    }
     
-    bitmap = BitmapFactory.decodeByteArray(rightTop, 0, rightTop.length);
-    canvas.drawBitmap(bitmap, 256, 0, paint);
-    bitmap.recycle();
+    data = bitmapToByteArray(combinedBitmap);
+    combinedBitmap.recycle();
   
-    bitmap = BitmapFactory.decodeByteArray(rightBottom, 0, rightBottom.length);
-    canvas.drawBitmap(bitmap, 256, 256, paint);
-    bitmap.recycle();
+    boolean success = writeTileImage(data, x, y, zoom);
     
-    data = bitmapToByteArray(image);
-    image.recycle();
     return data;
   }
 
-  Bitmap getNewBitmap() {
-    Bitmap image = Bitmap.createBitmap(TARGET_TILE_SIZE, TARGET_TILE_SIZE, Bitmap.Config.ARGB_8888);
+  Bitmap getNewBitmap(int width, int height) {
+    Bitmap image = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
     image.eraseColor(Color.TRANSPARENT);
     return image;
   }
@@ -279,12 +329,12 @@ public class MapTileProvider implements TileProvider {
     try {
       bos.close();
     } catch (Exception e) {
-      e.printStackTrace();
+      // e.printStackTrace();
     }
     return data;
   }
 
-	byte[] scaleLowerZoomTile(int x, int y, int zoom, int maximumZoom) {
+  byte[] drawOverZoomTile(int x, int y, int zoom, int maximumZoom) {
     int overZoomLevel = zoom - maximumZoom;
     int zoomFactor = 1 << overZoomLevel;
     
@@ -294,197 +344,208 @@ public class MapTileProvider implements TileProvider {
     
     int xOffset = x % zoomFactor;
     int yOffset = y % zoomFactor;
-
     byte[] data;
-    Bitmap image = getNewBitmap();
+
+    // if (overZoomLevel > 3) {
+    //   return null;
+    // }
+    Bitmap image = getNewBitmap(this.tileSize, this.tileSize);
     Canvas canvas = new Canvas(image);
     Paint paint = new Paint();
+    data = getTileImage(xParent, yParent, zoomParent);
 
-		data = getTileImage(xParent, yParent, zoomParent);
     if (data == null) return null;
-    
     Bitmap sourceImage;
-    sourceImage = BitmapFactory.decodeByteArray(data, 0, data.length);
 
+    sourceImage = BitmapFactory.decodeByteArray(data, 0, data.length);
     int subTileSize = this.tileSize / zoomFactor;
-    Rect sourceRect = new Rect(xOffset * subTileSize, yOffset * subTileSize, xOffset * subTileSize + subTileSize , yOffset * subTileSize + subTileSize);
-    Rect targetRect = new Rect(0,0,TARGET_TILE_SIZE, TARGET_TILE_SIZE);
+
+    Rect sourceRect = new Rect(
+      xOffset * subTileSize,
+      yOffset * subTileSize,
+      xOffset * subTileSize + subTileSize,
+      yOffset * subTileSize + subTileSize
+    );
+    Rect targetRect = new Rect(0, 0, this.tileSize, this.tileSize);
     canvas.drawBitmap(sourceImage, sourceRect, targetRect, paint);
     sourceImage.recycle();
-
     data = bitmapToByteArray(image);
+
     image.recycle();
     return data;
-	} 
-
-	void checkForRefresh(int x, int y, int zoom) {
-		String fileName =  getTileFilename(x, y, zoom);
-		File file = new File(fileName);
-		long lastModified = file.lastModified();
-		long now = System.currentTimeMillis();
-
-		if ((now - lastModified) / 1000 > this.tileCacheMaxAge) {
-      Log.d("urlTile", "Refreshing");
-			Constraints constraints = new Constraints.Builder()
-				.setRequiredNetworkType(NetworkType.CONNECTED)
-				.build();
-			OneTimeWorkRequest tileRefreshWorkRequest = new OneTimeWorkRequest.Builder(MapTileWorker.class)
-				.setConstraints(constraints)
-				.addTag(fileName)
-				.setInputData(
-					new Data.Builder()
-						.putString("url", getTileUrl(x, y, zoom).toString())
-						.putString("filename", fileName)
-						.putInt("maxAge", this.tileCacheMaxAge)
-						.build()
-					)
-				.build();
-			WorkManager.getInstance(this.context.getApplicationContext())
-			.enqueueUniqueWork(fileName, ExistingWorkPolicy.KEEP, tileRefreshWorkRequest);
-		}
-	}
-
-	byte[] fetchTile(int x, int y, int zoom) {
-		URL url = getTileUrl(x, y, zoom);
-		ByteArrayOutputStream buffer = null;
-		InputStream in = null;
-
-		try {
-			URLConnection conn = url.openConnection();
-			in = conn.getInputStream();
-			buffer = new ByteArrayOutputStream();
-
-			int nRead;
-			byte[] data = new byte[BUFFER_SIZE];
-
-			while ((nRead = in.read(data, 0, BUFFER_SIZE)) != -1) {
-				buffer.write(data, 0, nRead);
-			}
-			buffer.flush();
-
-			return buffer.toByteArray();
-		} catch (IOException | OutOfMemoryError e) {
-			e.printStackTrace();
-			return null;
-		} finally {
-			if (in != null) try { in.close(); } catch (Exception ignored) {}
-			if (buffer != null) try { buffer.close(); } catch (Exception ignored) {}
-		}
-	}
-	
-	byte[] readTileImage(int x, int y, int zoom) {
-		InputStream in = null;
-		ByteArrayOutputStream buffer = null;
-		String fileName = getTileFilename(x, y, zoom);
-		if (fileName == null) {
-			return null;
-		}
-
-		File file = new File(fileName);
-
-		try {
-			in = new FileInputStream(file);
-			buffer = new ByteArrayOutputStream();
-
-			int nRead;
-			byte[] data = new byte[BUFFER_SIZE];
-
-			while ((nRead = in.read(data, 0, BUFFER_SIZE)) != -1) {
-				buffer.write(data, 0, nRead);
-			}
-			buffer.flush();
-
-			if (this.tileCacheMaxAge == 0) {
-				file.setLastModified(System.currentTimeMillis());
-			}
-
-			return buffer.toByteArray();
-		} catch (IOException | OutOfMemoryError e) {
-			e.printStackTrace();
-			return null;
-		} finally {
-			if (in != null) try { in.close(); } catch (Exception ignored) {}
-			if (buffer != null) try { buffer.close(); } catch (Exception ignored) {}
-		}
-	}
-
-	boolean writeTileImage(byte[] image, int x, int y, int zoom) {
-		OutputStream out = null;
-		String fileName = getTileFilename(x, y, zoom);
-		if (fileName == null) {
-			return false;
-		}
-
-		try {
-			File file = new File(fileName);
-			file.getParentFile().mkdirs();
-			out = new FileOutputStream(file);
-			out.write(image);
-
-			return true;
-		} catch (IOException | OutOfMemoryError e) {
-			e.printStackTrace();
-			return false;
-		} finally {
-			if (out != null) try { out.close(); } catch (Exception ignored) {}
-		}
-	}
-
-	String getTileFilename(int x, int y, int zoom) {
-		if (this.tileCachePath == null) {
-			return null;
-		}
-		return this.tileCachePath + '/' + zoom +
-			"/" + x + "/" + y;
-	}
-	
-	protected URL getTileUrl(int x, int y, int zoom) {
-		return this.tileProvider.getTileUrl(x, y, zoom);
-	}
-	
-	public void setUrlTemplate(String urlTemplate) {
-		this.urlTemplate = urlTemplate;
-	}
-
-	public void setTileSize(int tileSize) {
-		if (this.tileSize != tileSize) {
-			this.tileProvider = new AIRMapUrlTileProvider(tileSize, tileSize, urlTemplate);
-		}
-		this.tileSize = tileSize;
-	}
+  }
+
+  boolean checkForRefresh(int x, int y, int zoom) {
+    String fileName = getTileFilename(x, y, zoom);
+    File file = new File(fileName);
+    long lastModified = file.lastModified();
+    long now = System.currentTimeMillis();
+
+    if ((now - lastModified) / 1000 > this.tileCacheMaxAge) {
+      return true;
+    }
+    return false;
+  }
+
+  public static boolean doesFileExist(URL url) {
+    try {
+      HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+      connection.setRequestMethod("HEAD");
+      int responseCode = connection.getResponseCode();
+
+      // ファイルが存在する場合、通常200か203が返されます
+      return (responseCode == HttpURLConnection.HTTP_OK);
+    } catch (Exception e) {
+      // 例外が発生した場合、ファイルは存在しないとみなします
+      System.err.println("Error checking file existence: " + e.getMessage());
+      return false;
+    }
+  }
+
+  byte[] fetchTile(int x, int y, int zoom) {
+    //headerでファイルの存在を確認する。getTileだとファイルが存在しない場合、レスポンスが遅くなるため。（S3であれば遅くないが通常のhttp serverだと遅い）
+    URL url = getTileUrl(x, y, zoom);
+    boolean fileExists = doesFileExist(url);
+    if (!fileExists) {
+      return null;
+    }
+    Tile tile = this.tileProvider.getTile(x, y, zoom);
+    if (Objects.isNull(tile)) {
+      // Log.d("urlTileA:NO_TILE", getTileFilename(x, y, zoom));
+      return null;
+    }
+    return tile.data;
+  }
+
+  byte[] readTileImage(int x, int y, int zoom) {
+    InputStream in = null;
+    ByteArrayOutputStream buffer = null;
+    String fileName = getTileFilename(x, y, zoom);
+    if (fileName == null) {
+      return null;
+    }
+
+    File file = new File(fileName);
+
+    try {
+      in = new FileInputStream(file);
+      buffer = new ByteArrayOutputStream();
+
+      int nRead;
+      byte[] data = new byte[BUFFER_SIZE];
+
+      while ((nRead = in.read(data, 0, BUFFER_SIZE)) != -1) {
+        buffer.write(data, 0, nRead);
+      }
+      buffer.flush();
+
+      if (this.tileCacheMaxAge == 0) {
+        file.setLastModified(System.currentTimeMillis());
+      }
+
+      return buffer.toByteArray();
+    } catch (IOException e) {
+      e.printStackTrace();
+      return null;
+    } catch (OutOfMemoryError e) {
+      e.printStackTrace();
+      return null;
+    } finally {
+      if (in != null) try {
+        in.close();
+      } catch (Exception ignored) {}
+      if (buffer != null) try {
+        buffer.close();
+      } catch (Exception ignored) {}
+    }
+  }
+
+  boolean writeTileImage(byte[] image, int x, int y, int zoom) {
+    OutputStream out = null;
+    String fileName = getTileFilename(x, y, zoom);
+    if (fileName == null) {
+      return false;
+    }
+
+    try {
+      File file = new File(fileName);
+      file.getParentFile().mkdirs();
+      out = new FileOutputStream(file);
+      out.write(image);
+
+      return true;
+    } catch (IOException e) {
+      Log.d("urlTile", "writeTileImage: " + e.getMessage());
+      e.printStackTrace();
+      return false;
+    } catch (OutOfMemoryError e) {
+      Log.d("urlTile", "writeTileImage: " + e.getMessage());
+      e.printStackTrace();
+      return false;
+    } finally {
+      if (out != null) try {
+        out.close();
+      } catch (Exception ignored) {}
+    }
+  }
+
+  String getTileFilename(int x, int y, int zoom) {
+    if (this.tileCachePath == null) {
+      return null;
+    }
+    String s =
+      this.tileCachePath + '/' + Integer.toString(zoom) + "/" + Integer.toString(x) + "/" + Integer.toString(y);
+    return s;
+  }
+
+  protected URL getTileUrl(int x, int y, int zoom) {
+    return this.tileProvider.getTileUrl(x, y, zoom);
+  }
+
+  public void setUrlTemplate(String urlTemplate) {
+    this.urlTemplate = urlTemplate;
+  }
+
+  public void setTileSize(int tileSize) {
+    if (this.tileSize != tileSize) {
+      this.tileProvider = new AIRMapUrlTileProvider(tileSize, tileSize, urlTemplate);
+    }
+    this.tileSize = tileSize;
+  }
 
   public void setDoubleTileSize(boolean doubleTileSize) {
-		this.doubleTileSize = doubleTileSize;
-	}
+    this.doubleTileSize = doubleTileSize;
+  }
 
-	public void setMaximumZ(int maximumZ) {
-		this.maximumZ = maximumZ;
-	}
+  public void setMaximumZ(int maximumZ) {
+    this.maximumZ = maximumZ;
+  }
 
   public void setMaximumNativeZ(int maximumNativeZ) {
-		this.maximumNativeZ = maximumNativeZ;
-	}
+    this.maximumNativeZ = maximumNativeZ;
+  }
 
-	public void setMinimumZ(int minimumZ) {
-		this.minimumZ = minimumZ;
-	}
+  public void setMinimumZ(int minimumZ) {
+    this.minimumZ = minimumZ;
+  }
 
-	public void setFlipY(boolean flipY) {
-		this.flipY = flipY;
-	}
+  public void setFlipY(boolean flipY) {
+    this.flipY = flipY;
+  }
 
-	public void setTileCachePath(String tileCachePath) {
-		this.tileCachePath = tileCachePath;
-	}
+  public void setTileCachePath(String tileCachePath) {
+    this.tileCachePath = tileCachePath;
+  }
 
-	public void setTileCacheMaxAge(int tileCacheMaxAge) {
-		this.tileCacheMaxAge = tileCacheMaxAge;
-	}
+  public void setTileCacheMaxAge(int tileCacheMaxAge) {
+    this.tileCacheMaxAge = tileCacheMaxAge;
+  }
 
   public void setOfflineMode(boolean offlineMode) {
-		this.offlineMode = offlineMode;
-	}
+    this.offlineMode = offlineMode;
+  }
 
-	public void setCustomMode() {
-	}
+  public void setCustomMode() {
+    this.customMode = customMode;
+  }
 }
\ No newline at end of file
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapUrlTile.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapUrlTile.java
index 968d58a..84fcd3f 100644
--- a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapUrlTile.java
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapUrlTile.java
@@ -5,6 +5,7 @@ import android.util.Log;
 import android.content.Context;
 
 import com.google.android.gms.maps.GoogleMap;
+import com.google.android.gms.maps.model.CameraPosition;
 import com.google.android.gms.maps.model.TileOverlay;
 import com.google.android.gms.maps.model.TileOverlayOptions;
 
@@ -28,9 +29,14 @@ public class MapUrlTile extends MapFeature {
   protected float tileCacheMaxAge;
   protected boolean offlineMode = false;
   protected float opacity = 1;
+  private android.animation.ValueAnimator fadeAnimator;
   protected Context context;
   protected boolean customTileProviderNeeded = false;
   
+  // ダブルバッファリング用の追加フィールド
+  private TileOverlay pendingTileOverlay;
+  private boolean isTransitioning = false;
+
   public MapUrlTile(Context context) {
     super(context);
     this.context = context;
@@ -183,9 +189,21 @@ public class MapUrlTile extends MapFeature {
     TileOverlayOptions options = new TileOverlayOptions();
     options.zIndex(zIndex);
     options.transparency(1 - this.opacity);
-    this.tileProvider = new MapTileProvider((int)this.tileSize, this.doubleTileSize, this.urlTemplate,
-      (int)this.maximumZ, (int)this.maximumNativeZ, (int)this.minimumZ, this.flipY, this.tileCachePath, 
-      (int)this.tileCacheMaxAge, this.offlineMode, this.context, this.customTileProviderNeeded);
+    
+    // Check if this is a DEM tile (hillshade://)
+    if (this.urlTemplate != null && (this.urlTemplate.startsWith("hillshade://") || this.urlTemplate.startsWith("hillshade-terrarium://"))) {
+      Log.d("urlTile ", "Detected DEM tile URL, creating MapDEMTileProvider");
+      // Create MapDEMTileProvider directly since it's in the same package now
+      this.tileProvider = new MapDEMTileProvider((int)this.tileSize, this.doubleTileSize, this.urlTemplate,
+        (int)this.maximumZ, (int)this.maximumNativeZ, (int)this.minimumZ, this.flipY, this.tileCachePath, 
+        (int)this.tileCacheMaxAge, this.offlineMode, this.context, this.customTileProviderNeeded);
+    } else {
+      // Standard tile provider
+      this.tileProvider = new MapTileProvider((int)this.tileSize, this.doubleTileSize, this.urlTemplate,
+        (int)this.maximumZ, (int)this.maximumNativeZ, (int)this.minimumZ, this.flipY, this.tileCachePath, 
+        (int)this.tileCacheMaxAge, this.offlineMode, this.context, this.customTileProviderNeeded);
+    }
+    
     options.tileProvider(this.tileProvider);
     return options;
   }
@@ -195,13 +213,234 @@ public class MapUrlTile extends MapFeature {
     return tileOverlay;
   }
 
+  private int lastBearing = 0;
+  private GoogleMap.OnCameraIdleListener cameraIdleListener;
+  
   @Override
   public void addToMap(Object map) {
-    this.tileOverlay = ((GoogleMap) map).addTileOverlay(getTileOverlayOptions());
+    GoogleMap googleMap = (GoogleMap) map;
+    
+    // まずタイルオーバーレイオプションを作成（これによりtileProviderが初期化される）
+    TileOverlayOptions overlayOptions = getTileOverlayOptions();
+    
+    Log.d("urlTile ", "addToMap called, tileProvider type: " + (tileProvider != null ? tileProvider.getClass().getSimpleName() : "null"));
+    
+    // MapDEMTileProviderにGoogleMapの参照を渡す
+    if (tileProvider instanceof MapDEMTileProvider) {
+      Log.d("urlTile ", "Setting up MapDEMTileProvider with GoogleMap reference");
+      ((MapDEMTileProvider) tileProvider).setGoogleMap(googleMap);
+      
+      // カメラ停止時にタイルキャッシュをクリアするリスナーを設定
+      cameraIdleListener = new GoogleMap.OnCameraIdleListener() {
+        @Override
+        public void onCameraIdle() {
+          CameraPosition position = googleMap.getCameraPosition();
+          if (position != null) {
+            int currentBearing = Math.round(position.bearing / 15.0f) * 15;
+            Log.d("urlTile ", "Camera idle - bearing: " + position.bearing + ", quantized: " + currentBearing + ", last: " + lastBearing);
+            
+            // MapDEMTileProviderに現在の回転角度を更新
+            ((MapDEMTileProvider) tileProvider).updateBearing(position.bearing);
+            
+            // 回転角度が変わった場合
+            if (currentBearing != lastBearing) {
+              Log.d("urlTile ", "Rotation changed: " + lastBearing + " -> " + currentBearing);
+              
+              // 大きな回転（45度以上）の場合のみキャッシュをクリア
+              int rotationDelta = Math.abs(currentBearing - lastBearing);
+              if (rotationDelta > 180) {
+                rotationDelta = 360 - rotationDelta;
+              }
+              
+              if (rotationDelta >= 45) {
+                Log.d("urlTile ", "Large rotation detected, preparing new overlay");
+                if (tileOverlay != null && !isTransitioning) {
+                  // 新しいオーバーレイを準備
+                  prepareNewOverlay(googleMap);
+                }
+              } else {
+                Log.d("urlTile ", "Small rotation, keeping cache");
+              }
+              
+              lastBearing = currentBearing;
+            }
+          }
+        }
+      };
+      
+      googleMap.setOnCameraIdleListener(cameraIdleListener);
+      Log.d("urlTile ", "Camera idle listener set");
+      
+      // 初期の回転角度を記録
+      CameraPosition initialPosition = googleMap.getCameraPosition();
+      if (initialPosition != null) {
+        lastBearing = Math.round(initialPosition.bearing / 15.0f) * 15;
+        ((MapDEMTileProvider) tileProvider).updateBearing(initialPosition.bearing);
+        Log.d("urlTile ", "Initial bearing set to: " + lastBearing);
+      }
+    }
+    
+    this.tileOverlay = googleMap.addTileOverlay(overlayOptions);
+    Log.d("urlTile ", "Tile overlay added to map");
   }
 
   @Override
   public void removeFromMap(Object map) {
-    tileOverlay.remove();
+    GoogleMap googleMap = (GoogleMap) map;
+    
+    // リスナーをクリア
+    if (cameraIdleListener != null) {
+      googleMap.setOnCameraIdleListener(null);
+      cameraIdleListener = null;
+    }
+    
+    // GoogleMapの参照をクリア
+    if (tileProvider instanceof MapDEMTileProvider) {
+      ((MapDEMTileProvider) tileProvider).setGoogleMap(null);
+    }
+    
+    // アニメーションをキャンセル
+    if (fadeAnimator != null && fadeAnimator.isRunning()) {
+      fadeAnimator.cancel();
+    }
+    
+    // 遷移をキャンセル
+    isTransitioning = false;
+    
+    // ペンディング中のオーバーレイを削除
+    if (pendingTileOverlay != null) {
+      pendingTileOverlay.remove();
+      pendingTileOverlay = null;
+    }
+    
+    if (tileOverlay != null) {
+      tileOverlay.remove();
+    }
+  }
+  
+  /**
+   * 新しいオーバーレイを準備してスムーズに切り替える
+   */
+  private void prepareNewOverlay(final GoogleMap googleMap) {
+    isTransitioning = true;
+    Log.d("urlTile ", "Preparing new overlay for smooth transition");
+    
+    // 現在の透過度を保存
+    final float currentOpacity = this.opacity;
+    
+    // 新しいオーバーレイを作成（現在のオーバーレイは表示したまま）
+    TileOverlayOptions newOverlayOptions = getTileOverlayOptions();
+    pendingTileOverlay = googleMap.addTileOverlay(newOverlayOptions);
+    
+    // 新しいオーバーレイを透明にして開始
+    if (pendingTileOverlay != null) {
+      pendingTileOverlay.setTransparency(1.0f); // 完全に透明
+      pendingTileOverlay.setZIndex(this.zIndex + 0.1f); // 少し上に配置
+      
+      // 遅延後にクロスフェード
+      android.os.Handler handler = new android.os.Handler();
+      handler.postDelayed(new Runnable() {
+        @Override
+        public void run() {
+          performCrossfade();
+        }
+      }, 500); // 500ms待って新しいタイルが読み込まれるのを待つ
+    }
+  }
+  
+  /**
+   * 古いオーバーレイから新しいオーバーレイへクロスフェード
+   */
+  private void performCrossfade() {
+    if (pendingTileOverlay == null || tileOverlay == null) {
+      isTransitioning = false;
+      return;
+    }
+    
+    Log.d("urlTile ", "Performing crossfade transition with opacity: " + this.opacity);
+    
+    // 現在の透過度を考慮した開始値と終了値
+    final float startTransparency = 1.0f;  // 新しいオーバーレイは完全に透明から開始
+    final float endTransparency = 1.0f - this.opacity;  // 設定された不透明度に対応する透過度
+    
+    // クロスフェードアニメーション
+    android.animation.ValueAnimator crossfadeAnimator = android.animation.ValueAnimator.ofFloat(0.0f, 1.0f);
+    crossfadeAnimator.setDuration(300);
+    crossfadeAnimator.addUpdateListener(new android.animation.ValueAnimator.AnimatorUpdateListener() {
+      @Override
+      public void onAnimationUpdate(android.animation.ValueAnimator animation) {
+        float progress = (float) animation.getAnimatedValue();
+        
+        // 新しいオーバーレイをフェードイン（設定された透過度まで）
+        if (pendingTileOverlay != null) {
+          float newTransparency = startTransparency - (startTransparency - endTransparency) * progress;
+          pendingTileOverlay.setTransparency(newTransparency);
+        }
+        
+        // 古いオーバーレイをフェードアウト
+        if (tileOverlay != null) {
+          float oldTransparency = endTransparency + (1.0f - endTransparency) * progress;
+          tileOverlay.setTransparency(oldTransparency);
+        }
+      }
+    });
+    
+    crossfadeAnimator.addListener(new android.animation.Animator.AnimatorListener() {
+      @Override
+      public void onAnimationStart(android.animation.Animator animation) {}
+      
+      @Override
+      public void onAnimationEnd(android.animation.Animator animation) {
+        // アニメーション完了後、古いオーバーレイを削除
+        if (tileOverlay != null) {
+          tileOverlay.remove();
+        }
+        
+        // 新しいオーバーレイを現在のオーバーレイに設定
+        tileOverlay = pendingTileOverlay;
+        pendingTileOverlay = null;
+        
+        // Z-indexを元に戻し、最終的な透過度を設定
+        if (tileOverlay != null) {
+          tileOverlay.setZIndex(zIndex);
+          tileOverlay.setTransparency(1.0f - opacity);  // 設定された不透明度を適用
+        }
+        
+        isTransitioning = false;
+        Log.d("urlTile ", "Crossfade transition completed with final opacity: " + opacity);
+      }
+      
+      @Override
+      public void onAnimationCancel(android.animation.Animator animation) {
+        isTransitioning = false;
+      }
+      
+      @Override
+      public void onAnimationRepeat(android.animation.Animator animation) {}
+    });
+    
+    crossfadeAnimator.start();
+  }
+  
+  /**
+   * タイル更新時のフェードアニメーション（旧実装、互換性のため残す）
+   */
+  private void animateFadeTransition() {
+    if (fadeAnimator != null && fadeAnimator.isRunning()) {
+      fadeAnimator.cancel();
+    }
+    
+    fadeAnimator = android.animation.ValueAnimator.ofFloat(1.0f, 0.7f, 1.0f);
+    fadeAnimator.setDuration(300); // 300ミリ秒のアニメーション
+    fadeAnimator.addUpdateListener(new android.animation.ValueAnimator.AnimatorUpdateListener() {
+      @Override
+      public void onAnimationUpdate(android.animation.ValueAnimator animation) {
+        float alpha = (float) animation.getAnimatedValue();
+        if (tileOverlay != null) {
+          tileOverlay.setTransparency(1 - alpha);
+        }
+      }
+    });
+    fadeAnimator.start();
   }
 }
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapUrlTileManager.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapUrlTileManager.java
index 2f1c573..ed7cba1 100644
--- a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapUrlTileManager.java
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapUrlTileManager.java
@@ -3,7 +3,6 @@ package com.rnmaps.maps;
 import android.content.Context;
 import android.util.DisplayMetrics;
 import android.view.WindowManager;
-
 import com.facebook.react.bridge.ReactApplicationContext;
 import com.facebook.react.uimanager.ThemedReactContext;
 import com.facebook.react.uimanager.ViewGroupManager;
@@ -14,9 +13,7 @@ public class MapUrlTileManager extends ViewGroupManager<MapUrlTile> {
   public MapUrlTileManager(ReactApplicationContext reactContext) {
     super();
     DisplayMetrics metrics = new DisplayMetrics();
-    ((WindowManager) reactContext.getSystemService(Context.WINDOW_SERVICE))
-        .getDefaultDisplay()
-        .getRealMetrics(metrics);
+    ((WindowManager) reactContext.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getRealMetrics(metrics);
   }
 
   @Override
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapView.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapView.java
index f03bc3f..c24a4fb 100644
--- a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapView.java
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapView.java
@@ -16,13 +16,11 @@ import android.view.ViewGroup;
 import android.widget.ImageView;
 import android.widget.ProgressBar;
 import android.widget.RelativeLayout;
-
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.core.content.PermissionChecker;
 import androidx.core.view.GestureDetectorCompat;
 import androidx.core.view.MotionEventCompat;
-
 import com.facebook.react.bridge.Arguments;
 import com.facebook.react.bridge.LifecycleEventListener;
 import com.facebook.react.bridge.ReactApplicationContext;
@@ -66,9 +64,6 @@ import com.google.maps.android.data.kml.KmlContainer;
 import com.google.maps.android.data.kml.KmlLayer;
 import com.google.maps.android.data.kml.KmlPlacemark;
 import com.google.maps.android.data.kml.KmlStyle;
-
-import org.xmlpull.v1.XmlPullParserException;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
@@ -77,9 +72,17 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ExecutionException;
+import org.xmlpull.v1.XmlPullParserException;
+
+public class MapView
+  extends com.google.android.gms.maps.MapView
+  implements
+    GoogleMap.InfoWindowAdapter,
+    GoogleMap.OnMarkerDragListener,
+    OnMapReadyCallback,
+    GoogleMap.OnPoiClickListener,
+    GoogleMap.OnIndoorStateChangeListener {
 
-public class MapView extends com.google.android.gms.maps.MapView implements GoogleMap.InfoWindowAdapter,
-    GoogleMap.OnMarkerDragListener, OnMapReadyCallback, GoogleMap.OnPoiClickListener, GoogleMap.OnIndoorStateChangeListener {
   public GoogleMap map;
   private MarkerManager markerManager;
   private MarkerManager.Collection markerCollection;
@@ -113,8 +116,10 @@ public class MapView extends com.google.android.gms.maps.MapView implements Goog
   private int cameraMoveReason = 0;
   private MapMarker selectedMarker;
 
-  private static final String[] PERMISSIONS = new String[]{
-      "android.permission.ACCESS_FINE_LOCATION", "android.permission.ACCESS_COARSE_LOCATION"};
+  private static final String[] PERMISSIONS = new String[] {
+    "android.permission.ACCESS_FINE_LOCATION",
+    "android.permission.ACCESS_COARSE_LOCATION",
+  };
 
   private final List<MapFeature> features = new ArrayList<>();
   private final Map<Marker, MapMarker> markerMap = new HashMap<>();
@@ -136,9 +141,7 @@ public class MapView extends com.google.android.gms.maps.MapView implements Goog
   private LatLng tapLocation;
 
   private static boolean contextHasBug(Context context) {
-    return context == null ||
-        context.getResources() == null ||
-        context.getResources().getConfiguration() == null;
+    return context == null || context.getResources() == null || context.getResources().getConfiguration() == null;
   }
 
   // We do this to fix this bug:
@@ -148,8 +151,7 @@ public class MapView extends com.google.android.gms.maps.MapView implements Goog
   // https://github.com/react-native-maps/react-native-maps/issues/1147
   //
   // Doing this allows us to avoid both bugs.
-  private static Context getNonBuggyContext(ThemedReactContext reactContext,
-      ReactApplicationContext appContext) {
+  private static Context getNonBuggyContext(ThemedReactContext reactContext, ReactApplicationContext appContext) {
     Context superContext = reactContext;
     if (!contextHasBug(appContext.getCurrentActivity())) {
       superContext = appContext.getCurrentActivity();
@@ -160,19 +162,24 @@ public class MapView extends com.google.android.gms.maps.MapView implements Goog
       } else if (!contextHasBug(reactContext.getApplicationContext())) {
         superContext = reactContext.getApplicationContext();
       }
-
     }
     return superContext;
   }
 
-  public MapView(ThemedReactContext reactContext, ReactApplicationContext appContext,
-                 MapManager manager,
-                 GoogleMapOptions googleMapOptions) {
+  public MapView(
+    ThemedReactContext reactContext,
+    ReactApplicationContext appContext,
+    MapManager manager,
+    GoogleMapOptions googleMapOptions
+  ) {
     super(getNonBuggyContext(reactContext, appContext), googleMapOptions);
-
     this.manager = manager;
     this.context = reactContext;
-    MapsInitializer.initialize(context, this.manager.renderer, renderer -> Log.d("AirMapRenderer", renderer.toString()));
+    MapsInitializer.initialize(
+      context,
+      this.manager.renderer,
+      renderer -> Log.d("AirMapRenderer", renderer.toString())
+    );
     super.onCreate(null);
     super.onResume();
     super.getMapAsync(this);
@@ -182,11 +189,11 @@ public class MapView extends com.google.android.gms.maps.MapView implements Goog
     fusedLocationSource = new FusedLocationSource(context);
 
     gestureDetector =
-        new GestureDetectorCompat(reactContext, new GestureDetector.SimpleOnGestureListener() {
-
+      new GestureDetectorCompat(
+        reactContext,
+        new GestureDetector.SimpleOnGestureListener() {
           @Override
-          public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX,
-              float distanceY) {
+          public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
             if (handlePanDrag) {
               onPanDrag(e2);
             }
@@ -198,25 +205,36 @@ public class MapView extends com.google.android.gms.maps.MapView implements Goog
             onDoublePress(ev);
             return false;
           }
-        });
+        }
+      );
 
-    this.addOnLayoutChangeListener(new OnLayoutChangeListener() {
-      @Override public void onLayoutChange(View v, int left, int top, int right, int bottom,
-          int oldLeft, int oldTop, int oldRight, int oldBottom) {
-        if (!paused) {
-          MapView.this.cacheView();
+    this.addOnLayoutChangeListener(
+        new OnLayoutChangeListener() {
+          @Override
+          public void onLayoutChange(
+            View v,
+            int left,
+            int top,
+            int right,
+            int bottom,
+            int oldLeft,
+            int oldTop,
+            int oldRight,
+            int oldBottom
+          ) {
+            if (!paused) {
+              MapView.this.cacheView();
+            }
+          }
         }
-      }
-    });
+      );
 
     int uiManagerType = UIManagerType.DEFAULT;
     if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
       uiManagerType = UIManagerType.FABRIC;
     }
 
-    eventDispatcher = UIManagerHelper
-      .getUIManager(reactContext, uiManagerType)
-      .getEventDispatcher();
+    eventDispatcher = UIManagerHelper.getUIManager(reactContext, uiManagerType).getEventDispatcher();
 
     // Set up a parent view for triggering visibility in subviews that depend on it.
     // Mainly ReactImageView depends on Fresco which depends on onVisibilityChanged() event
@@ -259,166 +277,191 @@ public class MapView extends com.google.android.gms.maps.MapView implements Goog
 
     final MapView view = this;
 
-    map.setOnMyLocationChangeListener(new GoogleMap.OnMyLocationChangeListener() {
-      @Override
-      public void onMyLocationChange(Location location){
-        WritableMap event = new WritableNativeMap();
+    map.setOnMyLocationChangeListener(
+      new GoogleMap.OnMyLocationChangeListener() {
+        @Override
+        public void onMyLocationChange(Location location) {
+          WritableMap event = new WritableNativeMap();
+
+          WritableMap coordinate = new WritableNativeMap();
+          coordinate.putDouble("latitude", location.getLatitude());
+          coordinate.putDouble("longitude", location.getLongitude());
+          coordinate.putDouble("altitude", location.getAltitude());
+          coordinate.putDouble("timestamp", location.getTime());
+          coordinate.putDouble("accuracy", location.getAccuracy());
+          coordinate.putDouble("speed", location.getSpeed());
+          coordinate.putDouble("heading", location.getBearing());
+          coordinate.putBoolean("isFromMockProvider", location.isFromMockProvider());
+
+          event.putMap("coordinate", coordinate);
+
+          manager.pushEvent(context, view, "onUserLocationChange", event);
+        }
+      }
+    );
 
-        WritableMap coordinate = new WritableNativeMap();
-        coordinate.putDouble("latitude", location.getLatitude());
-        coordinate.putDouble("longitude", location.getLongitude());
-        coordinate.putDouble("altitude", location.getAltitude());
-        coordinate.putDouble("timestamp", location.getTime());
-        coordinate.putDouble("accuracy", location.getAccuracy());
-        coordinate.putDouble("speed", location.getSpeed());
-        coordinate.putDouble("heading", location.getBearing());
-        coordinate.putBoolean("isFromMockProvider", location.isFromMockProvider());
+    markerCollection.setOnMarkerClickListener(
+      new GoogleMap.OnMarkerClickListener() {
+        @Override
+        public boolean onMarkerClick(@NonNull Marker marker) {
+          MapMarker airMapMarker = getMarkerMap(marker);
 
-        event.putMap("coordinate", coordinate);
+          WritableMap event = makeClickEventData(marker.getPosition());
+          event.putString("action", "marker-press");
+          event.putString("id", airMapMarker.getIdentifier());
+          manager.pushEvent(context, view, "onMarkerPress", event);
 
-        manager.pushEvent(context, view, "onUserLocationChange", event);
-      }
-    });
-
-    markerCollection.setOnMarkerClickListener(new GoogleMap.OnMarkerClickListener() {
-      @Override
-      public boolean onMarkerClick(@NonNull Marker marker) {
-        MapMarker airMapMarker = getMarkerMap(marker);
-
-        WritableMap event = makeClickEventData(marker.getPosition());
-        event.putString("action", "marker-press");
-        event.putString("id", airMapMarker.getIdentifier());
-        manager.pushEvent(context, view, "onMarkerPress", event);
-
-        event = makeClickEventData(marker.getPosition());
-        event.putString("action", "marker-press");
-        event.putString("id", airMapMarker.getIdentifier());
-        manager.pushEvent(context, airMapMarker, "onPress", event);
-
-        handleMarkerSelection(airMapMarker);
-
-        // Return false to open the callout info window and center on the marker
-        // https://developers.google.com/android/reference/com/google/android/gms/maps/GoogleMap
-        // .OnMarkerClickListener
-        if (view.moveOnMarkerPress) {
-          return false;
-        } else {
-          marker.showInfoWindow();
-          return true;
+          event = makeClickEventData(marker.getPosition());
+          event.putString("action", "marker-press");
+          event.putString("id", airMapMarker.getIdentifier());
+          manager.pushEvent(context, airMapMarker, "onPress", event);
+
+          handleMarkerSelection(airMapMarker);
+
+          // Return false to open the callout info window and center on the marker
+          // https://developers.google.com/android/reference/com/google/android/gms/maps/GoogleMap
+          // .OnMarkerClickListener
+          if (view.moveOnMarkerPress) {
+            return false;
+          } else {
+            marker.showInfoWindow();
+            return true;
+          }
         }
       }
-    });
-
-    polygonCollection.setOnPolygonClickListener(new GoogleMap.OnPolygonClickListener() {
-      @Override
-      public void onPolygonClick(@NonNull Polygon polygon) {
-        WritableMap event = makeClickEventData(tapLocation);
-        event.putString("action", "polygon-press");
-        manager.pushEvent(context, polygonMap.get(polygon), "onPress", event);
+    );
+
+    polygonCollection.setOnPolygonClickListener(
+      new GoogleMap.OnPolygonClickListener() {
+        @Override
+        public void onPolygonClick(@NonNull Polygon polygon) {
+          WritableMap event = makeClickEventData(tapLocation);
+          event.putString("action", "polygon-press");
+          manager.pushEvent(context, polygonMap.get(polygon), "onPress", event);
+        }
       }
-    });
-
-    polylineCollection.setOnPolylineClickListener(new GoogleMap.OnPolylineClickListener() {
-      @Override
-      public void onPolylineClick(@NonNull Polyline polyline) {
-        WritableMap event = makeClickEventData(tapLocation);
-        event.putString("action", "polyline-press");
-        manager.pushEvent(context, polylineMap.get(polyline), "onPress", event);
+    );
+
+    polylineCollection.setOnPolylineClickListener(
+      new GoogleMap.OnPolylineClickListener() {
+        @Override
+        public void onPolylineClick(@NonNull Polyline polyline) {
+          WritableMap event = makeClickEventData(tapLocation);
+          event.putString("action", "polyline-press");
+          manager.pushEvent(context, polylineMap.get(polyline), "onPress", event);
+        }
       }
-    });
-
-    markerCollection.setOnInfoWindowClickListener(new GoogleMap.OnInfoWindowClickListener() {
-      @Override
-      public void onInfoWindowClick(@NonNull Marker marker) {
-        WritableMap event = makeClickEventData(marker.getPosition());
-        event.putString("action", "callout-press");
-        manager.pushEvent(context, view, "onCalloutPress", event);
-
-        event = makeClickEventData(marker.getPosition());
-        event.putString("action", "callout-press");
-        MapMarker markerView = getMarkerMap(marker);
-        manager.pushEvent(context, markerView, "onCalloutPress", event);
-
-        event = makeClickEventData(marker.getPosition());
-        event.putString("action", "callout-press");
-        MapCallout infoWindow = markerView.getCalloutView();
-        if (infoWindow != null) manager.pushEvent(context, infoWindow, "onPress", event);
+    );
+
+    markerCollection.setOnInfoWindowClickListener(
+      new GoogleMap.OnInfoWindowClickListener() {
+        @Override
+        public void onInfoWindowClick(@NonNull Marker marker) {
+          WritableMap event = makeClickEventData(marker.getPosition());
+          event.putString("action", "callout-press");
+          manager.pushEvent(context, view, "onCalloutPress", event);
+
+          event = makeClickEventData(marker.getPosition());
+          event.putString("action", "callout-press");
+          MapMarker markerView = getMarkerMap(marker);
+          manager.pushEvent(context, markerView, "onCalloutPress", event);
+
+          event = makeClickEventData(marker.getPosition());
+          event.putString("action", "callout-press");
+          MapCallout infoWindow = markerView.getCalloutView();
+          if (infoWindow != null) manager.pushEvent(context, infoWindow, "onPress", event);
+        }
       }
-    });
+    );
 
-    map.setOnMapClickListener(new GoogleMap.OnMapClickListener() {
-      @Override
-      public void onMapClick(@NonNull LatLng point) {
-        WritableMap event = makeClickEventData(point);
-        event.putString("action", "press");
-        manager.pushEvent(context, view, "onPress", event);
+    map.setOnMapClickListener(
+      new GoogleMap.OnMapClickListener() {
+        @Override
+        public void onMapClick(@NonNull LatLng point) {
+          WritableMap event = makeClickEventData(point);
+          event.putString("action", "press");
+          manager.pushEvent(context, view, "onPress", event);
 
-        handleMarkerSelection(null);
-      }
-    });
-
-    map.setOnMapLongClickListener(new GoogleMap.OnMapLongClickListener() {
-      @Override
-      public void onMapLongClick(@NonNull LatLng point) {
-        WritableMap event = makeClickEventData(point);
-        event.putString("action", "long-press");
-        manager.pushEvent(context, view, "onLongPress", makeClickEventData(point));
-      }
-    });
-
-    groundOverlayCollection.setOnGroundOverlayClickListener(new GoogleMap.OnGroundOverlayClickListener() {
-      @Override
-      public void onGroundOverlayClick(@NonNull GroundOverlay groundOverlay) {
-        WritableMap event = makeClickEventData(groundOverlay.getPosition());
-        event.putString("action", "overlay-press");
-        manager.pushEvent(context, overlayMap.get(groundOverlay), "onPress", event);
+          handleMarkerSelection(null);
+        }
       }
-    });
+    );
 
-    map.setOnCameraMoveStartedListener(new GoogleMap.OnCameraMoveStartedListener() {
-      @Override
-      public void onCameraMoveStarted(int reason) {
-        cameraMoveReason = reason;
+    map.setOnMapLongClickListener(
+      new GoogleMap.OnMapLongClickListener() {
+        @Override
+        public void onMapLongClick(@NonNull LatLng point) {
+          WritableMap event = makeClickEventData(point);
+          event.putString("action", "long-press");
+          manager.pushEvent(context, view, "onLongPress", makeClickEventData(point));
+        }
       }
-    });
-
-    map.setOnCameraMoveListener(new GoogleMap.OnCameraMoveListener() {
-      @Override
-      public void onCameraMove() {
-        LatLngBounds bounds = map.getProjection().getVisibleRegion().latLngBounds;
+    );
 
-        cameraLastIdleBounds = null;
-        boolean isGesture = GoogleMap.OnCameraMoveStartedListener.REASON_GESTURE == cameraMoveReason;
+    groundOverlayCollection.setOnGroundOverlayClickListener(
+      new GoogleMap.OnGroundOverlayClickListener() {
+        @Override
+        public void onGroundOverlayClick(@NonNull GroundOverlay groundOverlay) {
+          WritableMap event = makeClickEventData(groundOverlay.getPosition());
+          event.putString("action", "overlay-press");
+          manager.pushEvent(context, overlayMap.get(groundOverlay), "onPress", event);
+        }
+      }
+    );
 
-        RegionChangeEvent event = new RegionChangeEvent(getId(), bounds, true, isGesture);
-        eventDispatcher.dispatchEvent(event);
+    map.setOnCameraMoveStartedListener(
+      new GoogleMap.OnCameraMoveStartedListener() {
+        @Override
+        public void onCameraMoveStarted(int reason) {
+          cameraMoveReason = reason;
+        }
       }
-    });
+    );
 
-    map.setOnCameraIdleListener(new GoogleMap.OnCameraIdleListener() {
-      @Override
-      public void onCameraIdle() {
-        LatLngBounds bounds = map.getProjection().getVisibleRegion().latLngBounds;
-        if ((cameraMoveReason != 0) &&
-          ((cameraLastIdleBounds == null) ||
-            LatLngBoundsUtils.BoundsAreDifferent(bounds, cameraLastIdleBounds))) {
+    map.setOnCameraMoveListener(
+      new GoogleMap.OnCameraMoveListener() {
+        @Override
+        public void onCameraMove() {
+          LatLngBounds bounds = map.getProjection().getVisibleRegion().latLngBounds;
 
-          cameraLastIdleBounds = bounds;
+          cameraLastIdleBounds = null;
           boolean isGesture = GoogleMap.OnCameraMoveStartedListener.REASON_GESTURE == cameraMoveReason;
 
-          RegionChangeEvent event = new RegionChangeEvent(getId(), bounds, false, isGesture);
+          RegionChangeEvent event = new RegionChangeEvent(getId(), bounds, true, isGesture);
           eventDispatcher.dispatchEvent(event);
         }
       }
-    });
+    );
 
-    map.setOnMapLoadedCallback(new GoogleMap.OnMapLoadedCallback() {
-      @Override public void onMapLoaded() {
-        isMapLoaded = true;
-        manager.pushEvent(context, view, "onMapLoaded", new WritableNativeMap());
-        MapView.this.cacheView();
+    map.setOnCameraIdleListener(
+      new GoogleMap.OnCameraIdleListener() {
+        @Override
+        public void onCameraIdle() {
+          LatLngBounds bounds = map.getProjection().getVisibleRegion().latLngBounds;
+          if (
+            (cameraMoveReason != 0) &&
+            ((cameraLastIdleBounds == null) || LatLngBoundsUtils.BoundsAreDifferent(bounds, cameraLastIdleBounds))
+          ) {
+            cameraLastIdleBounds = bounds;
+            boolean isGesture = GoogleMap.OnCameraMoveStartedListener.REASON_GESTURE == cameraMoveReason;
+
+            RegionChangeEvent event = new RegionChangeEvent(getId(), bounds, false, isGesture);
+            eventDispatcher.dispatchEvent(event);
+          }
+        }
       }
-    });
+    );
+
+    map.setOnMapLoadedCallback(
+      new GoogleMap.OnMapLoadedCallback() {
+        @Override
+        public void onMapLoaded() {
+          isMapLoaded = true;
+          manager.pushEvent(context, view, "onMapLoaded", new WritableNativeMap());
+          MapView.this.cacheView();
+        }
+      }
+    );
 
     // We need to be sure to disable location-tracking when app enters background, in-case some
     // other module
@@ -427,41 +470,42 @@ public class MapView extends com.google.android.gms.maps.MapView implements Goog
     // updating location constantly, killing the battery, even though some other location-mgmt
     // module may
     // desire to shut-down location-services.
-    lifecycleListener = new LifecycleEventListener() {
-      @Override
-      public void onHostResume() {
-        if (hasPermissions() && map != null) {
-          //noinspection MissingPermission
-          map.setMyLocationEnabled(showUserLocation);
-          map.setLocationSource(fusedLocationSource);
-        }
-        synchronized (MapView.this) {
-          if (!destroyed) {
-            MapView.this.onResume();
+    lifecycleListener =
+      new LifecycleEventListener() {
+        @Override
+        public void onHostResume() {
+          if (hasPermissions() && map != null) {
+            //noinspection MissingPermission
+            map.setMyLocationEnabled(showUserLocation);
+            map.setLocationSource(fusedLocationSource);
+          }
+          synchronized (MapView.this) {
+            if (!destroyed) {
+              MapView.this.onResume();
+            }
+            paused = false;
           }
-          paused = false;
         }
-      }
 
-      @Override
-      public void onHostPause() {
-        if (hasPermissions() && map != null) {
-          //noinspection MissingPermission
-          map.setMyLocationEnabled(false);
-        }
-        synchronized (MapView.this) {
-          if (!destroyed) {
-            MapView.this.onPause();
+        @Override
+        public void onHostPause() {
+          if (hasPermissions() && map != null) {
+            //noinspection MissingPermission
+            map.setMyLocationEnabled(false);
+          }
+          synchronized (MapView.this) {
+            if (!destroyed) {
+              MapView.this.onPause();
+            }
+            paused = true;
           }
-          paused = true;
         }
-      }
 
-      @Override
-      public void onHostDestroy() {
-        MapView.this.doDestroy();
-      }
-    };
+        @Override
+        public void onHostDestroy() {
+          MapView.this.doDestroy();
+        }
+      };
 
     context.addLifecycleEventListener(lifecycleListener);
   }
@@ -497,15 +541,16 @@ public class MapView extends com.google.android.gms.maps.MapView implements Goog
       manager.pushEvent(context, this, "onMarkerSelect", event);
     }
 
-     selectedMarker = target;
+    selectedMarker = target;
   }
 
   private boolean hasPermissions() {
-    return checkSelfPermission(getContext(), PERMISSIONS[0]) == PermissionChecker.PERMISSION_GRANTED ||
-        checkSelfPermission(getContext(), PERMISSIONS[1]) == PermissionChecker.PERMISSION_GRANTED;
+    return (
+      checkSelfPermission(getContext(), PERMISSIONS[0]) == PermissionChecker.PERMISSION_GRANTED ||
+      checkSelfPermission(getContext(), PERMISSIONS[1]) == PermissionChecker.PERMISSION_GRANTED
+    );
   }
 
-
   /*
   onDestroy is final method so I can't override it.
    */
@@ -537,15 +582,15 @@ public class MapView extends com.google.android.gms.maps.MapView implements Goog
   }
 
   private void applyBridgedProps() {
-    if(initialRegion != null) {
+    if (initialRegion != null) {
       moveToRegion(initialRegion);
       initialRegionSet = true;
-    } else if(region != null) {
+    } else if (region != null) {
       moveToRegion(region);
     } else {
       moveToCamera(camera);
     }
-    if(customMapStyleString != null) {
+    if (customMapStyleString != null) {
       map.setMapStyle(new MapStyleOptions(customMapStyleString));
     }
   }
@@ -558,8 +603,8 @@ public class MapView extends com.google.android.gms.maps.MapView implements Goog
     double lngDelta = region.getDouble("longitudeDelta");
     double latDelta = region.getDouble("latitudeDelta");
     LatLngBounds bounds = new LatLngBounds(
-            new LatLng(lat - latDelta / 2, lng - lngDelta / 2), // southwest
-            new LatLng(lat + latDelta / 2, lng + lngDelta / 2)  // northeast
+      new LatLng(lat - latDelta / 2, lng - lngDelta / 2), // southwest
+      new LatLng(lat + latDelta / 2, lng + lngDelta / 2) // northeast
     );
     if (super.getHeight() <= 0 || super.getWidth() <= 0) {
       // in this case, our map has not been laid out yet, so we save the bounds in a local
@@ -576,35 +621,37 @@ public class MapView extends com.google.android.gms.maps.MapView implements Goog
 
   public void setRegion(ReadableMap region) {
     this.region = region;
-    if(region != null && map != null) {
+    if (region != null && map != null) {
       moveToRegion(region);
     }
   }
 
   public void setCamera(ReadableMap camera) {
     this.camera = camera;
-    if(camera != null && map != null) {
+    if (camera != null && map != null) {
       moveToCamera(camera);
     }
   }
-public static CameraPosition cameraPositionFromMap(ReadableMap camera){
-  if (camera == null) return null;
 
-  CameraPosition.Builder builder = new CameraPosition.Builder();
+  public static CameraPosition cameraPositionFromMap(ReadableMap camera) {
+    if (camera == null) return null;
 
-  ReadableMap center = camera.getMap("center");
-  if (center != null) {
-    double lng = center.getDouble("longitude");
-    double lat = center.getDouble("latitude");
-    builder.target(new LatLng(lat, lng));
-  }
+    CameraPosition.Builder builder = new CameraPosition.Builder();
 
-  builder.tilt((float)camera.getDouble("pitch"));
-  builder.bearing((float)camera.getDouble("heading"));
-  builder.zoom((float)camera.getDouble("zoom"));
+    ReadableMap center = camera.getMap("center");
+    if (center != null) {
+      double lng = center.getDouble("longitude");
+      double lat = center.getDouble("latitude");
+      builder.target(new LatLng(lat, lng));
+    }
+
+    builder.tilt((float) camera.getDouble("pitch"));
+    builder.bearing((float) camera.getDouble("heading"));
+    builder.zoom((float) camera.getDouble("zoom"));
+
+    return builder.build();
+  }
 
-  return builder.build();
-}
   public void moveToCamera(ReadableMap cameraMap) {
     CameraPosition camera = cameraPositionFromMap(cameraMap);
     if (camera == null) return;
@@ -623,7 +670,7 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
 
   public void setMapStyle(@Nullable String customMapStyleString) {
     this.customMapStyleString = customMapStyleString;
-    if(map != null && customMapStyleString != null) {
+    if (map != null && customMapStyleString != null) {
       map.setMapStyle(new MapStyleOptions(customMapStyleString));
     }
   }
@@ -637,15 +684,15 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
     }
   }
 
-  public void setUserLocationPriority(int priority){
+  public void setUserLocationPriority(int priority) {
     fusedLocationSource.setPriority(priority);
   }
 
-  public void setUserLocationUpdateInterval(int interval){
+  public void setUserLocationUpdateInterval(int interval) {
     fusedLocationSource.setInterval(interval);
   }
 
-  public void setUserLocationFastestInterval(int interval){
+  public void setUserLocationFastestInterval(int interval) {
     fusedLocationSource.setFastestInterval(interval);
   }
 
@@ -724,7 +771,7 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
 
       // Remove from a view group if already present, prevent "specified child
       // already had a parent" error.
-      ViewGroup annotationParent = (ViewGroup)annotation.getParent();
+      ViewGroup annotationParent = (ViewGroup) annotation.getParent();
       if (annotationParent != null) {
         annotationParent.removeView(annotation);
       }
@@ -765,6 +812,10 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
       MapUrlTile urlTileView = (MapUrlTile) child;
       urlTileView.addToMap(map);
       features.add(index, urlTileView);
+    } else if (child instanceof MapPMTile) {
+      MapPMTile PMTileView = (MapPMTile) child;
+      PMTileView.addToMap(map);
+      features.add(index, PMTileView);
     } else if (child instanceof MapWMSTile) {
       MapWMSTile urlTileView = (MapWMSTile) child;
       urlTileView.addToMap(map);
@@ -783,7 +834,7 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
       MapHeatmap heatmapView = (MapHeatmap) child;
       heatmapView.addToMap(map);
       features.add(index, heatmapView);
-      TileOverlay heatmap = (TileOverlay)heatmapView.getFeature();
+      TileOverlay heatmap = (TileOverlay) heatmapView.getFeature();
       heatmapMap.put(heatmap, heatmapView);
     } else if (child instanceof ViewGroup) {
       ViewGroup children = (ViewGroup) child;
@@ -812,13 +863,13 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
     } else if (feature instanceof MapHeatmap) {
       heatmapMap.remove(feature.getFeature());
       feature.removeFromMap(map);
-    } else if(feature instanceof MapCircle) {
+    } else if (feature instanceof MapCircle) {
       feature.removeFromMap(circleCollection);
-    } else if(feature instanceof MapOverlay) {
+    } else if (feature instanceof MapOverlay) {
       feature.removeFromMap(groundOverlayCollection);
-    } else if(feature instanceof MapPolygon) {
+    } else if (feature instanceof MapPolygon) {
       feature.removeFromMap(polygonCollection);
-    } else if(feature instanceof  MapPolyline) {
+    } else if (feature instanceof MapPolyline) {
       feature.removeFromMap(polylineCollection);
     } else {
       feature.removeFromMap(map);
@@ -862,8 +913,7 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
 
       boundsToMove = null;
       cameraToSet = null;
-    }
-    else if (cameraToSet != null) {
+    } else if (cameraToSet != null) {
       map.moveCamera(cameraToSet);
       cameraToSet = null;
     }
@@ -873,13 +923,13 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
     if (map == null) return;
     CameraPosition.Builder builder = new CameraPosition.Builder(map.getCameraPosition());
     if (camera.hasKey("zoom")) {
-      builder.zoom((float)camera.getDouble("zoom"));
+      builder.zoom((float) camera.getDouble("zoom"));
     }
     if (camera.hasKey("heading")) {
-      builder.bearing((float)camera.getDouble("heading"));
+      builder.bearing((float) camera.getDouble("heading"));
     }
     if (camera.hasKey("pitch")) {
-      builder.tilt((float)camera.getDouble("pitch"));
+      builder.tilt((float) camera.getDouble("pitch"));
     }
     if (camera.hasKey("center")) {
       ReadableMap center = camera.getMap("center");
@@ -890,15 +940,14 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
 
     if (duration <= 0) {
       map.moveCamera(update);
-    }
-    else {
+    } else {
       map.animateCamera(update, duration, null);
     }
   }
 
   public void animateToRegion(LatLngBounds bounds, int duration) {
     if (map == null) return;
-    if(duration <= 0) {
+    if (duration <= 0) {
       map.moveCamera(CameraUpdateFactory.newLatLngBounds(bounds, 0));
     } else {
       map.animateCamera(CameraUpdateFactory.newLatLngBounds(bounds, 0), duration, null);
@@ -925,8 +974,12 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
       CameraUpdate cu = CameraUpdateFactory.newLatLngBounds(bounds, baseMapPadding);
 
       if (edgePadding != null) {
-        map.setPadding(edgePadding.getInt("left"), edgePadding.getInt("top"),
-          edgePadding.getInt("right"), edgePadding.getInt("bottom"));
+        map.setPadding(
+          edgePadding.getInt("left"),
+          edgePadding.getInt("top"),
+          edgePadding.getInt("right"),
+          edgePadding.getInt("bottom")
+        );
       }
 
       if (animated) {
@@ -967,8 +1020,12 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
       CameraUpdate cu = CameraUpdateFactory.newLatLngBounds(bounds, baseMapPadding);
 
       if (edgePadding != null) {
-        map.setPadding(edgePadding.getInt("left"), edgePadding.getInt("top"),
-          edgePadding.getInt("right"), edgePadding.getInt("bottom"));
+        map.setPadding(
+          edgePadding.getInt("left"),
+          edgePadding.getInt("top"),
+          edgePadding.getInt("right"),
+          edgePadding.getInt("bottom")
+        );
       }
 
       if (animated) {
@@ -984,7 +1041,7 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
   int baseTopMapPadding;
   int baseBottomMapPadding;
 
-  public void applyBaseMapPadding(int left, int top, int right, int bottom){
+  public void applyBaseMapPadding(int left, int top, int right, int bottom) {
     this.map.setPadding(left, top, right, bottom);
     baseLeftMapPadding = left;
     baseRightMapPadding = right;
@@ -992,8 +1049,7 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
     baseBottomMapPadding = bottom;
   }
 
-  public void fitToCoordinates(ReadableArray coordinatesArray, ReadableMap edgePadding,
-      boolean animated) {
+  public void fitToCoordinates(ReadableArray coordinatesArray, ReadableMap edgePadding, boolean animated) {
     if (map == null) return;
 
     LatLngBounds.Builder builder = new LatLngBounds.Builder();
@@ -1009,7 +1065,12 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
     CameraUpdate cu = CameraUpdateFactory.newLatLngBounds(bounds, baseMapPadding);
 
     if (edgePadding != null) {
-      appendMapPadding(edgePadding.getInt("left"), edgePadding.getInt("top"), edgePadding.getInt("right"), edgePadding.getInt("bottom"));
+      appendMapPadding(
+        edgePadding.getInt("left"),
+        edgePadding.getInt("top"),
+        edgePadding.getInt("right"),
+        edgePadding.getInt("bottom")
+      );
     }
 
     if (animated) {
@@ -1021,7 +1082,7 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
     map.setPadding(baseLeftMapPadding, baseTopMapPadding, baseRightMapPadding, baseBottomMapPadding);
   }
 
-  private void appendMapPadding(int iLeft,int iTop, int iRight, int iBottom) {
+  private void appendMapPadding(int iLeft, int iTop, int iRight, int iBottom) {
     int left;
     int top;
     int right;
@@ -1033,10 +1094,12 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
     right = (int) (iRight * density);
     bottom = (int) (iBottom * density);
 
-    map.setPadding(left + baseLeftMapPadding,
-            top + baseTopMapPadding,
-            right + baseRightMapPadding,
-            bottom + baseBottomMapPadding);
+    map.setPadding(
+      left + baseLeftMapPadding,
+      top + baseTopMapPadding,
+      right + baseRightMapPadding,
+      bottom + baseBottomMapPadding
+    );
   }
 
   public double[][] getMapBoundaries() {
@@ -1044,10 +1107,7 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
     LatLng northEast = bounds.northeast;
     LatLng southWest = bounds.southwest;
 
-    return new double[][] {
-      {northEast.longitude, northEast.latitude},
-      {southWest.longitude, southWest.latitude}
-    };
+    return new double[][] { { northEast.longitude, northEast.latitude }, { southWest.longitude, southWest.latitude } };
   }
 
   public void setMapBoundaries(ReadableMap northEast, ReadableMap southWest) {
@@ -1086,18 +1146,18 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
   public boolean dispatchTouchEvent(MotionEvent ev) {
     gestureDetector.onTouchEvent(ev);
 
-    int X = (int)ev.getX();          
-    int Y = (int)ev.getY();
-    if(map != null) {
-      tapLocation = map.getProjection().fromScreenLocation(new Point(X,Y));
+    int X = (int) ev.getX();
+    int Y = (int) ev.getY();
+    if (map != null) {
+      tapLocation = map.getProjection().fromScreenLocation(new Point(X, Y));
     }
 
     int action = MotionEventCompat.getActionMasked(ev);
 
     switch (action) {
       case (MotionEvent.ACTION_DOWN):
-        this.getParent().requestDisallowInterceptTouchEvent(
-            map != null && map.getUiSettings().isScrollGesturesEnabled());
+        this.getParent()
+          .requestDisallowInterceptTouchEvent(map != null && map.getUiSettings().isScrollGesturesEnabled());
         break;
       case (MotionEvent.ACTION_UP):
         // Clear this regardless, since isScrollGesturesEnabled() may have been updated
@@ -1163,12 +1223,15 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
     if (this.mapLoadingLayout == null) {
       this.mapLoadingLayout = new RelativeLayout(getContext());
       this.mapLoadingLayout.setBackgroundColor(Color.LTGRAY);
-      this.addView(this.mapLoadingLayout,
-          new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
-              ViewGroup.LayoutParams.MATCH_PARENT));
+      this.addView(
+          this.mapLoadingLayout,
+          new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)
+        );
 
       RelativeLayout.LayoutParams params = new RelativeLayout.LayoutParams(
-          RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT);
+        RelativeLayout.LayoutParams.WRAP_CONTENT,
+        RelativeLayout.LayoutParams.WRAP_CONTENT
+      );
       params.addRule(RelativeLayout.CENTER_IN_PARENT);
       this.mapLoadingLayout.addView(this.getMapLoadingProgressBar(), params);
 
@@ -1181,9 +1244,10 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
   private ImageView getCacheImageView() {
     if (this.cacheImageView == null) {
       this.cacheImageView = new ImageView(getContext());
-      this.addView(this.cacheImageView,
-          new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
-              ViewGroup.LayoutParams.MATCH_PARENT));
+      this.addView(
+          this.cacheImageView,
+          new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)
+        );
       this.cacheImageView.setVisibility(View.INVISIBLE);
     }
     return this.cacheImageView;
@@ -1218,13 +1282,16 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
       cacheImageView.setVisibility(View.INVISIBLE);
       mapLoadingLayout.setVisibility(View.VISIBLE);
       if (this.isMapLoaded) {
-        this.map.snapshot(new GoogleMap.SnapshotReadyCallback() {
-          @Override public void onSnapshotReady(Bitmap bitmap) {
-            cacheImageView.setImageBitmap(bitmap);
-            cacheImageView.setVisibility(View.VISIBLE);
-            mapLoadingLayout.setVisibility(View.INVISIBLE);
-          }
-        });
+        this.map.snapshot(
+            new GoogleMap.SnapshotReadyCallback() {
+              @Override
+              public void onSnapshotReady(Bitmap bitmap) {
+                cacheImageView.setImageBitmap(bitmap);
+                cacheImageView.setVisibility(View.VISIBLE);
+                mapLoadingLayout.setVisibility(View.INVISIBLE);
+              }
+            }
+          );
       }
     } else {
       this.removeCacheImageView();
@@ -1251,13 +1318,22 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
 
   public void setKmlSrc(String kmlSrc) {
     try {
-      InputStream kmlStream =  new FileUtil(context).execute(kmlSrc).get();
+      InputStream kmlStream = new FileUtil(context).execute(kmlSrc).get();
 
       if (kmlStream == null) {
         return;
       }
 
-      KmlLayer kmlLayer = new KmlLayer(map, kmlStream, context, markerManager, polygonManager, polylineManager, groundOverlayManager, null);
+      KmlLayer kmlLayer = new KmlLayer(
+        map,
+        kmlStream,
+        context,
+        markerManager,
+        polygonManager,
+        polylineManager,
+        groundOverlayManager,
+        null
+      );
       kmlLayer.addLayerToMap();
 
       WritableMap pointers = new WritableNativeMap();
@@ -1275,7 +1351,6 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
         return;
       }
 
-
       if (container.getContainers().iterator().hasNext()) {
         container = container.getContainers().iterator().next();
       }
@@ -1308,8 +1383,7 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
 
         MapMarker marker = new MapMarker(context, options, this.manager.getMarkerManager());
 
-        if (placemark.getInlineStyle() != null
-            && placemark.getInlineStyle().getIconUrl() != null) {
+        if (placemark.getInlineStyle() != null && placemark.getInlineStyle().getIconUrl() != null) {
           marker.setImage(placemark.getInlineStyle().getIconUrl());
         } else if (container.getStyle(placemark.getStyleId()) != null) {
           KmlStyle style = container.getStyle(placemark.getStyleId());
@@ -1333,7 +1407,6 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
       pointers.putArray("markers", markers);
 
       manager.pushEvent(context, this, "onKmlReady", pointers);
-
     } catch (XmlPullParserException | IOException | InterruptedException | ExecutionException e) {
       e.printStackTrace();
     }
@@ -1420,8 +1493,10 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
     }
 
     for (Map.Entry<Marker, MapMarker> entryMarker : markerMap.entrySet()) {
-      if (entryMarker.getKey().getPosition().equals(marker.getPosition())
-          && entryMarker.getKey().getTitle().equals(marker.getTitle())) {
+      if (
+        entryMarker.getKey().getPosition().equals(marker.getPosition()) &&
+        entryMarker.getKey().getTitle().equals(marker.getTitle())
+      ) {
         airMarker = entryMarker.getValue();
         break;
       }
@@ -1439,8 +1514,10 @@ public static CameraPosition cameraPositionFromMap(ReadableMap camera){
   private final Runnable measureAndLayout = new Runnable() {
     @Override
     public void run() {
-      measure(MeasureSpec.makeMeasureSpec(getWidth(), MeasureSpec.EXACTLY),
-              MeasureSpec.makeMeasureSpec(getHeight(), MeasureSpec.EXACTLY));
+      measure(
+        MeasureSpec.makeMeasureSpec(getWidth(), MeasureSpec.EXACTLY),
+        MeasureSpec.makeMeasureSpec(getHeight(), MeasureSpec.EXACTLY)
+      );
       layout(getLeft(), getTop(), getRight(), getBottom());
     }
   };
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapsPackage.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapsPackage.java
index 3bf751d..d0eeb14 100644
--- a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapsPackage.java
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/MapsPackage.java
@@ -4,7 +4,6 @@ import com.facebook.react.ReactPackage;
 import com.facebook.react.bridge.NativeModule;
 import com.facebook.react.bridge.ReactApplicationContext;
 import com.facebook.react.uimanager.ViewManager;
-
 import java.util.ArrayList;
 import java.util.List;
 
@@ -37,6 +36,7 @@ public class MapsPackage implements ReactPackage {
     viewManagers.add(new MapUrlTileManager(reactContext));
     viewManagers.add(new MapWMSTileManager(reactContext));
     viewManagers.add(new MapLocalTileManager(reactContext));
+    viewManagers.add(new MapPMTileManager(reactContext));
     viewManagers.add(new MapOverlayManager(reactContext));
     viewManagers.add(new MapHeatmapManager());
 
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/BufferPosition.class b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/BufferPosition.class
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/BufferPosition.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/BufferPosition.java
new file mode 100644
index 0000000..bbebbd1
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/BufferPosition.java
@@ -0,0 +1,14 @@
+package PMTiles;
+
+import java.nio.ByteBuffer;
+
+public class BufferPosition {
+
+  public ByteBuffer buf;
+  public int pos;
+
+  public BufferPosition(ByteBuffer buf, int pos) {
+    this.buf = buf;
+    this.pos = pos;
+  }
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Cache.class b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Cache.class
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Cache.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Cache.java
new file mode 100644
index 0000000..0f12b7d
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Cache.java
@@ -0,0 +1,25 @@
+package PMTiles;
+
+import java.nio.ByteBuffer;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+
+public interface Cache {
+  CompletableFuture<Header> getHeader(Source source, String currentEtag);
+
+  CompletableFuture<List<Entry>> getDirectory(
+    Source source,
+    long offset,
+    long length,
+    Header header
+  );
+
+  CompletableFuture<ByteBuffer> getArrayBuffer(
+    Source source,
+    long offset,
+    long length,
+    Header header
+  );
+
+  CompletableFuture<Void> invalidate(Source source, String currentEtag);
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Compression.class b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Compression.class
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Compression.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Compression.java
new file mode 100644
index 0000000..4d5b2bc
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Compression.java
@@ -0,0 +1,19 @@
+package PMTiles;
+
+public enum Compression {
+  Unknown(0),
+  None(1),
+  Gzip(2),
+  Brotli(3),
+  Zstd(4);
+
+  private final int value;
+
+  Compression(int value) {
+    this.value = value;
+  }
+
+  public int getValue() {
+    return value;
+  }
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Decompress.class b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Decompress.class
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Decompress.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Decompress.java
new file mode 100644
index 0000000..893dd63
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Decompress.java
@@ -0,0 +1,43 @@
+package PMTiles;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.zip.GZIPInputStream;
+
+public class Decompress {
+
+  public static ByteBuffer decompress(ByteBuffer data, int compression)
+    throws IOException {
+    if (compression == 1 || compression == 0) {
+      return data;
+    } else if (compression == 2) {
+      return decompressGzip(data);
+    } else {
+      throw new IllegalArgumentException("Compression method not supported");
+    }
+  }
+
+  private static ByteBuffer decompressGzip(ByteBuffer data) throws IOException {
+    //System.out.println("Decompressing GZIP");
+    //System.out.println("Data length: " + data);
+    byte[] inputData = new byte[data.remaining()];
+    data.get(inputData);
+
+    try (
+      ByteArrayInputStream bais = new ByteArrayInputStream(inputData);
+      GZIPInputStream gzipInputStream = new GZIPInputStream(bais);
+      ByteArrayOutputStream baos = new ByteArrayOutputStream()
+    ) {
+      byte[] buffer = new byte[4096];
+      int bytesRead;
+
+      while ((bytesRead = gzipInputStream.read(buffer)) != -1) {
+        baos.write(buffer, 0, bytesRead);
+      }
+
+      return ByteBuffer.wrap(baos.toByteArray());
+    }
+  }
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/DecompressFunc.class b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/DecompressFunc.class
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/DecompressFunc.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/DecompressFunc.java
new file mode 100644
index 0000000..a8b53c0
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/DecompressFunc.java
@@ -0,0 +1,7 @@
+package PMTiles;
+
+import java.nio.ByteBuffer;
+
+public interface DecompressFunc {
+  ByteBuffer decompress(ByteBuffer buf, int compression);
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Entry.class b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Entry.class
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Entry.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Entry.java
new file mode 100644
index 0000000..65bf0e7
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Entry.java
@@ -0,0 +1,65 @@
+package PMTiles;
+
+public class Entry {
+
+  public long tileId;
+  public long offset;
+  public int length;
+  public int runLength;
+
+  public Entry(long tileId, long offset, int length, int runLength) {
+    this.tileId = tileId;
+    this.offset = offset;
+    this.length = length;
+    this.runLength = runLength;
+  }
+
+  // Getter and Setter methods
+  public long getTileId() {
+    return tileId;
+  }
+
+  public void setTileId(long tileId) {
+    this.tileId = tileId;
+  }
+
+  public long getOffset() {
+    return offset;
+  }
+
+  public void setOffset(long offset) {
+    this.offset = offset;
+  }
+
+  public int getLength() {
+    return length;
+  }
+
+  public void setLength(int length) {
+    this.length = length;
+  }
+
+  public int getRunLength() {
+    return runLength;
+  }
+
+  public void setRunLength(int runLength) {
+    this.runLength = runLength;
+  }
+
+  @Override
+  public String toString() {
+    return (
+      "Entry{" +
+      "tileId=" +
+      tileId +
+      ", offset=" +
+      offset +
+      ", length=" +
+      length +
+      ", runLength=" +
+      runLength +
+      '}'
+    );
+  }
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/EtagMismatch.class b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/EtagMismatch.class
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/EtagMismatch.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/EtagMismatch.java
new file mode 100644
index 0000000..0884c9a
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/EtagMismatch.java
@@ -0,0 +1,12 @@
+package PMTiles;
+
+public class EtagMismatch extends RuntimeException {
+
+  public EtagMismatch() {
+    super();
+  }
+
+  public EtagMismatch(String message) {
+    super(message);
+  }
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/FetchSource.class b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/FetchSource.class
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/FetchSource.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/FetchSource.java
new file mode 100644
index 0000000..727d544
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/FetchSource.java
@@ -0,0 +1,107 @@
+package PMTiles;
+
+import android.content.Context;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.RandomAccessFile;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.net.URLConnection;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.util.concurrent.CompletableFuture;
+
+public class FetchSource implements Source {
+
+  private final String url;
+  private final Context context;
+  private final boolean isLocalFile;
+
+  public FetchSource(String url) {
+    this(null, url);
+  }
+
+  public FetchSource(Context context, String url) {
+    this.url = url;
+    this.context = context;
+    this.isLocalFile = url.startsWith("file://") || !url.contains("://");
+  }
+
+  public String getKey() {
+    return this.url;
+  }
+
+  public CompletableFuture<RangeResponse> getBytes(long offset, long length) {
+    if (isLocalFile) {
+      return getBytesFromLocalFile(offset, length);
+    } else {
+      return getBytesFromUrl(offset, length);
+    }
+  }
+
+  private CompletableFuture<RangeResponse> getBytesFromUrl(long offset, long length) {
+    return CompletableFuture.supplyAsync(() -> {
+      try {
+        URL urlObj = new URL(this.url);
+        URLConnection connection = urlObj.openConnection();
+        connection.setConnectTimeout(10 * 1000);
+        connection.setReadTimeout(10 * 1000);
+        String rangeHeader = "bytes=" + offset + "-" + (offset + length - 1);
+        connection.setRequestProperty("Range", rangeHeader);
+
+        int responseCode = ((HttpURLConnection) connection).getResponseCode();
+        if (responseCode >= 300) {
+          throw new RuntimeException("Bad response code: " + responseCode);
+        }
+
+        try (InputStream in = connection.getInputStream(); ByteArrayOutputStream out = new ByteArrayOutputStream()) {
+          byte[] buffer = new byte[1024];
+          int bytesRead;
+
+          while ((bytesRead = in.read(buffer)) != -1) {
+            out.write(buffer, 0, bytesRead);
+          }
+
+          byte[] responseBody = out.toByteArray();
+          ByteBuffer data = ByteBuffer.wrap(responseBody);
+
+          String etag = connection.getHeaderField("ETag");
+          String cacheControl = connection.getHeaderField("Cache-Control");
+          String expires = connection.getHeaderField("Expires");
+
+          return new RangeResponse(data, etag, cacheControl, expires);
+        }
+      } catch (IOException e) {
+        System.out.println("Error: " + e.getMessage());
+        return null;
+      }
+    });
+  }
+
+  private CompletableFuture<RangeResponse> getBytesFromLocalFile(long offset, long length) {
+    return CompletableFuture.supplyAsync(() -> {
+      try {
+        String filePath = this.url.replace("file://", "");
+        File file = new File(filePath);
+        if (!file.exists() && this.context != null) {
+          file = new File(this.context.getFilesDir(), filePath);
+        }
+        try (
+          RandomAccessFile randomAccessFile = new RandomAccessFile(file, "r");
+          FileChannel channel = randomAccessFile.getChannel()
+        ) {
+          ByteBuffer buffer = ByteBuffer.allocate((int) length);
+          channel.read(buffer, offset);
+          buffer.flip();
+
+          return new RangeResponse(buffer, null, null, null);
+        }
+      } catch (Exception e) {
+        System.out.println("Error reading local file: " + e.getMessage());
+        return null;
+      }
+    });
+  }
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Header.class b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Header.class
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Header.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Header.java
new file mode 100644
index 0000000..3dbccc2
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Header.java
@@ -0,0 +1,239 @@
+package PMTiles;
+
+public class Header {
+
+  private int specVersion;
+  private long rootDirectoryOffset;
+  private long rootDirectoryLength;
+  private long jsonMetadataOffset;
+  private long jsonMetadataLength;
+  private long leafDirectoryOffset;
+  private long leafDirectoryLength;
+  private long tileDataOffset;
+  private long tileDataLength;
+  private long numAddressedTiles;
+  private long numTileEntries;
+  private long numTileContents;
+  private boolean clustered;
+  private int internalCompression;
+  private int tileCompression;
+  private int tileType;
+  private int minZoom;
+  private int maxZoom;
+  private double minLon;
+  private double minLat;
+  private double maxLon;
+  private double maxLat;
+  private int centerZoom;
+  private double centerLon;
+  private double centerLat;
+  private String etag;
+
+  public int getSpecVersion() {
+    return specVersion;
+  }
+
+  public void setSpecVersion(int specVersion) {
+    this.specVersion = specVersion;
+  }
+
+  public long getRootDirectoryOffset() {
+    return rootDirectoryOffset;
+  }
+
+  public void setRootDirectoryOffset(long rootDirectoryOffset) {
+    this.rootDirectoryOffset = rootDirectoryOffset;
+  }
+
+  public long getRootDirectoryLength() {
+    return rootDirectoryLength;
+  }
+
+  public void setRootDirectoryLength(long rootDirectoryLength) {
+    this.rootDirectoryLength = rootDirectoryLength;
+  }
+
+  public long getJsonMetadataOffset() {
+    return jsonMetadataOffset;
+  }
+
+  public void setJsonMetadataOffset(long jsonMetadataOffset) {
+    this.jsonMetadataOffset = jsonMetadataOffset;
+  }
+
+  public long getJsonMetadataLength() {
+    return jsonMetadataLength;
+  }
+
+  public void setJsonMetadataLength(long jsonMetadataLength) {
+    this.jsonMetadataLength = jsonMetadataLength;
+  }
+
+  public long getLeafDirectoryOffset() {
+    return leafDirectoryOffset;
+  }
+
+  public void setLeafDirectoryOffset(long leafDirectoryOffset) {
+    this.leafDirectoryOffset = leafDirectoryOffset;
+  }
+
+  public long getLeafDirectoryLength() {
+    return leafDirectoryLength;
+  }
+
+  public void setLeafDirectoryLength(long leafDirectoryLength) {
+    this.leafDirectoryLength = leafDirectoryLength;
+  }
+
+  public long getTileDataOffset() {
+    return tileDataOffset;
+  }
+
+  public void setTileDataOffset(long tileDataOffset) {
+    this.tileDataOffset = tileDataOffset;
+  }
+
+  public long getTileDataLength() {
+    return tileDataLength;
+  }
+
+  public void setTileDataLength(long tileDataLength) {
+    this.tileDataLength = tileDataLength;
+  }
+
+  public long getNumAddressedTiles() {
+    return numAddressedTiles;
+  }
+
+  public void setNumAddressedTiles(long numAddressedTiles) {
+    this.numAddressedTiles = numAddressedTiles;
+  }
+
+  public long getNumTileEntries() {
+    return numTileEntries;
+  }
+
+  public void setNumTileEntries(long numTileEntries) {
+    this.numTileEntries = numTileEntries;
+  }
+
+  public long getNumTileContents() {
+    return numTileContents;
+  }
+
+  public void setNumTileContents(long numTileContents) {
+    this.numTileContents = numTileContents;
+  }
+
+  public boolean isClustered() {
+    return clustered;
+  }
+
+  public void setClustered(boolean clustered) {
+    this.clustered = clustered;
+  }
+
+  public int getInternalCompression() {
+    return internalCompression;
+  }
+
+  public void setInternalCompression(int internalCompression) {
+    this.internalCompression = internalCompression;
+  }
+
+  public int getTileCompression() {
+    return tileCompression;
+  }
+
+  public void setTileCompression(int tileCompression) {
+    this.tileCompression = tileCompression;
+  }
+
+  public int getTileType() {
+    return tileType;
+  }
+
+  public void setTileType(int tileType) {
+    this.tileType = tileType;
+  }
+
+  public int getMinZoom() {
+    return minZoom;
+  }
+
+  public void setMinZoom(int minZoom) {
+    this.minZoom = minZoom;
+  }
+
+  public int getMaxZoom() {
+    return maxZoom;
+  }
+
+  public void setMaxZoom(int maxZoom) {
+    this.maxZoom = maxZoom;
+  }
+
+  public double getMinLon() {
+    return minLon;
+  }
+
+  public void setMinLon(double minLon) {
+    this.minLon = minLon;
+  }
+
+  public double getMinLat() {
+    return minLat;
+  }
+
+  public void setMinLat(double minLat) {
+    this.minLat = minLat;
+  }
+
+  public double getMaxLon() {
+    return maxLon;
+  }
+
+  public void setMaxLon(double maxLon) {
+    this.maxLon = maxLon;
+  }
+
+  public double getMaxLat() {
+    return maxLat;
+  }
+
+  public void setMaxLat(double maxLat) {
+    this.maxLat = maxLat;
+  }
+
+  public int getCenterZoom() {
+    return centerZoom;
+  }
+
+  public void setCenterZoom(int centerZoom) {
+    this.centerZoom = centerZoom;
+  }
+
+  public double getCenterLon() {
+    return centerLon;
+  }
+
+  public void setCenterLon(double centerLon) {
+    this.centerLon = centerLon;
+  }
+
+  public double getCenterLat() {
+    return centerLat;
+  }
+
+  public void setCenterLat(double centerLat) {
+    this.centerLat = centerLat;
+  }
+
+  public String getEtag() {
+    return etag;
+  }
+
+  public void setEtag(String etag) {
+    this.etag = etag;
+  }
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Metadata.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Metadata.java
new file mode 100644
index 0000000..dec82ac
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Metadata.java
@@ -0,0 +1,22 @@
+package PMTiles;
+
+import com.google.gson.Gson;
+import com.google.gson.annotations.SerializedName;
+import java.util.List;
+import java.util.Map;
+
+public class Metadata {
+
+  public String name;
+  public String type;
+
+  @SerializedName("vector_layers")
+  public List<VectorLayer> vectorLayers;
+
+  @Override
+  public String toString() {
+    // Gson オブジェクトを使ってオブジェクトを JSON 形式の文字列に変換
+    Gson gson = new Gson();
+    return gson.toJson(this);
+  }
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/PMTiles.class b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/PMTiles.class
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/PMTiles.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/PMTiles.java
new file mode 100644
index 0000000..26a6b57
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/PMTiles.java
@@ -0,0 +1,187 @@
+package PMTiles;
+
+import android.util.Log;
+import com.google.gson.Gson;
+import com.google.gson.reflect.TypeToken;
+import java.io.IOException;
+import java.lang.InterruptedException;
+import java.lang.reflect.Type;
+import java.nio.ByteBuffer;
+import java.nio.charset.CharacterCodingException;
+import java.nio.charset.Charset;
+import java.nio.charset.CharsetDecoder;
+import java.nio.charset.CodingErrorAction;
+import java.nio.charset.StandardCharsets;
+import java.util.List;
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Function;
+
+public class PMTiles {
+
+  private final Source source;
+  private final Cache cache;
+  private final DecompressFunc decompress;
+
+  public PMTiles(Object source, Cache cache, DecompressFunc decompress) {
+    if (source instanceof String) {
+      this.source = new FetchSource((String) source);
+    } else {
+      this.source = (Source) source;
+    }
+    if (decompress != null) {
+      this.decompress = decompress;
+    } else {
+      this.decompress =
+        (data, compression) -> {
+          try {
+            return Decompress.decompress(data, compression);
+          } catch (IOException e) {
+            throw new RuntimeException("Decompression failed", e);
+          }
+        };
+    }
+    if (cache != null) {
+      this.cache = cache;
+    } else {
+      this.cache = new SharedPromiseCache(100, true, this.decompress);
+    }
+  }
+
+  public CompletableFuture<Header> getHeader() {
+    return cache
+      .getHeader(source, null)
+      .exceptionally(ex -> {
+        return null;
+      });
+  }
+
+  public CompletableFuture<Optional<RangeResponse>> getZxyAttempt(int z, int x, int y) {
+    long tileId = PMTilesUtils.zxyToTileId(z, x, y);
+    Log.v("MainActivity", "tileId: " + tileId + " " + z + " " + x + " " + y);
+    //System.out.println("tileId: " + tileId + " " + z + " " + x + " " + y);
+    CompletableFuture<Header> headerFuture = cache.getHeader(source, null);
+
+    return headerFuture.thenCompose(header -> {
+      if (z < header.getMinZoom() || z > header.getMaxZoom()) {
+        return CompletableFuture.completedFuture(Optional.empty());
+      }
+
+      long directoryOffset = header.getRootDirectoryOffset();
+      long directoryLength = header.getRootDirectoryLength();
+      //   System.out.println("directoryOffset: " + directoryOffset);
+      //   System.out.println("directoryLength: " + directoryLength);
+      Optional<RangeResponse> r = searchDirectoryForTile(tileId, header, directoryOffset, directoryLength);
+      return CompletableFuture.completedFuture(r);
+    });
+  }
+
+  private Optional<RangeResponse> searchDirectoryForTile(
+    long tileId,
+    Header header,
+    long directoryOffset,
+    long directoryLength
+  ) {
+    //System.out.println("searchDirectoryForTile: " + tileId);
+    for (int depth = 0; depth <= 3; depth++) {
+      //System.out.println("depth: " + depth);
+      List<Entry> directory = cache.getDirectory(source, directoryOffset, directoryLength, header).join(); // Assuming getDirectory returns CompletableFuture<Directory>
+      //System.out.println("directory: " + directory);
+      Entry entry = PMTilesUtils.findTile(directory, tileId);
+
+      if (entry != null) {
+        if (entry.getRunLength() > 0) {
+          RangeResponse resp = source
+            .getBytes(header.getTileDataOffset() + entry.getOffset(), entry.getLength())
+            .join(); // Assuming getBytes returns CompletableFuture<Resp>
+
+          if (header.getEtag() != null && !header.getEtag().equals(resp.etag)) {
+            throw new EtagMismatch(resp.etag);
+          }
+
+          RangeResponse rangeResponse = new RangeResponse(
+            this.decompress.decompress(resp.data, header.getTileCompression()), // Assuming decompress returns byte[]
+            null,
+            resp.cacheControl,
+            resp.expires
+          );
+          //System.out.println("found entry: " + entry);
+          return Optional.of(rangeResponse);
+        } else {
+          directoryOffset = header.getLeafDirectoryOffset() + entry.getOffset();
+          directoryLength = entry.getLength();
+          //System.out.println("next directoryOffset: " + directoryOffset);
+        }
+      } else {
+        return Optional.empty();
+      }
+    }
+    throw new RuntimeException("Maximum directory depth exceeded");
+  }
+
+  public CompletableFuture<Optional<RangeResponse>> getZxy(int z, int x, int y) {
+    return getZxyAttempt(z, x, y)
+      .exceptionally(ex -> {
+        if (ex.getCause() instanceof EtagMismatch) {
+          cache.invalidate(source, ex.getMessage());
+          return getZxyAttempt(z, x, y).join();
+        } else {
+          System.out.println("Exception: " + ex);
+          throw new RuntimeException(ex);
+        }
+      });
+  }
+
+  public CompletableFuture<Metadata> getMetadataAttempt() {
+    return cache
+      .getHeader(source, null)
+      .thenCompose(header -> {
+        CompletableFuture<Metadata> resultFuture = new CompletableFuture<>();
+        try {
+          source
+            .getBytes(header.getJsonMetadataOffset(), header.getJsonMetadataLength())
+            .thenAccept(resp -> {
+              if (header.getEtag() != null && !header.getEtag().equals(resp.etag)) {
+                resultFuture.completeExceptionally(new EtagMismatch(resp.etag));
+              } else {
+                ByteBuffer decompressed = this.decompress.decompress(resp.data, header.getInternalCompression());
+                CharsetDecoder decoder = Charset
+                  .forName("UTF-8")
+                  .newDecoder()
+                  .onMalformedInput(CodingErrorAction.REPORT)
+                  .onUnmappableCharacter(CodingErrorAction.REPORT);
+                try {
+                  String metadata = decoder.decode(decompressed).toString();
+                  Gson gson = new Gson();
+                  Metadata metadataObject = gson.fromJson(metadata, Metadata.class);
+                  resultFuture.complete(metadataObject);
+                } catch (CharacterCodingException e) {
+                  resultFuture.completeExceptionally(e);
+                }
+              }
+            })
+            .exceptionally(ex -> {
+              resultFuture.completeExceptionally(ex);
+              return null;
+            });
+        } catch (Exception e) {
+          resultFuture.completeExceptionally(e);
+        }
+        return resultFuture;
+      });
+  }
+
+  public CompletableFuture<Metadata> getMetadata() {
+    return getMetadataAttempt()
+      .exceptionally(ex -> {
+        if (ex.getCause() instanceof EtagMismatch) {
+          cache.invalidate(source, ex.getMessage());
+          return getMetadataAttempt().join();
+        } else {
+          throw new RuntimeException(ex);
+        }
+      });
+  }
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/PMTilesUtils.class b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/PMTilesUtils.class
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/PMTilesUtils.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/PMTilesUtils.java
new file mode 100644
index 0000000..112488c
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/PMTilesUtils.java
@@ -0,0 +1,395 @@
+package PMTiles;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.AbstractMap.SimpleEntry;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+
+class PMTilesUtils {
+
+  static final int HEADER_SIZE_BYTES = 127;
+
+  public static Header bytesToHeader(ByteBuffer bytes, String etag) {
+    bytes.order(ByteOrder.LITTLE_ENDIAN);
+    // for (int i = 0; i < bytes.limit(); i++) {
+    //   System.out.printf("%X ", bytes.get(i));
+    // }
+    int specVersion = bytes.get(7);
+    //System.out.println("specVersion: " + specVersion);
+    if (specVersion > 3) {
+      throw new RuntimeException(
+        "Archive is spec version " + specVersion + " but this library supports up to spec version 3"
+      );
+    }
+
+    Header header = new Header();
+    header.setSpecVersion(specVersion);
+    header.setRootDirectoryOffset(getUint64(bytes, 8));
+    header.setRootDirectoryLength(getUint64(bytes, 16));
+    header.setJsonMetadataOffset(getUint64(bytes, 24));
+    header.setJsonMetadataLength(getUint64(bytes, 32));
+    header.setLeafDirectoryOffset(getUint64(bytes, 40));
+    header.setLeafDirectoryLength(getUint64(bytes, 48));
+    header.setTileDataOffset(getUint64(bytes, 56));
+    header.setTileDataLength(getUint64(bytes, 64));
+    header.setNumAddressedTiles(getUint64(bytes, 72));
+    header.setNumTileEntries(getUint64(bytes, 80));
+    header.setNumTileContents(getUint64(bytes, 88));
+    header.setClustered(bytes.get(96) == 1);
+    header.setInternalCompression(bytes.get(97));
+    header.setTileCompression(bytes.get(98));
+    header.setTileType(bytes.get(99));
+    header.setMinZoom(bytes.get(100));
+    header.setMaxZoom(bytes.get(101));
+    header.setMinLon(bytes.getInt(102) / 10000000.0);
+    header.setMinLat(bytes.getInt(106) / 10000000.0);
+    header.setMaxLon(bytes.getInt(110) / 10000000.0);
+    header.setMaxLat(bytes.getInt(114) / 10000000.0);
+    header.setCenterZoom(bytes.get(118));
+    header.setCenterLon(bytes.getInt(119) / 10000000.0);
+    header.setCenterLat(bytes.getInt(123) / 10000000.0);
+    header.setEtag(etag);
+
+    return header;
+  }
+
+  private static long getUint64(ByteBuffer buffer, int offset) {
+    long wh = (long) buffer.getInt(offset + 4) & 0xFFFFFFFFL;
+    long wl = (long) buffer.getInt(offset + 0) & 0xFFFFFFFFL;
+    return wh * (long) Math.pow(2, 32) + wl;
+  }
+
+  static long toNum(int low, int high) {
+    long result = (((long) high) << 32) | (((long) low) & 0xffffffffL);
+    //System.out.println("toNum: " + low + " " + high + " " + result);
+    return result;
+  }
+
+  static long readVarintRemainder(int l, BufferPosition p) {
+    ByteBuffer buf = p.buf;
+    int h, b;
+    b = buf.get(p.pos++) & 0xFF;
+    h = (b & 0x70) >> 4;
+    if (b < 0x80) return toNum(l, h);
+    b = buf.get(p.pos++) & 0xFF;
+    h |= (b & 0x7f) << 3;
+    if (b < 0x80) return toNum(l, h);
+    b = buf.get(p.pos++) & 0xFF;
+    h |= (b & 0x7f) << 10;
+    if (b < 0x80) return toNum(l, h);
+    b = buf.get(p.pos++) & 0xFF;
+    h |= (b & 0x7f) << 17;
+    if (b < 0x80) return toNum(l, h);
+    b = buf.get(p.pos++) & 0xFF;
+    h |= (b & 0x7f) << 24;
+    if (b < 0x80) return toNum(l, h);
+    b = buf.get(p.pos++) & 0xFF;
+    h |= (b & 0x01) << 31;
+    if (b < 0x80) return toNum(l, h);
+    throw new RuntimeException("Expected varint not more than 10 bytes");
+  }
+
+  static long readVarint(BufferPosition p) {
+    ByteBuffer buf = p.buf;
+    int val, b;
+
+    b = buf.get(p.pos++) & 0xFF;
+    val = b & 0x7f;
+    if (b < 0x80) return val;
+    b = buf.get(p.pos++) & 0xFF;
+    val |= (b & 0x7f) << 7;
+    if (b < 0x80) return val;
+    b = buf.get(p.pos++) & 0xFF;
+    val |= (b & 0x7f) << 14;
+    if (b < 0x80) return val;
+    b = buf.get(p.pos++) & 0xFF;
+    val |= (b & 0x7f) << 21;
+    if (b < 0x80) return val;
+    b = buf.get(p.pos) & 0xFF;
+    val |= (b & 0x0f) << 28;
+    //System.out.println("readVarintRemainder: " + val);
+    //System.out.println("p pos: " + p.pos);
+    return readVarintRemainder(val, p);
+  }
+
+  public static List<Entry> deserializeIndex(ByteBuffer buffer) {
+    BufferPosition p = new BufferPosition(buffer, 0);
+    //System.out.println("buffer length (capacity): " + p.buf.capacity());
+    int numEntries = (int) readVarint(p);
+    //System.out.println("numEntries: " + numEntries);
+    List<Entry> entries = new ArrayList<>();
+    // System.out.println("buffer position: " + p.pos);
+    // for (int i = 0; i < p.buf.limit(); i++) {
+    //   System.out.printf("%d ", p.buf.get(i) & 0xFF);
+    // }
+    long lastId = 0;
+    for (int i = 0; i < numEntries; i++) {
+      long v = readVarint(p);
+      //System.out.println("tileId:" + (lastId + v));
+      entries.add(new Entry(lastId + v, 0, 0, 1));
+      lastId += v;
+    }
+
+    for (int i = 0; i < numEntries; i++) {
+      entries.get(i).runLength = (int) readVarint(p);
+    }
+
+    for (int i = 0; i < numEntries; i++) {
+      entries.get(i).length = (int) readVarint(p);
+    }
+
+    for (int i = 0; i < numEntries; i++) {
+      long v = readVarint(p);
+      if (v == 0 && i > 0) {
+        entries.get(i).offset = entries.get(i - 1).offset + entries.get(i - 1).length;
+      } else {
+        entries.get(i).offset = v - 1;
+      }
+      //System.out.println("tileId:" + entries.get(i).tileId);
+      //System.out.println("runLength:" + entries.get(i).runLength);
+    }
+
+    return entries;
+  }
+
+  public static CompletableFuture<SimpleEntry<Header, Optional<RootDirData>>> getHeaderAndRoot(
+    Source source,
+    boolean prefetch,
+    String currentEtag
+  ) {
+    try {
+      //System.out.println("Fetching header from " + source.getKey());
+      RangeResponse resp = source.getBytes(0, 16384).get();
+
+      //System.out.println(resp);
+      ByteBuffer buffer = resp.data;
+      buffer.order(ByteOrder.LITTLE_ENDIAN);
+
+      if (buffer.getShort(0) != 0x4d50) {
+        throw new RuntimeException("Wrong magic number for PMTiles archive");
+      }
+
+      ByteBuffer headerData = (ByteBuffer) buffer.slice().limit(HEADER_SIZE_BYTES);
+      String respEtag = resp.etag;
+      if (currentEtag != null && !resp.etag.equals(currentEtag)) {
+        System.err.println(
+          "ETag conflict detected; your HTTP server might not support content-based ETag headers. ETags disabled for " +
+          source.getKey()
+        );
+        respEtag = null;
+      }
+      // System.out.println("respEtag: " + respEtag);
+      Header header = bytesToHeader(headerData, respEtag);
+      //System.out.println("header: " + header);
+      if (prefetch) {
+        //System.out.println(header.getRootDirectoryOffset());
+        int rootDirOffset = (int) header.getRootDirectoryOffset();
+        int rootDirLength = (int) header.getRootDirectoryLength();
+        //System.out.println("rootDirOffset: " + rootDirOffset);
+        //System.out.println("rootDirLength: " + rootDirLength);
+        ByteBuffer rootDirData = (ByteBuffer) buffer.position(rootDirOffset);
+        rootDirData = (ByteBuffer) rootDirData.slice().limit(rootDirLength);
+
+        String dirKey =
+          source.getKey() +
+          "|" +
+          (header.getEtag() != null ? header.getEtag() : "") +
+          "|" +
+          rootDirOffset +
+          "|" +
+          rootDirLength;
+
+        ByteBuffer deserialized = Decompress.decompress(rootDirData, header.getInternalCompression());
+        //deserialized.order(ByteOrder.LITTLE_ENDIAN);
+        // for (int i = 0; i < deserialized.limit(); i++) {
+        //   System.out.printf("%d ", deserialized.get(i) & 0xFF);
+        // }
+        List<Entry> rootDir = deserializeIndex(deserialized);
+        //System.out.println("dirKey: " + dirKey);
+        //System.out.println("rootDirSize: " + rootDir.size());
+        //System.out.println("rootDir: " + rootDir);
+
+        return CompletableFuture.completedFuture(
+          new SimpleEntry<>(header, Optional.of(new RootDirData(dirKey, rootDir.size(), rootDir)))
+        );
+      }
+
+      return CompletableFuture.completedFuture(new SimpleEntry<>(header, Optional.empty()));
+    } catch (Exception e) {
+      return CompletableFuture.completedFuture(null);
+    }
+  }
+
+  public static CompletableFuture<List<Entry>> getDirectory(
+    Source source,
+    DecompressFunc decompress,
+    long offset,
+    long length,
+    Header header
+  ) {
+    //System.out.println("offset: " + offset);
+    //System.out.println("length: " + length);
+    return source
+      .getBytes(offset, length)
+      .thenApply(resp -> {
+        if (header.getEtag() != null && !header.getEtag().equals(resp.etag)) {
+          throw new EtagMismatch(resp.etag);
+        }
+
+        return decompress.decompress(resp.data, header.getInternalCompression());
+      })
+      .thenApply(data -> {
+        List<Entry> directory = deserializeIndex(data);
+        if (directory.isEmpty()) {
+          throw new RuntimeException("Empty directory is invalid");
+        }
+
+        return directory;
+      });
+  }
+
+  private static final long[] tzValues = {
+    0,
+    1,
+    5,
+    21,
+    85,
+    341,
+    1365,
+    5461,
+    21845,
+    87381,
+    349525,
+    1398101,
+    5592405,
+    22369621,
+    89478485,
+    357913941,
+    1431655765,
+    5726623061L,
+    22906492245L,
+    91625968981L,
+    366503875925L,
+    1466015503701L,
+    5864062014805L,
+    23456248059221L,
+    93824992236885L,
+    375299968947541L,
+    1501199875790165L,
+  };
+
+  public static void rotate(long n, long[] xy, long rx, long ry) {
+    if (ry == 0) {
+      if (rx == 1) {
+        xy[0] = n - 1 - xy[0];
+        xy[1] = n - 1 - xy[1];
+      }
+      long t = xy[0];
+      xy[0] = xy[1];
+      xy[1] = t;
+    }
+  }
+
+  public static int[] idOnLevel(int z, long pos) {
+    int n = (int) Math.pow(2, z);
+    long rx = pos;
+    long ry = pos;
+    long t = pos;
+    long[] xy = { 0, 0 };
+    long s = 1;
+    while (s < n) {
+      rx = 1 & (t / 2);
+      ry = 1 & (t ^ rx);
+      rotate(s, xy, rx, ry);
+      xy[0] += s * rx;
+      xy[1] += s * ry;
+      t = t / 4;
+      s *= 2;
+    }
+    return new int[] { z, (int) xy[0], (int) xy[1] };
+  }
+
+  public static long zxyToTileId(int z, int x, int y) {
+    if (z > 26) {
+      throw new Error("Tile zoom level exceeds max safe number limit (26)");
+    }
+    if (x > Math.pow(2, z) - 1 || y > Math.pow(2, z) - 1) {
+      throw new Error("tile x/y outside zoom level bounds");
+    }
+
+    long acc = tzValues[z];
+    long n = (long) Math.pow(2, z);
+    long rx = 0;
+    long ry = 0;
+    long d = 0;
+    long[] xy = { x, y };
+    long s = n / 2;
+    while (s > 0) {
+      rx = (xy[0] & s) > 0 ? 1 : 0;
+      ry = (xy[1] & s) > 0 ? 1 : 0;
+      d += s * s * ((3 * rx) ^ ry);
+      rotate(s, xy, rx, ry);
+      s = s / 2;
+    }
+    return acc + d;
+  }
+
+  public static int[] tileIdToZxy(long i) {
+    long acc = 0;
+    int z;
+
+    for (z = 0; z < 27; z++) {
+      long num_tiles = (long) Math.pow(2, z) * (long) Math.pow(2, z);
+      if (acc + num_tiles > i) {
+        return idOnLevel(z, i - acc);
+      }
+      acc += num_tiles;
+    }
+
+    throw new Error("Tile zoom level exceeds max safe number limit (26)");
+  }
+
+  public static Entry findTile(List<Entry> entries, long tileId) {
+    int m = 0;
+    int n = entries.size() - 1;
+    //System.out.println("entries.size() = " + entries.size());
+    //System.out.println("tileId = " + tileId);
+    while (m <= n) {
+      int k = (n + m) >> 1;
+      //System.out.println("k = " + k);
+      //System.out.println("entries.get(k).tileId = " + entries.get(k).tileId);
+      // System.out.println(
+      //   "entries.get(k).runLength = " + entries.get(k).runLength
+      // );
+      // System.out.println("entries.get(k).offset = " + entries.get(k).offset);
+
+      int cmp = Long.compare(tileId, entries.get(k).tileId);
+      if (cmp > 0) {
+        m = k + 1;
+      } else if (cmp < 0) {
+        n = k - 1;
+      } else {
+        //System.out.println("found");
+        return entries.get(k);
+      }
+    }
+    //System.out.println("n = " + n);
+    // System.out.println(
+    //   "entries.get(n).runLength = " + entries.get(n).runLength
+    // );
+    // at this point, m > n
+    if (n >= 0) {
+      if (entries.get(n).runLength == 0) {
+        return entries.get(n);
+      }
+      if (tileId - entries.get(n).tileId < entries.get(n).runLength) {
+        return entries.get(n);
+      }
+    }
+    return null;
+  }
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/RangeResponse.class b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/RangeResponse.class
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/RangeResponse.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/RangeResponse.java
new file mode 100644
index 0000000..d55aba9
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/RangeResponse.java
@@ -0,0 +1,23 @@
+package PMTiles;
+
+import java.nio.ByteBuffer;
+
+public class RangeResponse {
+
+  public ByteBuffer data;
+  public String etag;
+  public String cacheControl;
+  public String expires;
+
+  public RangeResponse(
+    ByteBuffer data,
+    String etag,
+    String cacheControl,
+    String expires
+  ) {
+    this.data = data;
+    this.etag = etag;
+    this.cacheControl = cacheControl;
+    this.expires = expires;
+  }
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/RootDirData.class b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/RootDirData.class
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/RootDirData.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/RootDirData.java
new file mode 100644
index 0000000..e5d1e83
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/RootDirData.java
@@ -0,0 +1,28 @@
+package PMTiles;
+
+import java.util.List;
+
+public class RootDirData {
+
+  private String dirKey;
+  private int length;
+  private List<Entry> entries;
+
+  public RootDirData(String dirKey, int length, List<Entry> entries) {
+    this.dirKey = dirKey;
+    this.length = length;
+    this.entries = entries;
+  }
+
+  public String getDirKey() {
+    return dirKey;
+  }
+
+  public int getLength() {
+    return length;
+  }
+
+  public List<Entry> getEntries() {
+    return entries;
+  }
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/SharedPromiseCache.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/SharedPromiseCache.java
new file mode 100644
index 0000000..9acd5f0
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/SharedPromiseCache.java
@@ -0,0 +1,151 @@
+package PMTiles;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.AbstractMap.SimpleEntry;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+
+class SharedPromiseCacheValue<T> {
+
+  private long lastUsed;
+  private CompletableFuture<T> data;
+
+  public SharedPromiseCacheValue(long lastUsed, CompletableFuture<T> data) {
+    this.lastUsed = lastUsed;
+    this.data = data;
+  }
+
+  public long getLastUsed() {
+    return lastUsed;
+  }
+
+  public void setLastUsed(long lastUsed) {
+    this.lastUsed = lastUsed;
+  }
+
+  public CompletableFuture<T> getData() {
+    return data;
+  }
+
+  public void setData(CompletableFuture<T> data) {
+    this.data = data;
+  }
+}
+
+public class SharedPromiseCache implements Cache {
+
+  private final Map<String, SharedPromiseCacheValue> cache;
+  private final int maxCacheEntries;
+  private long counter;
+  private final boolean prefetch;
+  private final DecompressFunc decompress;
+
+  public SharedPromiseCache(int maxCacheEntries, boolean prefetch, DecompressFunc decompress) {
+    this.cache = new HashMap<String, SharedPromiseCacheValue>();
+    this.maxCacheEntries = maxCacheEntries;
+    this.counter = 1;
+    this.prefetch = prefetch;
+    this.decompress = decompress;
+  }
+
+  public CompletableFuture<Header> getHeader(Source source, String currentEtag) {
+    String cacheKey = source.getKey();
+    if (cache.containsKey(cacheKey)) {
+      cache.get(cacheKey).setLastUsed(counter++);
+      return (CompletableFuture<Header>) cache.get(cacheKey).getData();
+    }
+
+    CompletableFuture<Header> promise = PMTilesUtils
+      .getHeaderAndRoot(source, prefetch, currentEtag)
+      .thenApply(res -> {
+        if (res == null || res.getKey() == null) {
+          return null;
+        }
+
+        Optional<RootDirData> rootDirDataOpt = res.getValue();
+
+        cache.put(
+          rootDirDataOpt.get().getDirKey(),
+          new SharedPromiseCacheValue(counter++, CompletableFuture.completedFuture(rootDirDataOpt.get().getEntries()))
+        );
+
+        prune();
+        return res.getKey();
+      })
+      .exceptionally(ex -> {
+        return null;
+      });
+
+    cache.put(cacheKey, new SharedPromiseCacheValue(counter++, promise));
+
+    return promise;
+  }
+
+  public CompletableFuture<List<Entry>> getDirectory(Source source, long offset, long length, Header header) {
+    String cacheKey =
+      source.getKey() + "|" + (header.getEtag() != null ? header.getEtag() : "") + "|" + offset + "|" + length;
+    //System.out.println("getDirectory: " + cacheKey);
+    if (cache.containsKey(cacheKey)) {
+      //System.out.println("getDirectory: " + cacheKey + " - cache hit");
+      cache.get(cacheKey).setLastUsed(counter++);
+      return (CompletableFuture<List<Entry>>) cache.get(cacheKey).getData();
+    }
+
+    CompletableFuture<List<Entry>> promise = PMTilesUtils.getDirectory(source, decompress, offset, length, header);
+
+    //System.out.println("getDirectory: " + cacheKey);
+    cache.put(cacheKey, new SharedPromiseCacheValue(counter++, promise));
+    prune();
+    //System.out.println("cache" + cache);
+    return promise;
+  }
+
+  public CompletableFuture<ByteBuffer> getArrayBuffer(Source source, long offset, long length, Header header) {
+    String cacheKey =
+      source.getKey() + "|" + (header.getEtag() != null ? header.getEtag() : "") + "|" + offset + "|" + length;
+    if (cache.containsKey(cacheKey)) {
+      cache.get(cacheKey).setLastUsed(counter++);
+      return (CompletableFuture<ByteBuffer>) cache.get(cacheKey).getData();
+    }
+
+    CompletableFuture<ByteBuffer> promise = source
+      .getBytes(offset, length)
+      .thenApply(resp -> {
+        if (header.getEtag() != null && !header.getEtag().equals(resp.etag)) {
+          throw new EtagMismatch(resp.etag);
+        }
+        prune();
+        return resp.data;
+      });
+
+    cache.put(cacheKey, new SharedPromiseCacheValue(counter++, promise));
+    return promise;
+  }
+
+  private void prune() {
+    if (cache.size() >= maxCacheEntries) {
+      long minUsed = Long.MAX_VALUE;
+      String minKey = null;
+      for (Map.Entry<String, SharedPromiseCacheValue> entry : cache.entrySet()) {
+        if (entry.getValue().getLastUsed() < minUsed) {
+          minUsed = entry.getValue().getLastUsed();
+          minKey = entry.getKey();
+        }
+      }
+      if (minKey != null) {
+        cache.remove(minKey);
+      }
+    }
+  }
+
+  public CompletableFuture<Void> invalidate(Source source, String currentEtag) {
+    cache.remove(source.getKey());
+    return getHeader(source, currentEtag).thenAccept(header -> {});
+  }
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/SharedPromiseCacheValue.class b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/SharedPromiseCacheValue.class
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Source.class b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Source.class
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Source.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Source.java
new file mode 100644
index 0000000..59075aa
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/Source.java
@@ -0,0 +1,9 @@
+package PMTiles;
+
+import java.util.concurrent.CompletableFuture;
+
+public interface Source {
+  CompletableFuture<RangeResponse> getBytes(long offset, long length);
+
+  String getKey();
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/TileType.class b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/TileType.class
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/TileType.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/TileType.java
new file mode 100644
index 0000000..744a96a
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/TileType.java
@@ -0,0 +1,19 @@
+package PMTiles;
+
+public enum TileType {
+  Unknown(0),
+  Mvt(1),
+  Png(2),
+  Jpeg(3),
+  Webp(4);
+
+  private final int value;
+
+  TileType(int value) {
+    this.value = value;
+  }
+
+  public int getValue() {
+    return value;
+  }
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/VectorLayer.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/VectorLayer.java
new file mode 100644
index 0000000..bac1189
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/PMTiles/VectorLayer.java
@@ -0,0 +1,11 @@
+package PMTiles;
+
+public class VectorLayer {
+
+  public String id;
+
+  @Override
+  public String toString() {
+    return "VectorLayer{id='" + id + "'}";
+  }
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/VectorStyle/LayerStyle.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/VectorStyle/LayerStyle.java
new file mode 100644
index 0000000..8824688
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/VectorStyle/LayerStyle.java
@@ -0,0 +1,32 @@
+package VectorTileStyle;
+
+import VectorTileStyle.LayoutStyle;
+import VectorTileStyle.PaintStyle;
+import com.google.gson.Gson;
+import com.google.gson.annotations.SerializedName;
+import java.util.Map;
+
+public class LayerStyle {
+
+  public String id;
+  public String type;
+  public String source;
+
+  @SerializedName("source-layer")
+  public String sourceLayer;
+
+  public Integer minzoom;
+  public Integer maxzoom;
+
+  public PaintStyle paint; // Map<String, Object> の代わりに
+  public LayoutStyle layout; // Map<String, Object> の代わりに
+
+  public Object filter;
+
+  @Override
+  public String toString() {
+    // Gson オブジェクトを使ってオブジェクトを JSON 形式の文字列に変換
+    Gson gson = new Gson();
+    return gson.toJson(this);
+  }
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/VectorStyle/LayoutStyle.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/VectorStyle/LayoutStyle.java
new file mode 100644
index 0000000..f674e64
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/VectorStyle/LayoutStyle.java
@@ -0,0 +1,17 @@
+package VectorTileStyle;
+
+import com.google.gson.annotations.SerializedName;
+import java.util.List;
+
+public class LayoutStyle {
+
+  @SerializedName("text-field")
+  public List<String> textField;
+
+  @SerializedName("text-size")
+  public Integer textSize;
+
+  @SerializedName("text-font")
+  public List<String> textFont;
+  // 他のlayout属性もこちらに追加
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/VectorStyle/PaintStyle.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/VectorStyle/PaintStyle.java
new file mode 100644
index 0000000..8ecd4e3
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/VectorStyle/PaintStyle.java
@@ -0,0 +1,43 @@
+package VectorTileStyle;
+
+import com.google.gson.annotations.SerializedName;
+
+public class PaintStyle {
+
+  @SerializedName("fill-color")
+  public Object fillColor;
+
+  @SerializedName("fill-outline-color")
+  public String fillOutlineColor;
+
+  @SerializedName("fill-opacity")
+  public Float fillOpacity;
+
+  @SerializedName("line-color")
+  public Object lineColor;
+
+  @SerializedName("line-width")
+  public Float lineWidth;
+
+  @SerializedName("circle-color")
+  public Object circleColor;
+
+  @SerializedName("circle-radius")
+  public Float circleRadius;
+
+  @SerializedName("circle-stroke-color")
+  public String circleStrokeColor;
+
+  @SerializedName("circle-stroke-width")
+  public Float circleStrokeWidth;
+
+  @SerializedName("text-color")
+  public Object textColor;
+
+  @SerializedName("text-halo-color")
+  public String textHaloColor;
+
+  @SerializedName("text-halo-width")
+  public Float textHaloWidth;
+  // 他のpaint属性もこちらに追加
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/VectorStyle/VectorStyle.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/VectorStyle/VectorStyle.java
new file mode 100644
index 0000000..e093889
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/VectorStyle/VectorStyle.java
@@ -0,0 +1,9 @@
+package VectorTileStyle;
+
+import com.google.gson.annotations.SerializedName;
+import java.util.List;
+
+public class VectorStyle {
+
+  public List<LayerStyle> layers;
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/VectorStyle/VectorTileStyleManager.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/VectorStyle/VectorTileStyleManager.java
new file mode 100644
index 0000000..1d7741c
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/VectorStyle/VectorTileStyleManager.java
@@ -0,0 +1,230 @@
+package VectorTileStyleManager;
+
+import PMTiles.Metadata;
+import PMTiles.VectorLayer;
+import VectorTileStyle.LayerStyle;
+import VectorTileStyle.VectorStyle;
+import android.util.Log;
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.reflect.TypeToken;
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.lang.reflect.Type;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.nio.file.FileAlreadyExistsException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.CompletableFuture;
+
+public class VectorTileStyleManager {
+
+  private String urlTemplate;
+  private String localPath;
+  private long lastUpdatedTime = 0; // long型で記録
+  private List<LayerStyle> styleLayers; // ダウンロードしたスタイル情報を保存
+  private boolean offlineMode = false;
+
+  public VectorTileStyleManager(String urlTemplate, String tileCachePath, String styleURL, Boolean offlineMode) {
+    //Log.d("urlTile","##" + metadata.name + "##" + metadata.type);
+    //Log.d("urlTile", "##styleURL: " + styleURL);
+    if (styleURL != null && !styleURL.trim().isEmpty()) {
+      this.urlTemplate = styleURL.trim();
+    }
+    if (tileCachePath != null && !tileCachePath.trim().isEmpty()) {
+      this.localPath = tileCachePath.trim() + "/style.json";
+    }
+    // System.out.println("##localPath: " + this.localPath);
+    // System.out.println("##urlTemplate: " + this.urlTemplate);
+
+    this.offlineMode = offlineMode;
+  }
+
+  public CompletableFuture<Void> initialize() {
+    return loadStyleAsync()
+      .thenAccept(style -> {
+        Gson gson = new Gson();
+        Type styleType = new TypeToken<VectorStyle>() {}.getType();
+        VectorStyle vectorStyle = gson.fromJson(style, styleType);
+        this.styleLayers = vectorStyle.layers;
+      })
+      .exceptionally(exception -> {
+        //System.out.println("##exception: " + exception);
+        this.styleLayers = new ArrayList<>();
+        return null;
+      });
+  }
+
+  private void removeStyleFile() {
+    Path path = Paths.get(this.localPath);
+    try {
+      // System.out.println("##removeStyleFile: " + path);
+      Files.deleteIfExists(path);
+    } catch (IOException e) {
+      // System.out.println("##IOException: " + e);
+      throw new RuntimeException("Failed to remove style file", e);
+    }
+  }
+
+  public CompletableFuture<String> loadStyleAsync() {
+    return CompletableFuture.supplyAsync(() -> {
+      try {
+        // まずダウンロードを試みる
+        String style = downloadStyleJson(this.urlTemplate);
+        return saveStyle(style);
+      } catch (Exception e) {
+        // styleURLが指定されていない場合は、キャッシュにあるファイルを削除する
+        if ((this.urlTemplate == null || this.urlTemplate.trim().isEmpty()) && !this.offlineMode) {
+          removeStyleFile();
+          throw new RuntimeException("No style URL is specified", e);
+        }
+        // ダウンロードに失敗した場合は、ローカルファイルを読む
+        Path path = Paths.get(localPath);
+        if (Files.exists(path)) {
+          try {
+            lastUpdatedTime = path.toFile().lastModified();
+            return new String(Files.readAllBytes(path));
+          } catch (IOException ex) {
+            throw new RuntimeException("Failed to read local file", ex);
+          }
+        } else {
+          throw new RuntimeException("Failed to download and save style", e);
+        }
+      }
+    });
+  }
+
+  public String saveStyle(String style) throws IOException {
+    Path path = Paths.get(this.localPath);
+
+    if (Files.exists(path)) {
+      // すでにファイルが存在する場合、内容を比較
+      String existingStyle = new String(Files.readAllBytes(path));
+
+      if (!existingStyle.equals(style)) {
+        // 異なる場合は新しい内容で上書き
+        Files.write(path, style.getBytes());
+        lastUpdatedTime = System.currentTimeMillis();
+      } else {
+        // 同じ場合は更新しない
+        lastUpdatedTime = path.toFile().lastModified();
+      }
+    } else {
+      // ディレクトリが存在しない場合は、ディレクトリを作成
+      if (!Files.exists(path.getParent())) {
+        Files.createDirectories(path.getParent());
+      }
+      // ファイルが存在しない場合、新しく書き込み
+      Files.write(path, style.getBytes());
+      lastUpdatedTime = System.currentTimeMillis();
+    }
+
+    return style;
+  }
+
+  private String downloadStyleJson(String url) {
+    StringBuilder response = new StringBuilder();
+    try {
+      URL obj = new URL(url);
+      HttpURLConnection con = (HttpURLConnection) obj.openConnection();
+      con.setRequestMethod("GET");
+      int responseCode = con.getResponseCode();
+
+      if (responseCode == HttpURLConnection.HTTP_OK) {
+        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));
+        String inputLine;
+        while ((inputLine = in.readLine()) != null) {
+          response.append(inputLine);
+        }
+        in.close();
+      } else {
+        //System.out.println("##responseCode: " + responseCode);
+        throw new RuntimeException("Bad response code: " + responseCode);
+      }
+    } catch (IOException e) {
+      //System.out.println("##IOException2: " + e);
+      throw new RuntimeException("Failed to download style JSON", e);
+    }
+
+    return response.toString();
+  }
+
+  public List<LayerStyle> getDefaultStyleLayers(Metadata metadata) {
+    // System.out.println("##name: " + metadata.name);
+    List<LayerStyle> styleLayers = new ArrayList<>();
+    Gson gson = new Gson();
+    Type styleLayerListType = new TypeToken<List<LayerStyle>>() {}.getType();
+    for (VectorLayer layer : metadata.vectorLayers) {
+      // System.out.println("##id: " + layer.id);
+      String json = String.format(
+        "[\n" +
+        "  {\n" +
+        "    \"id\": \"%1$s_fill\",\n" +
+        "    \"type\": \"fill\",\n" +
+        "    \"source\": \"example-source\",\n" +
+        "    \"source-layer\": \"%1$s\",\n" +
+        "    \"minzoom\": 0,\n" +
+        "    \"maxzoom\": 24,\n" +
+        "    \"paint\": {\n" +
+        "      \"fill-color\": \"#00FF00\",\n" +
+        "      \"fill-outline-color\": \"#000000\",\n" +
+        "      \"fill-opacity\": 0.5\n" +
+        "    }\n" +
+        "  },\n" +
+        "  {\n" +
+        "    \"id\": \"%1$s_stroke\",\n" +
+        "    \"type\": \"line\",\n" +
+        "    \"source\": \"example-source\",\n" +
+        "    \"source-layer\": \"%1$s\",\n" +
+        "    \"minzoom\": 0,\n" +
+        "    \"maxzoom\": 24,\n" +
+        "    \"paint\": {\n" +
+        "      \"line-color\": \"#0000FF\",\n" +
+        "      \"line-width\": 1\n" +
+        "    }\n" +
+        "  },\n" +
+        "  {\n" +
+        "    \"id\": \"%1$s_point\",\n" +
+        "    \"type\": \"circle\",\n" +
+        "    \"source\": \"example-source\",\n" +
+        "    \"source-layer\": \"%1$s\",\n" +
+        "    \"minzoom\": 0,\n" +
+        "    \"maxzoom\": 24,\n" +
+        "    \"paint\": {\n" +
+        "      \"circle-color\": \"#FF0000\",\n" +
+        "      \"circle-radius\": 3,\n" +
+        "      \"circle-stroke-width\": 1,\n" +
+        "      \"circle-stroke-color\": \"#FFFFFF\"\n" +
+        "    }\n" +
+        "  }\n" +
+        "]",
+        layer.id
+      );
+      List<LayerStyle> newLayers = gson.fromJson(json, styleLayerListType);
+      styleLayers.addAll(newLayers);
+    }
+    String styleLayersString = gson.toJson(styleLayers);
+    //Log.d("urlTile", "##styleLayersString: " + styleLayersString);
+    try {
+      saveStyle(styleLayersString);
+    } catch (IOException e) {
+      throw new RuntimeException("Failed to save default style layers", e);
+    }
+    return styleLayers;
+  }
+
+  public List<LayerStyle> getStyleLayers() {
+    //Log.d("urlTile", "##getStyleLayers: " + this.styleLayers);
+    return this.styleLayers;
+  }
+
+  public long getLastUpdatedTime() {
+    return lastUpdatedTime;
+  }
+}
diff --git a/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/vector_tile/VectorTile.java b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/vector_tile/VectorTile.java
new file mode 100644
index 0000000..69be0be
--- /dev/null
+++ b/node_modules/react-native-maps/android/src/main/java/com/rnmaps/maps/vector_tile/VectorTile.java
@@ -0,0 +1,3887 @@
+// Generated by the protocol buffer compiler.  DO NOT EDIT!
+// source: vector_tile.proto
+
+package vector_tile;
+
+public final class VectorTile {
+  private VectorTile() {}
+  public static void registerAllExtensions(
+      com.google.protobuf.ExtensionRegistryLite registry) {
+  }
+  public interface TileOrBuilder extends 
+      // @@protoc_insertion_point(interface_extends:vector_tile.Tile)
+       com.google.protobuf.GeneratedMessageLite.
+            ExtendableMessageOrBuilder<
+                Tile, Tile.Builder> {
+
+    /**
+     * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+     */
+    java.util.List<vector_tile.VectorTile.Tile.Layer> 
+        getLayersList();
+    /**
+     * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+     */
+    vector_tile.VectorTile.Tile.Layer getLayers(int index);
+    /**
+     * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+     */
+    int getLayersCount();
+  }
+  /**
+   * Protobuf type {@code vector_tile.Tile}
+   */
+  public  static final class Tile extends
+      com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
+        Tile, Tile.Builder> implements
+      // @@protoc_insertion_point(message_implements:vector_tile.Tile)
+      TileOrBuilder {
+    private Tile() {
+      layers_ = emptyProtobufList();
+    }
+    /**
+     * <pre>
+     * GeomType is described in section 4.3.4 of the specification
+     * </pre>
+     *
+     * Protobuf enum {@code vector_tile.Tile.GeomType}
+     */
+    public enum GeomType
+        implements com.google.protobuf.Internal.EnumLite {
+      /**
+       * <code>UNKNOWN = 0;</code>
+       */
+      UNKNOWN(0),
+      /**
+       * <code>POINT = 1;</code>
+       */
+      POINT(1),
+      /**
+       * <code>LINESTRING = 2;</code>
+       */
+      LINESTRING(2),
+      /**
+       * <code>POLYGON = 3;</code>
+       */
+      POLYGON(3),
+      ;
+
+      /**
+       * <code>UNKNOWN = 0;</code>
+       */
+      public static final int UNKNOWN_VALUE = 0;
+      /**
+       * <code>POINT = 1;</code>
+       */
+      public static final int POINT_VALUE = 1;
+      /**
+       * <code>LINESTRING = 2;</code>
+       */
+      public static final int LINESTRING_VALUE = 2;
+      /**
+       * <code>POLYGON = 3;</code>
+       */
+      public static final int POLYGON_VALUE = 3;
+
+
+      @java.lang.Override
+      public final int getNumber() {
+        return value;
+      }
+
+      /**
+       * @param value The number of the enum to look for.
+       * @return The enum associated with the given number.
+       * @deprecated Use {@link #forNumber(int)} instead.
+       */
+      @java.lang.Deprecated
+      public static GeomType valueOf(int value) {
+        return forNumber(value);
+      }
+
+      public static GeomType forNumber(int value) {
+        switch (value) {
+          case 0: return UNKNOWN;
+          case 1: return POINT;
+          case 2: return LINESTRING;
+          case 3: return POLYGON;
+          default: return null;
+        }
+      }
+
+      public static com.google.protobuf.Internal.EnumLiteMap<GeomType>
+          internalGetValueMap() {
+        return internalValueMap;
+      }
+      private static final com.google.protobuf.Internal.EnumLiteMap<
+          GeomType> internalValueMap =
+            new com.google.protobuf.Internal.EnumLiteMap<GeomType>() {
+              @java.lang.Override
+              public GeomType findValueByNumber(int number) {
+                return GeomType.forNumber(number);
+              }
+            };
+
+      public static com.google.protobuf.Internal.EnumVerifier 
+          internalGetVerifier() {
+        return GeomTypeVerifier.INSTANCE;
+      }
+
+      private static final class GeomTypeVerifier implements 
+           com.google.protobuf.Internal.EnumVerifier { 
+              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new GeomTypeVerifier();
+              @java.lang.Override
+              public boolean isInRange(int number) {
+                return GeomType.forNumber(number) != null;
+              }
+            };
+
+      private final int value;
+
+      private GeomType(int value) {
+        this.value = value;
+      }
+
+      // @@protoc_insertion_point(enum_scope:vector_tile.Tile.GeomType)
+    }
+
+    public interface ValueOrBuilder extends 
+        // @@protoc_insertion_point(interface_extends:vector_tile.Tile.Value)
+         com.google.protobuf.GeneratedMessageLite.
+              ExtendableMessageOrBuilder<
+                  Value, Value.Builder> {
+
+      /**
+       * <pre>
+       * Exactly one of these values must be present in a valid message
+       * </pre>
+       *
+       * <code>optional string string_value = 1;</code>
+       * @return Whether the stringValue field is set.
+       */
+      boolean hasStringValue();
+      /**
+       * <pre>
+       * Exactly one of these values must be present in a valid message
+       * </pre>
+       *
+       * <code>optional string string_value = 1;</code>
+       * @return The stringValue.
+       */
+      java.lang.String getStringValue();
+      /**
+       * <pre>
+       * Exactly one of these values must be present in a valid message
+       * </pre>
+       *
+       * <code>optional string string_value = 1;</code>
+       * @return The bytes for stringValue.
+       */
+      com.google.protobuf.ByteString
+          getStringValueBytes();
+
+      /**
+       * <code>optional float float_value = 2;</code>
+       * @return Whether the floatValue field is set.
+       */
+      boolean hasFloatValue();
+      /**
+       * <code>optional float float_value = 2;</code>
+       * @return The floatValue.
+       */
+      float getFloatValue();
+
+      /**
+       * <code>optional double double_value = 3;</code>
+       * @return Whether the doubleValue field is set.
+       */
+      boolean hasDoubleValue();
+      /**
+       * <code>optional double double_value = 3;</code>
+       * @return The doubleValue.
+       */
+      double getDoubleValue();
+
+      /**
+       * <code>optional int64 int_value = 4;</code>
+       * @return Whether the intValue field is set.
+       */
+      boolean hasIntValue();
+      /**
+       * <code>optional int64 int_value = 4;</code>
+       * @return The intValue.
+       */
+      long getIntValue();
+
+      /**
+       * <code>optional uint64 uint_value = 5;</code>
+       * @return Whether the uintValue field is set.
+       */
+      boolean hasUintValue();
+      /**
+       * <code>optional uint64 uint_value = 5;</code>
+       * @return The uintValue.
+       */
+      long getUintValue();
+
+      /**
+       * <code>optional sint64 sint_value = 6;</code>
+       * @return Whether the sintValue field is set.
+       */
+      boolean hasSintValue();
+      /**
+       * <code>optional sint64 sint_value = 6;</code>
+       * @return The sintValue.
+       */
+      long getSintValue();
+
+      /**
+       * <code>optional bool bool_value = 7;</code>
+       * @return Whether the boolValue field is set.
+       */
+      boolean hasBoolValue();
+      /**
+       * <code>optional bool bool_value = 7;</code>
+       * @return The boolValue.
+       */
+      boolean getBoolValue();
+    }
+    /**
+     * <pre>
+     * Variant type encoding
+     * The use of values is described in section 4.1 of the specification
+     * </pre>
+     *
+     * Protobuf type {@code vector_tile.Tile.Value}
+     */
+    public  static final class Value extends
+        com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
+          Value, Value.Builder> implements
+        // @@protoc_insertion_point(message_implements:vector_tile.Tile.Value)
+        ValueOrBuilder {
+      private Value() {
+        stringValue_ = "";
+      }
+      private int bitField0_;
+      public static final int STRING_VALUE_FIELD_NUMBER = 1;
+      private java.lang.String stringValue_;
+      /**
+       * <pre>
+       * Exactly one of these values must be present in a valid message
+       * </pre>
+       *
+       * <code>optional string string_value = 1;</code>
+       * @return Whether the stringValue field is set.
+       */
+      @java.lang.Override
+      public boolean hasStringValue() {
+        return ((bitField0_ & 0x00000001) != 0);
+      }
+      /**
+       * <pre>
+       * Exactly one of these values must be present in a valid message
+       * </pre>
+       *
+       * <code>optional string string_value = 1;</code>
+       * @return The stringValue.
+       */
+      @java.lang.Override
+      public java.lang.String getStringValue() {
+        return stringValue_;
+      }
+      /**
+       * <pre>
+       * Exactly one of these values must be present in a valid message
+       * </pre>
+       *
+       * <code>optional string string_value = 1;</code>
+       * @return The bytes for stringValue.
+       */
+      @java.lang.Override
+      public com.google.protobuf.ByteString
+          getStringValueBytes() {
+        return com.google.protobuf.ByteString.copyFromUtf8(stringValue_);
+      }
+      /**
+       * <pre>
+       * Exactly one of these values must be present in a valid message
+       * </pre>
+       *
+       * <code>optional string string_value = 1;</code>
+       * @param value The stringValue to set.
+       */
+      private void setStringValue(
+          java.lang.String value) {
+        java.lang.Class<?> valueClass = value.getClass();
+  bitField0_ |= 0x00000001;
+        stringValue_ = value;
+      }
+      /**
+       * <pre>
+       * Exactly one of these values must be present in a valid message
+       * </pre>
+       *
+       * <code>optional string string_value = 1;</code>
+       */
+      private void clearStringValue() {
+        bitField0_ = (bitField0_ & ~0x00000001);
+        stringValue_ = getDefaultInstance().getStringValue();
+      }
+      /**
+       * <pre>
+       * Exactly one of these values must be present in a valid message
+       * </pre>
+       *
+       * <code>optional string string_value = 1;</code>
+       * @param value The bytes for stringValue to set.
+       */
+      private void setStringValueBytes(
+          com.google.protobuf.ByteString value) {
+        stringValue_ = value.toStringUtf8();
+        bitField0_ |= 0x00000001;
+      }
+
+      public static final int FLOAT_VALUE_FIELD_NUMBER = 2;
+      private float floatValue_;
+      /**
+       * <code>optional float float_value = 2;</code>
+       * @return Whether the floatValue field is set.
+       */
+      @java.lang.Override
+      public boolean hasFloatValue() {
+        return ((bitField0_ & 0x00000002) != 0);
+      }
+      /**
+       * <code>optional float float_value = 2;</code>
+       * @return The floatValue.
+       */
+      @java.lang.Override
+      public float getFloatValue() {
+        return floatValue_;
+      }
+      /**
+       * <code>optional float float_value = 2;</code>
+       * @param value The floatValue to set.
+       */
+      private void setFloatValue(float value) {
+        bitField0_ |= 0x00000002;
+        floatValue_ = value;
+      }
+      /**
+       * <code>optional float float_value = 2;</code>
+       */
+      private void clearFloatValue() {
+        bitField0_ = (bitField0_ & ~0x00000002);
+        floatValue_ = 0F;
+      }
+
+      public static final int DOUBLE_VALUE_FIELD_NUMBER = 3;
+      private double doubleValue_;
+      /**
+       * <code>optional double double_value = 3;</code>
+       * @return Whether the doubleValue field is set.
+       */
+      @java.lang.Override
+      public boolean hasDoubleValue() {
+        return ((bitField0_ & 0x00000004) != 0);
+      }
+      /**
+       * <code>optional double double_value = 3;</code>
+       * @return The doubleValue.
+       */
+      @java.lang.Override
+      public double getDoubleValue() {
+        return doubleValue_;
+      }
+      /**
+       * <code>optional double double_value = 3;</code>
+       * @param value The doubleValue to set.
+       */
+      private void setDoubleValue(double value) {
+        bitField0_ |= 0x00000004;
+        doubleValue_ = value;
+      }
+      /**
+       * <code>optional double double_value = 3;</code>
+       */
+      private void clearDoubleValue() {
+        bitField0_ = (bitField0_ & ~0x00000004);
+        doubleValue_ = 0D;
+      }
+
+      public static final int INT_VALUE_FIELD_NUMBER = 4;
+      private long intValue_;
+      /**
+       * <code>optional int64 int_value = 4;</code>
+       * @return Whether the intValue field is set.
+       */
+      @java.lang.Override
+      public boolean hasIntValue() {
+        return ((bitField0_ & 0x00000008) != 0);
+      }
+      /**
+       * <code>optional int64 int_value = 4;</code>
+       * @return The intValue.
+       */
+      @java.lang.Override
+      public long getIntValue() {
+        return intValue_;
+      }
+      /**
+       * <code>optional int64 int_value = 4;</code>
+       * @param value The intValue to set.
+       */
+      private void setIntValue(long value) {
+        bitField0_ |= 0x00000008;
+        intValue_ = value;
+      }
+      /**
+       * <code>optional int64 int_value = 4;</code>
+       */
+      private void clearIntValue() {
+        bitField0_ = (bitField0_ & ~0x00000008);
+        intValue_ = 0L;
+      }
+
+      public static final int UINT_VALUE_FIELD_NUMBER = 5;
+      private long uintValue_;
+      /**
+       * <code>optional uint64 uint_value = 5;</code>
+       * @return Whether the uintValue field is set.
+       */
+      @java.lang.Override
+      public boolean hasUintValue() {
+        return ((bitField0_ & 0x00000010) != 0);
+      }
+      /**
+       * <code>optional uint64 uint_value = 5;</code>
+       * @return The uintValue.
+       */
+      @java.lang.Override
+      public long getUintValue() {
+        return uintValue_;
+      }
+      /**
+       * <code>optional uint64 uint_value = 5;</code>
+       * @param value The uintValue to set.
+       */
+      private void setUintValue(long value) {
+        bitField0_ |= 0x00000010;
+        uintValue_ = value;
+      }
+      /**
+       * <code>optional uint64 uint_value = 5;</code>
+       */
+      private void clearUintValue() {
+        bitField0_ = (bitField0_ & ~0x00000010);
+        uintValue_ = 0L;
+      }
+
+      public static final int SINT_VALUE_FIELD_NUMBER = 6;
+      private long sintValue_;
+      /**
+       * <code>optional sint64 sint_value = 6;</code>
+       * @return Whether the sintValue field is set.
+       */
+      @java.lang.Override
+      public boolean hasSintValue() {
+        return ((bitField0_ & 0x00000020) != 0);
+      }
+      /**
+       * <code>optional sint64 sint_value = 6;</code>
+       * @return The sintValue.
+       */
+      @java.lang.Override
+      public long getSintValue() {
+        return sintValue_;
+      }
+      /**
+       * <code>optional sint64 sint_value = 6;</code>
+       * @param value The sintValue to set.
+       */
+      private void setSintValue(long value) {
+        bitField0_ |= 0x00000020;
+        sintValue_ = value;
+      }
+      /**
+       * <code>optional sint64 sint_value = 6;</code>
+       */
+      private void clearSintValue() {
+        bitField0_ = (bitField0_ & ~0x00000020);
+        sintValue_ = 0L;
+      }
+
+      public static final int BOOL_VALUE_FIELD_NUMBER = 7;
+      private boolean boolValue_;
+      /**
+       * <code>optional bool bool_value = 7;</code>
+       * @return Whether the boolValue field is set.
+       */
+      @java.lang.Override
+      public boolean hasBoolValue() {
+        return ((bitField0_ & 0x00000040) != 0);
+      }
+      /**
+       * <code>optional bool bool_value = 7;</code>
+       * @return The boolValue.
+       */
+      @java.lang.Override
+      public boolean getBoolValue() {
+        return boolValue_;
+      }
+      /**
+       * <code>optional bool bool_value = 7;</code>
+       * @param value The boolValue to set.
+       */
+      private void setBoolValue(boolean value) {
+        bitField0_ |= 0x00000040;
+        boolValue_ = value;
+      }
+      /**
+       * <code>optional bool bool_value = 7;</code>
+       */
+      private void clearBoolValue() {
+        bitField0_ = (bitField0_ & ~0x00000040);
+        boolValue_ = false;
+      }
+
+      public static vector_tile.VectorTile.Tile.Value parseFrom(
+          java.nio.ByteBuffer data)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, data);
+      }
+      public static vector_tile.VectorTile.Tile.Value parseFrom(
+          java.nio.ByteBuffer data,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, data, extensionRegistry);
+      }
+      public static vector_tile.VectorTile.Tile.Value parseFrom(
+          com.google.protobuf.ByteString data)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, data);
+      }
+      public static vector_tile.VectorTile.Tile.Value parseFrom(
+          com.google.protobuf.ByteString data,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, data, extensionRegistry);
+      }
+      public static vector_tile.VectorTile.Tile.Value parseFrom(byte[] data)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, data);
+      }
+      public static vector_tile.VectorTile.Tile.Value parseFrom(
+          byte[] data,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, data, extensionRegistry);
+      }
+      public static vector_tile.VectorTile.Tile.Value parseFrom(java.io.InputStream input)
+          throws java.io.IOException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, input);
+      }
+      public static vector_tile.VectorTile.Tile.Value parseFrom(
+          java.io.InputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws java.io.IOException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, input, extensionRegistry);
+      }
+      public static vector_tile.VectorTile.Tile.Value parseDelimitedFrom(java.io.InputStream input)
+          throws java.io.IOException {
+        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
+      }
+      public static vector_tile.VectorTile.Tile.Value parseDelimitedFrom(
+          java.io.InputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws java.io.IOException {
+        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
+      }
+      public static vector_tile.VectorTile.Tile.Value parseFrom(
+          com.google.protobuf.CodedInputStream input)
+          throws java.io.IOException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, input);
+      }
+      public static vector_tile.VectorTile.Tile.Value parseFrom(
+          com.google.protobuf.CodedInputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws java.io.IOException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, input, extensionRegistry);
+      }
+
+      public static Builder newBuilder() {
+        return (Builder) DEFAULT_INSTANCE.createBuilder();
+      }
+      public static Builder newBuilder(vector_tile.VectorTile.Tile.Value prototype) {
+        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
+      }
+
+      /**
+       * <pre>
+       * Variant type encoding
+       * The use of values is described in section 4.1 of the specification
+       * </pre>
+       *
+       * Protobuf type {@code vector_tile.Tile.Value}
+       */
+      public static final class Builder extends
+          com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
+            vector_tile.VectorTile.Tile.Value, Builder> implements
+          // @@protoc_insertion_point(builder_implements:vector_tile.Tile.Value)
+          vector_tile.VectorTile.Tile.ValueOrBuilder {
+        // Construct using vector_tile.VectorTile.Tile.Value.newBuilder()
+        private Builder() {
+          super(DEFAULT_INSTANCE);
+        }
+
+
+        /**
+         * <pre>
+         * Exactly one of these values must be present in a valid message
+         * </pre>
+         *
+         * <code>optional string string_value = 1;</code>
+         * @return Whether the stringValue field is set.
+         */
+        @java.lang.Override
+        public boolean hasStringValue() {
+          return instance.hasStringValue();
+        }
+        /**
+         * <pre>
+         * Exactly one of these values must be present in a valid message
+         * </pre>
+         *
+         * <code>optional string string_value = 1;</code>
+         * @return The stringValue.
+         */
+        @java.lang.Override
+        public java.lang.String getStringValue() {
+          return instance.getStringValue();
+        }
+        /**
+         * <pre>
+         * Exactly one of these values must be present in a valid message
+         * </pre>
+         *
+         * <code>optional string string_value = 1;</code>
+         * @return The bytes for stringValue.
+         */
+        @java.lang.Override
+        public com.google.protobuf.ByteString
+            getStringValueBytes() {
+          return instance.getStringValueBytes();
+        }
+        /**
+         * <pre>
+         * Exactly one of these values must be present in a valid message
+         * </pre>
+         *
+         * <code>optional string string_value = 1;</code>
+         * @param value The stringValue to set.
+         * @return This builder for chaining.
+         */
+        public Builder setStringValue(
+            java.lang.String value) {
+          copyOnWrite();
+          instance.setStringValue(value);
+          return this;
+        }
+        /**
+         * <pre>
+         * Exactly one of these values must be present in a valid message
+         * </pre>
+         *
+         * <code>optional string string_value = 1;</code>
+         * @return This builder for chaining.
+         */
+        public Builder clearStringValue() {
+          copyOnWrite();
+          instance.clearStringValue();
+          return this;
+        }
+        /**
+         * <pre>
+         * Exactly one of these values must be present in a valid message
+         * </pre>
+         *
+         * <code>optional string string_value = 1;</code>
+         * @param value The bytes for stringValue to set.
+         * @return This builder for chaining.
+         */
+        public Builder setStringValueBytes(
+            com.google.protobuf.ByteString value) {
+          copyOnWrite();
+          instance.setStringValueBytes(value);
+          return this;
+        }
+
+        /**
+         * <code>optional float float_value = 2;</code>
+         * @return Whether the floatValue field is set.
+         */
+        @java.lang.Override
+        public boolean hasFloatValue() {
+          return instance.hasFloatValue();
+        }
+        /**
+         * <code>optional float float_value = 2;</code>
+         * @return The floatValue.
+         */
+        @java.lang.Override
+        public float getFloatValue() {
+          return instance.getFloatValue();
+        }
+        /**
+         * <code>optional float float_value = 2;</code>
+         * @param value The floatValue to set.
+         * @return This builder for chaining.
+         */
+        public Builder setFloatValue(float value) {
+          copyOnWrite();
+          instance.setFloatValue(value);
+          return this;
+        }
+        /**
+         * <code>optional float float_value = 2;</code>
+         * @return This builder for chaining.
+         */
+        public Builder clearFloatValue() {
+          copyOnWrite();
+          instance.clearFloatValue();
+          return this;
+        }
+
+        /**
+         * <code>optional double double_value = 3;</code>
+         * @return Whether the doubleValue field is set.
+         */
+        @java.lang.Override
+        public boolean hasDoubleValue() {
+          return instance.hasDoubleValue();
+        }
+        /**
+         * <code>optional double double_value = 3;</code>
+         * @return The doubleValue.
+         */
+        @java.lang.Override
+        public double getDoubleValue() {
+          return instance.getDoubleValue();
+        }
+        /**
+         * <code>optional double double_value = 3;</code>
+         * @param value The doubleValue to set.
+         * @return This builder for chaining.
+         */
+        public Builder setDoubleValue(double value) {
+          copyOnWrite();
+          instance.setDoubleValue(value);
+          return this;
+        }
+        /**
+         * <code>optional double double_value = 3;</code>
+         * @return This builder for chaining.
+         */
+        public Builder clearDoubleValue() {
+          copyOnWrite();
+          instance.clearDoubleValue();
+          return this;
+        }
+
+        /**
+         * <code>optional int64 int_value = 4;</code>
+         * @return Whether the intValue field is set.
+         */
+        @java.lang.Override
+        public boolean hasIntValue() {
+          return instance.hasIntValue();
+        }
+        /**
+         * <code>optional int64 int_value = 4;</code>
+         * @return The intValue.
+         */
+        @java.lang.Override
+        public long getIntValue() {
+          return instance.getIntValue();
+        }
+        /**
+         * <code>optional int64 int_value = 4;</code>
+         * @param value The intValue to set.
+         * @return This builder for chaining.
+         */
+        public Builder setIntValue(long value) {
+          copyOnWrite();
+          instance.setIntValue(value);
+          return this;
+        }
+        /**
+         * <code>optional int64 int_value = 4;</code>
+         * @return This builder for chaining.
+         */
+        public Builder clearIntValue() {
+          copyOnWrite();
+          instance.clearIntValue();
+          return this;
+        }
+
+        /**
+         * <code>optional uint64 uint_value = 5;</code>
+         * @return Whether the uintValue field is set.
+         */
+        @java.lang.Override
+        public boolean hasUintValue() {
+          return instance.hasUintValue();
+        }
+        /**
+         * <code>optional uint64 uint_value = 5;</code>
+         * @return The uintValue.
+         */
+        @java.lang.Override
+        public long getUintValue() {
+          return instance.getUintValue();
+        }
+        /**
+         * <code>optional uint64 uint_value = 5;</code>
+         * @param value The uintValue to set.
+         * @return This builder for chaining.
+         */
+        public Builder setUintValue(long value) {
+          copyOnWrite();
+          instance.setUintValue(value);
+          return this;
+        }
+        /**
+         * <code>optional uint64 uint_value = 5;</code>
+         * @return This builder for chaining.
+         */
+        public Builder clearUintValue() {
+          copyOnWrite();
+          instance.clearUintValue();
+          return this;
+        }
+
+        /**
+         * <code>optional sint64 sint_value = 6;</code>
+         * @return Whether the sintValue field is set.
+         */
+        @java.lang.Override
+        public boolean hasSintValue() {
+          return instance.hasSintValue();
+        }
+        /**
+         * <code>optional sint64 sint_value = 6;</code>
+         * @return The sintValue.
+         */
+        @java.lang.Override
+        public long getSintValue() {
+          return instance.getSintValue();
+        }
+        /**
+         * <code>optional sint64 sint_value = 6;</code>
+         * @param value The sintValue to set.
+         * @return This builder for chaining.
+         */
+        public Builder setSintValue(long value) {
+          copyOnWrite();
+          instance.setSintValue(value);
+          return this;
+        }
+        /**
+         * <code>optional sint64 sint_value = 6;</code>
+         * @return This builder for chaining.
+         */
+        public Builder clearSintValue() {
+          copyOnWrite();
+          instance.clearSintValue();
+          return this;
+        }
+
+        /**
+         * <code>optional bool bool_value = 7;</code>
+         * @return Whether the boolValue field is set.
+         */
+        @java.lang.Override
+        public boolean hasBoolValue() {
+          return instance.hasBoolValue();
+        }
+        /**
+         * <code>optional bool bool_value = 7;</code>
+         * @return The boolValue.
+         */
+        @java.lang.Override
+        public boolean getBoolValue() {
+          return instance.getBoolValue();
+        }
+        /**
+         * <code>optional bool bool_value = 7;</code>
+         * @param value The boolValue to set.
+         * @return This builder for chaining.
+         */
+        public Builder setBoolValue(boolean value) {
+          copyOnWrite();
+          instance.setBoolValue(value);
+          return this;
+        }
+        /**
+         * <code>optional bool bool_value = 7;</code>
+         * @return This builder for chaining.
+         */
+        public Builder clearBoolValue() {
+          copyOnWrite();
+          instance.clearBoolValue();
+          return this;
+        }
+
+        // @@protoc_insertion_point(builder_scope:vector_tile.Tile.Value)
+      }
+      private byte memoizedIsInitialized = 2;
+      @java.lang.Override
+      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
+      protected final java.lang.Object dynamicMethod(
+          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
+          java.lang.Object arg0, java.lang.Object arg1) {
+        switch (method) {
+          case NEW_MUTABLE_INSTANCE: {
+            return new vector_tile.VectorTile.Tile.Value();
+          }
+          case NEW_BUILDER: {
+            return new Builder();
+          }
+          case BUILD_MESSAGE_INFO: {
+              java.lang.Object[] objects = new java.lang.Object[] {
+                "bitField0_",
+                "stringValue_",
+                "floatValue_",
+                "doubleValue_",
+                "intValue_",
+                "uintValue_",
+                "sintValue_",
+                "boolValue_",
+              };
+              java.lang.String info =
+                  "\u0001\u0007\u0000\u0001\u0001\u0007\u0007\u0000\u0000\u0000\u0001\u1008\u0000\u0002" +
+                  "\u1001\u0001\u0003\u1000\u0002\u0004\u1002\u0003\u0005\u1003\u0004\u0006\u1010\u0005" +
+                  "\u0007\u1007\u0006";
+              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
+          }
+          // fall through
+          case GET_DEFAULT_INSTANCE: {
+            return DEFAULT_INSTANCE;
+          }
+          case GET_PARSER: {
+            com.google.protobuf.Parser<vector_tile.VectorTile.Tile.Value> parser = PARSER;
+            if (parser == null) {
+              synchronized (vector_tile.VectorTile.Tile.Value.class) {
+                parser = PARSER;
+                if (parser == null) {
+                  parser =
+                      new DefaultInstanceBasedParser<vector_tile.VectorTile.Tile.Value>(
+                          DEFAULT_INSTANCE);
+                  PARSER = parser;
+                }
+              }
+            }
+            return parser;
+        }
+        case GET_MEMOIZED_IS_INITIALIZED: {
+          return memoizedIsInitialized;
+        }
+        case SET_MEMOIZED_IS_INITIALIZED: {
+          memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
+          return null;
+        }
+        }
+        throw new UnsupportedOperationException();
+      }
+
+
+      // @@protoc_insertion_point(class_scope:vector_tile.Tile.Value)
+      private static final vector_tile.VectorTile.Tile.Value DEFAULT_INSTANCE;
+      static {
+        Value defaultInstance = new Value();
+        // New instances are implicitly immutable so no need to make
+        // immutable.
+        DEFAULT_INSTANCE = defaultInstance;
+        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
+          Value.class, defaultInstance);
+      }
+
+      public static vector_tile.VectorTile.Tile.Value getDefaultInstance() {
+        return DEFAULT_INSTANCE;
+      }
+
+      private static volatile com.google.protobuf.Parser<Value> PARSER;
+
+      public static com.google.protobuf.Parser<Value> parser() {
+        return DEFAULT_INSTANCE.getParserForType();
+      }
+    }
+
+    public interface FeatureOrBuilder extends
+        // @@protoc_insertion_point(interface_extends:vector_tile.Tile.Feature)
+        com.google.protobuf.MessageLiteOrBuilder {
+
+      /**
+       * <code>optional uint64 id = 1 [default = 0];</code>
+       * @return Whether the id field is set.
+       */
+      boolean hasId();
+      /**
+       * <code>optional uint64 id = 1 [default = 0];</code>
+       * @return The id.
+       */
+      long getId();
+
+      /**
+       * <pre>
+       * Tags of this feature are encoded as repeated pairs of
+       * integers.
+       * A detailed description of tags is located in sections
+       * 4.2 and 4.4 of the specification
+       * </pre>
+       *
+       * <code>repeated uint32 tags = 2 [packed = true];</code>
+       * @return A list containing the tags.
+       */
+      java.util.List<java.lang.Integer> getTagsList();
+      /**
+       * <pre>
+       * Tags of this feature are encoded as repeated pairs of
+       * integers.
+       * A detailed description of tags is located in sections
+       * 4.2 and 4.4 of the specification
+       * </pre>
+       *
+       * <code>repeated uint32 tags = 2 [packed = true];</code>
+       * @return The count of tags.
+       */
+      int getTagsCount();
+      /**
+       * <pre>
+       * Tags of this feature are encoded as repeated pairs of
+       * integers.
+       * A detailed description of tags is located in sections
+       * 4.2 and 4.4 of the specification
+       * </pre>
+       *
+       * <code>repeated uint32 tags = 2 [packed = true];</code>
+       * @param index The index of the element to return.
+       * @return The tags at the given index.
+       */
+      int getTags(int index);
+
+      /**
+       * <pre>
+       * The type of geometry stored in this feature.
+       * </pre>
+       *
+       * <code>optional .vector_tile.Tile.GeomType type = 3 [default = UNKNOWN];</code>
+       * @return Whether the type field is set.
+       */
+      boolean hasType();
+      /**
+       * <pre>
+       * The type of geometry stored in this feature.
+       * </pre>
+       *
+       * <code>optional .vector_tile.Tile.GeomType type = 3 [default = UNKNOWN];</code>
+       * @return The type.
+       */
+      vector_tile.VectorTile.Tile.GeomType getType();
+
+      /**
+       * <pre>
+       * Contains a stream of commands and parameters (vertices).
+       * A detailed description on geometry encoding is located in 
+       * section 4.3 of the specification.
+       * </pre>
+       *
+       * <code>repeated uint32 geometry = 4 [packed = true];</code>
+       * @return A list containing the geometry.
+       */
+      java.util.List<java.lang.Integer> getGeometryList();
+      /**
+       * <pre>
+       * Contains a stream of commands and parameters (vertices).
+       * A detailed description on geometry encoding is located in 
+       * section 4.3 of the specification.
+       * </pre>
+       *
+       * <code>repeated uint32 geometry = 4 [packed = true];</code>
+       * @return The count of geometry.
+       */
+      int getGeometryCount();
+      /**
+       * <pre>
+       * Contains a stream of commands and parameters (vertices).
+       * A detailed description on geometry encoding is located in 
+       * section 4.3 of the specification.
+       * </pre>
+       *
+       * <code>repeated uint32 geometry = 4 [packed = true];</code>
+       * @param index The index of the element to return.
+       * @return The geometry at the given index.
+       */
+      int getGeometry(int index);
+    }
+    /**
+     * <pre>
+     * Features are described in section 4.2 of the specification
+     * </pre>
+     *
+     * Protobuf type {@code vector_tile.Tile.Feature}
+     */
+    public  static final class Feature extends
+        com.google.protobuf.GeneratedMessageLite<
+            Feature, Feature.Builder> implements
+        // @@protoc_insertion_point(message_implements:vector_tile.Tile.Feature)
+        FeatureOrBuilder {
+      private Feature() {
+        tags_ = emptyIntList();
+        geometry_ = emptyIntList();
+      }
+      private int bitField0_;
+      public static final int ID_FIELD_NUMBER = 1;
+      private long id_;
+      /**
+       * <code>optional uint64 id = 1 [default = 0];</code>
+       * @return Whether the id field is set.
+       */
+      @java.lang.Override
+      public boolean hasId() {
+        return ((bitField0_ & 0x00000001) != 0);
+      }
+      /**
+       * <code>optional uint64 id = 1 [default = 0];</code>
+       * @return The id.
+       */
+      @java.lang.Override
+      public long getId() {
+        return id_;
+      }
+      /**
+       * <code>optional uint64 id = 1 [default = 0];</code>
+       * @param value The id to set.
+       */
+      private void setId(long value) {
+        bitField0_ |= 0x00000001;
+        id_ = value;
+      }
+      /**
+       * <code>optional uint64 id = 1 [default = 0];</code>
+       */
+      private void clearId() {
+        bitField0_ = (bitField0_ & ~0x00000001);
+        id_ = 0L;
+      }
+
+      public static final int TAGS_FIELD_NUMBER = 2;
+      private com.google.protobuf.Internal.IntList tags_;
+      /**
+       * <pre>
+       * Tags of this feature are encoded as repeated pairs of
+       * integers.
+       * A detailed description of tags is located in sections
+       * 4.2 and 4.4 of the specification
+       * </pre>
+       *
+       * <code>repeated uint32 tags = 2 [packed = true];</code>
+       * @return A list containing the tags.
+       */
+      @java.lang.Override
+      public java.util.List<java.lang.Integer>
+          getTagsList() {
+        return tags_;
+      }
+      /**
+       * <pre>
+       * Tags of this feature are encoded as repeated pairs of
+       * integers.
+       * A detailed description of tags is located in sections
+       * 4.2 and 4.4 of the specification
+       * </pre>
+       *
+       * <code>repeated uint32 tags = 2 [packed = true];</code>
+       * @return The count of tags.
+       */
+      @java.lang.Override
+      public int getTagsCount() {
+        return tags_.size();
+      }
+      /**
+       * <pre>
+       * Tags of this feature are encoded as repeated pairs of
+       * integers.
+       * A detailed description of tags is located in sections
+       * 4.2 and 4.4 of the specification
+       * </pre>
+       *
+       * <code>repeated uint32 tags = 2 [packed = true];</code>
+       * @param index The index of the element to return.
+       * @return The tags at the given index.
+       */
+      @java.lang.Override
+      public int getTags(int index) {
+        return tags_.getInt(index);
+      }
+      private int tagsMemoizedSerializedSize = -1;
+      private void ensureTagsIsMutable() {
+        com.google.protobuf.Internal.IntList tmp = tags_;
+        if (!tmp.isModifiable()) {
+          tags_ =
+              com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
+         }
+      }
+      /**
+       * <pre>
+       * Tags of this feature are encoded as repeated pairs of
+       * integers.
+       * A detailed description of tags is located in sections
+       * 4.2 and 4.4 of the specification
+       * </pre>
+       *
+       * <code>repeated uint32 tags = 2 [packed = true];</code>
+       * @param index The index to set the value at.
+       * @param value The tags to set.
+       */
+      private void setTags(
+          int index, int value) {
+        ensureTagsIsMutable();
+        tags_.setInt(index, value);
+      }
+      /**
+       * <pre>
+       * Tags of this feature are encoded as repeated pairs of
+       * integers.
+       * A detailed description of tags is located in sections
+       * 4.2 and 4.4 of the specification
+       * </pre>
+       *
+       * <code>repeated uint32 tags = 2 [packed = true];</code>
+       * @param value The tags to add.
+       */
+      private void addTags(int value) {
+        ensureTagsIsMutable();
+        tags_.addInt(value);
+      }
+      /**
+       * <pre>
+       * Tags of this feature are encoded as repeated pairs of
+       * integers.
+       * A detailed description of tags is located in sections
+       * 4.2 and 4.4 of the specification
+       * </pre>
+       *
+       * <code>repeated uint32 tags = 2 [packed = true];</code>
+       * @param values The tags to add.
+       */
+      private void addAllTags(
+          java.lang.Iterable<? extends java.lang.Integer> values) {
+        ensureTagsIsMutable();
+        com.google.protobuf.AbstractMessageLite.addAll(
+            values, tags_);
+      }
+      /**
+       * <pre>
+       * Tags of this feature are encoded as repeated pairs of
+       * integers.
+       * A detailed description of tags is located in sections
+       * 4.2 and 4.4 of the specification
+       * </pre>
+       *
+       * <code>repeated uint32 tags = 2 [packed = true];</code>
+       */
+      private void clearTags() {
+        tags_ = emptyIntList();
+      }
+
+      public static final int TYPE_FIELD_NUMBER = 3;
+      private int type_;
+      /**
+       * <pre>
+       * The type of geometry stored in this feature.
+       * </pre>
+       *
+       * <code>optional .vector_tile.Tile.GeomType type = 3 [default = UNKNOWN];</code>
+       * @return Whether the type field is set.
+       */
+      @java.lang.Override
+      public boolean hasType() {
+        return ((bitField0_ & 0x00000002) != 0);
+      }
+      /**
+       * <pre>
+       * The type of geometry stored in this feature.
+       * </pre>
+       *
+       * <code>optional .vector_tile.Tile.GeomType type = 3 [default = UNKNOWN];</code>
+       * @return The type.
+       */
+      @java.lang.Override
+      public vector_tile.VectorTile.Tile.GeomType getType() {
+        vector_tile.VectorTile.Tile.GeomType result = vector_tile.VectorTile.Tile.GeomType.forNumber(type_);
+        return result == null ? vector_tile.VectorTile.Tile.GeomType.UNKNOWN : result;
+      }
+      /**
+       * <pre>
+       * The type of geometry stored in this feature.
+       * </pre>
+       *
+       * <code>optional .vector_tile.Tile.GeomType type = 3 [default = UNKNOWN];</code>
+       * @param value The type to set.
+       */
+      private void setType(vector_tile.VectorTile.Tile.GeomType value) {
+        type_ = value.getNumber();
+        bitField0_ |= 0x00000002;
+      }
+      /**
+       * <pre>
+       * The type of geometry stored in this feature.
+       * </pre>
+       *
+       * <code>optional .vector_tile.Tile.GeomType type = 3 [default = UNKNOWN];</code>
+       */
+      private void clearType() {
+        bitField0_ = (bitField0_ & ~0x00000002);
+        type_ = 0;
+      }
+
+      public static final int GEOMETRY_FIELD_NUMBER = 4;
+      private com.google.protobuf.Internal.IntList geometry_;
+      /**
+       * <pre>
+       * Contains a stream of commands and parameters (vertices).
+       * A detailed description on geometry encoding is located in 
+       * section 4.3 of the specification.
+       * </pre>
+       *
+       * <code>repeated uint32 geometry = 4 [packed = true];</code>
+       * @return A list containing the geometry.
+       */
+      @java.lang.Override
+      public java.util.List<java.lang.Integer>
+          getGeometryList() {
+        return geometry_;
+      }
+      /**
+       * <pre>
+       * Contains a stream of commands and parameters (vertices).
+       * A detailed description on geometry encoding is located in 
+       * section 4.3 of the specification.
+       * </pre>
+       *
+       * <code>repeated uint32 geometry = 4 [packed = true];</code>
+       * @return The count of geometry.
+       */
+      @java.lang.Override
+      public int getGeometryCount() {
+        return geometry_.size();
+      }
+      /**
+       * <pre>
+       * Contains a stream of commands and parameters (vertices).
+       * A detailed description on geometry encoding is located in 
+       * section 4.3 of the specification.
+       * </pre>
+       *
+       * <code>repeated uint32 geometry = 4 [packed = true];</code>
+       * @param index The index of the element to return.
+       * @return The geometry at the given index.
+       */
+      @java.lang.Override
+      public int getGeometry(int index) {
+        return geometry_.getInt(index);
+      }
+      private int geometryMemoizedSerializedSize = -1;
+      private void ensureGeometryIsMutable() {
+        com.google.protobuf.Internal.IntList tmp = geometry_;
+        if (!tmp.isModifiable()) {
+          geometry_ =
+              com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
+         }
+      }
+      /**
+       * <pre>
+       * Contains a stream of commands and parameters (vertices).
+       * A detailed description on geometry encoding is located in 
+       * section 4.3 of the specification.
+       * </pre>
+       *
+       * <code>repeated uint32 geometry = 4 [packed = true];</code>
+       * @param index The index to set the value at.
+       * @param value The geometry to set.
+       */
+      private void setGeometry(
+          int index, int value) {
+        ensureGeometryIsMutable();
+        geometry_.setInt(index, value);
+      }
+      /**
+       * <pre>
+       * Contains a stream of commands and parameters (vertices).
+       * A detailed description on geometry encoding is located in 
+       * section 4.3 of the specification.
+       * </pre>
+       *
+       * <code>repeated uint32 geometry = 4 [packed = true];</code>
+       * @param value The geometry to add.
+       */
+      private void addGeometry(int value) {
+        ensureGeometryIsMutable();
+        geometry_.addInt(value);
+      }
+      /**
+       * <pre>
+       * Contains a stream of commands and parameters (vertices).
+       * A detailed description on geometry encoding is located in 
+       * section 4.3 of the specification.
+       * </pre>
+       *
+       * <code>repeated uint32 geometry = 4 [packed = true];</code>
+       * @param values The geometry to add.
+       */
+      private void addAllGeometry(
+          java.lang.Iterable<? extends java.lang.Integer> values) {
+        ensureGeometryIsMutable();
+        com.google.protobuf.AbstractMessageLite.addAll(
+            values, geometry_);
+      }
+      /**
+       * <pre>
+       * Contains a stream of commands and parameters (vertices).
+       * A detailed description on geometry encoding is located in 
+       * section 4.3 of the specification.
+       * </pre>
+       *
+       * <code>repeated uint32 geometry = 4 [packed = true];</code>
+       */
+      private void clearGeometry() {
+        geometry_ = emptyIntList();
+      }
+
+      public static vector_tile.VectorTile.Tile.Feature parseFrom(
+          java.nio.ByteBuffer data)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, data);
+      }
+      public static vector_tile.VectorTile.Tile.Feature parseFrom(
+          java.nio.ByteBuffer data,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, data, extensionRegistry);
+      }
+      public static vector_tile.VectorTile.Tile.Feature parseFrom(
+          com.google.protobuf.ByteString data)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, data);
+      }
+      public static vector_tile.VectorTile.Tile.Feature parseFrom(
+          com.google.protobuf.ByteString data,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, data, extensionRegistry);
+      }
+      public static vector_tile.VectorTile.Tile.Feature parseFrom(byte[] data)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, data);
+      }
+      public static vector_tile.VectorTile.Tile.Feature parseFrom(
+          byte[] data,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, data, extensionRegistry);
+      }
+      public static vector_tile.VectorTile.Tile.Feature parseFrom(java.io.InputStream input)
+          throws java.io.IOException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, input);
+      }
+      public static vector_tile.VectorTile.Tile.Feature parseFrom(
+          java.io.InputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws java.io.IOException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, input, extensionRegistry);
+      }
+      public static vector_tile.VectorTile.Tile.Feature parseDelimitedFrom(java.io.InputStream input)
+          throws java.io.IOException {
+        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
+      }
+      public static vector_tile.VectorTile.Tile.Feature parseDelimitedFrom(
+          java.io.InputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws java.io.IOException {
+        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
+      }
+      public static vector_tile.VectorTile.Tile.Feature parseFrom(
+          com.google.protobuf.CodedInputStream input)
+          throws java.io.IOException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, input);
+      }
+      public static vector_tile.VectorTile.Tile.Feature parseFrom(
+          com.google.protobuf.CodedInputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws java.io.IOException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, input, extensionRegistry);
+      }
+
+      public static Builder newBuilder() {
+        return (Builder) DEFAULT_INSTANCE.createBuilder();
+      }
+      public static Builder newBuilder(vector_tile.VectorTile.Tile.Feature prototype) {
+        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
+      }
+
+      /**
+       * <pre>
+       * Features are described in section 4.2 of the specification
+       * </pre>
+       *
+       * Protobuf type {@code vector_tile.Tile.Feature}
+       */
+      public static final class Builder extends
+          com.google.protobuf.GeneratedMessageLite.Builder<
+            vector_tile.VectorTile.Tile.Feature, Builder> implements
+          // @@protoc_insertion_point(builder_implements:vector_tile.Tile.Feature)
+          vector_tile.VectorTile.Tile.FeatureOrBuilder {
+        // Construct using vector_tile.VectorTile.Tile.Feature.newBuilder()
+        private Builder() {
+          super(DEFAULT_INSTANCE);
+        }
+
+
+        /**
+         * <code>optional uint64 id = 1 [default = 0];</code>
+         * @return Whether the id field is set.
+         */
+        @java.lang.Override
+        public boolean hasId() {
+          return instance.hasId();
+        }
+        /**
+         * <code>optional uint64 id = 1 [default = 0];</code>
+         * @return The id.
+         */
+        @java.lang.Override
+        public long getId() {
+          return instance.getId();
+        }
+        /**
+         * <code>optional uint64 id = 1 [default = 0];</code>
+         * @param value The id to set.
+         * @return This builder for chaining.
+         */
+        public Builder setId(long value) {
+          copyOnWrite();
+          instance.setId(value);
+          return this;
+        }
+        /**
+         * <code>optional uint64 id = 1 [default = 0];</code>
+         * @return This builder for chaining.
+         */
+        public Builder clearId() {
+          copyOnWrite();
+          instance.clearId();
+          return this;
+        }
+
+        /**
+         * <pre>
+         * Tags of this feature are encoded as repeated pairs of
+         * integers.
+         * A detailed description of tags is located in sections
+         * 4.2 and 4.4 of the specification
+         * </pre>
+         *
+         * <code>repeated uint32 tags = 2 [packed = true];</code>
+         * @return A list containing the tags.
+         */
+        @java.lang.Override
+        public java.util.List<java.lang.Integer>
+            getTagsList() {
+          return java.util.Collections.unmodifiableList(
+              instance.getTagsList());
+        }
+        /**
+         * <pre>
+         * Tags of this feature are encoded as repeated pairs of
+         * integers.
+         * A detailed description of tags is located in sections
+         * 4.2 and 4.4 of the specification
+         * </pre>
+         *
+         * <code>repeated uint32 tags = 2 [packed = true];</code>
+         * @return The count of tags.
+         */
+        @java.lang.Override
+        public int getTagsCount() {
+          return instance.getTagsCount();
+        }
+        /**
+         * <pre>
+         * Tags of this feature are encoded as repeated pairs of
+         * integers.
+         * A detailed description of tags is located in sections
+         * 4.2 and 4.4 of the specification
+         * </pre>
+         *
+         * <code>repeated uint32 tags = 2 [packed = true];</code>
+         * @param index The index of the element to return.
+         * @return The tags at the given index.
+         */
+        @java.lang.Override
+        public int getTags(int index) {
+          return instance.getTags(index);
+        }
+        /**
+         * <pre>
+         * Tags of this feature are encoded as repeated pairs of
+         * integers.
+         * A detailed description of tags is located in sections
+         * 4.2 and 4.4 of the specification
+         * </pre>
+         *
+         * <code>repeated uint32 tags = 2 [packed = true];</code>
+         * @param value The tags to set.
+         * @return This builder for chaining.
+         */
+        public Builder setTags(
+            int index, int value) {
+          copyOnWrite();
+          instance.setTags(index, value);
+          return this;
+        }
+        /**
+         * <pre>
+         * Tags of this feature are encoded as repeated pairs of
+         * integers.
+         * A detailed description of tags is located in sections
+         * 4.2 and 4.4 of the specification
+         * </pre>
+         *
+         * <code>repeated uint32 tags = 2 [packed = true];</code>
+         * @param value The tags to add.
+         * @return This builder for chaining.
+         */
+        public Builder addTags(int value) {
+          copyOnWrite();
+          instance.addTags(value);
+          return this;
+        }
+        /**
+         * <pre>
+         * Tags of this feature are encoded as repeated pairs of
+         * integers.
+         * A detailed description of tags is located in sections
+         * 4.2 and 4.4 of the specification
+         * </pre>
+         *
+         * <code>repeated uint32 tags = 2 [packed = true];</code>
+         * @param values The tags to add.
+         * @return This builder for chaining.
+         */
+        public Builder addAllTags(
+            java.lang.Iterable<? extends java.lang.Integer> values) {
+          copyOnWrite();
+          instance.addAllTags(values);
+          return this;
+        }
+        /**
+         * <pre>
+         * Tags of this feature are encoded as repeated pairs of
+         * integers.
+         * A detailed description of tags is located in sections
+         * 4.2 and 4.4 of the specification
+         * </pre>
+         *
+         * <code>repeated uint32 tags = 2 [packed = true];</code>
+         * @return This builder for chaining.
+         */
+        public Builder clearTags() {
+          copyOnWrite();
+          instance.clearTags();
+          return this;
+        }
+
+        /**
+         * <pre>
+         * The type of geometry stored in this feature.
+         * </pre>
+         *
+         * <code>optional .vector_tile.Tile.GeomType type = 3 [default = UNKNOWN];</code>
+         * @return Whether the type field is set.
+         */
+        @java.lang.Override
+        public boolean hasType() {
+          return instance.hasType();
+        }
+        /**
+         * <pre>
+         * The type of geometry stored in this feature.
+         * </pre>
+         *
+         * <code>optional .vector_tile.Tile.GeomType type = 3 [default = UNKNOWN];</code>
+         * @return The type.
+         */
+        @java.lang.Override
+        public vector_tile.VectorTile.Tile.GeomType getType() {
+          return instance.getType();
+        }
+        /**
+         * <pre>
+         * The type of geometry stored in this feature.
+         * </pre>
+         *
+         * <code>optional .vector_tile.Tile.GeomType type = 3 [default = UNKNOWN];</code>
+         * @param value The enum numeric value on the wire for type to set.
+         * @return This builder for chaining.
+         */
+        public Builder setType(vector_tile.VectorTile.Tile.GeomType value) {
+          copyOnWrite();
+          instance.setType(value);
+          return this;
+        }
+        /**
+         * <pre>
+         * The type of geometry stored in this feature.
+         * </pre>
+         *
+         * <code>optional .vector_tile.Tile.GeomType type = 3 [default = UNKNOWN];</code>
+         * @return This builder for chaining.
+         */
+        public Builder clearType() {
+          copyOnWrite();
+          instance.clearType();
+          return this;
+        }
+
+        /**
+         * <pre>
+         * Contains a stream of commands and parameters (vertices).
+         * A detailed description on geometry encoding is located in 
+         * section 4.3 of the specification.
+         * </pre>
+         *
+         * <code>repeated uint32 geometry = 4 [packed = true];</code>
+         * @return A list containing the geometry.
+         */
+        @java.lang.Override
+        public java.util.List<java.lang.Integer>
+            getGeometryList() {
+          return java.util.Collections.unmodifiableList(
+              instance.getGeometryList());
+        }
+        /**
+         * <pre>
+         * Contains a stream of commands and parameters (vertices).
+         * A detailed description on geometry encoding is located in 
+         * section 4.3 of the specification.
+         * </pre>
+         *
+         * <code>repeated uint32 geometry = 4 [packed = true];</code>
+         * @return The count of geometry.
+         */
+        @java.lang.Override
+        public int getGeometryCount() {
+          return instance.getGeometryCount();
+        }
+        /**
+         * <pre>
+         * Contains a stream of commands and parameters (vertices).
+         * A detailed description on geometry encoding is located in 
+         * section 4.3 of the specification.
+         * </pre>
+         *
+         * <code>repeated uint32 geometry = 4 [packed = true];</code>
+         * @param index The index of the element to return.
+         * @return The geometry at the given index.
+         */
+        @java.lang.Override
+        public int getGeometry(int index) {
+          return instance.getGeometry(index);
+        }
+        /**
+         * <pre>
+         * Contains a stream of commands and parameters (vertices).
+         * A detailed description on geometry encoding is located in 
+         * section 4.3 of the specification.
+         * </pre>
+         *
+         * <code>repeated uint32 geometry = 4 [packed = true];</code>
+         * @param value The geometry to set.
+         * @return This builder for chaining.
+         */
+        public Builder setGeometry(
+            int index, int value) {
+          copyOnWrite();
+          instance.setGeometry(index, value);
+          return this;
+        }
+        /**
+         * <pre>
+         * Contains a stream of commands and parameters (vertices).
+         * A detailed description on geometry encoding is located in 
+         * section 4.3 of the specification.
+         * </pre>
+         *
+         * <code>repeated uint32 geometry = 4 [packed = true];</code>
+         * @param value The geometry to add.
+         * @return This builder for chaining.
+         */
+        public Builder addGeometry(int value) {
+          copyOnWrite();
+          instance.addGeometry(value);
+          return this;
+        }
+        /**
+         * <pre>
+         * Contains a stream of commands and parameters (vertices).
+         * A detailed description on geometry encoding is located in 
+         * section 4.3 of the specification.
+         * </pre>
+         *
+         * <code>repeated uint32 geometry = 4 [packed = true];</code>
+         * @param values The geometry to add.
+         * @return This builder for chaining.
+         */
+        public Builder addAllGeometry(
+            java.lang.Iterable<? extends java.lang.Integer> values) {
+          copyOnWrite();
+          instance.addAllGeometry(values);
+          return this;
+        }
+        /**
+         * <pre>
+         * Contains a stream of commands and parameters (vertices).
+         * A detailed description on geometry encoding is located in 
+         * section 4.3 of the specification.
+         * </pre>
+         *
+         * <code>repeated uint32 geometry = 4 [packed = true];</code>
+         * @return This builder for chaining.
+         */
+        public Builder clearGeometry() {
+          copyOnWrite();
+          instance.clearGeometry();
+          return this;
+        }
+
+        // @@protoc_insertion_point(builder_scope:vector_tile.Tile.Feature)
+      }
+      @java.lang.Override
+      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
+      protected final java.lang.Object dynamicMethod(
+          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
+          java.lang.Object arg0, java.lang.Object arg1) {
+        switch (method) {
+          case NEW_MUTABLE_INSTANCE: {
+            return new vector_tile.VectorTile.Tile.Feature();
+          }
+          case NEW_BUILDER: {
+            return new Builder();
+          }
+          case BUILD_MESSAGE_INFO: {
+              java.lang.Object[] objects = new java.lang.Object[] {
+                "bitField0_",
+                "id_",
+                "tags_",
+                "type_",
+                vector_tile.VectorTile.Tile.GeomType.internalGetVerifier(),
+                "geometry_",
+              };
+              java.lang.String info =
+                  "\u0001\u0004\u0000\u0001\u0001\u0004\u0004\u0000\u0002\u0000\u0001\u1003\u0000\u0002" +
+                  "+\u0003\u100c\u0001\u0004+";
+              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
+          }
+          // fall through
+          case GET_DEFAULT_INSTANCE: {
+            return DEFAULT_INSTANCE;
+          }
+          case GET_PARSER: {
+            com.google.protobuf.Parser<vector_tile.VectorTile.Tile.Feature> parser = PARSER;
+            if (parser == null) {
+              synchronized (vector_tile.VectorTile.Tile.Feature.class) {
+                parser = PARSER;
+                if (parser == null) {
+                  parser =
+                      new DefaultInstanceBasedParser<vector_tile.VectorTile.Tile.Feature>(
+                          DEFAULT_INSTANCE);
+                  PARSER = parser;
+                }
+              }
+            }
+            return parser;
+        }
+        case GET_MEMOIZED_IS_INITIALIZED: {
+          return (byte) 1;
+        }
+        case SET_MEMOIZED_IS_INITIALIZED: {
+          return null;
+        }
+        }
+        throw new UnsupportedOperationException();
+      }
+
+
+      // @@protoc_insertion_point(class_scope:vector_tile.Tile.Feature)
+      private static final vector_tile.VectorTile.Tile.Feature DEFAULT_INSTANCE;
+      static {
+        Feature defaultInstance = new Feature();
+        // New instances are implicitly immutable so no need to make
+        // immutable.
+        DEFAULT_INSTANCE = defaultInstance;
+        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
+          Feature.class, defaultInstance);
+      }
+
+      public static vector_tile.VectorTile.Tile.Feature getDefaultInstance() {
+        return DEFAULT_INSTANCE;
+      }
+
+      private static volatile com.google.protobuf.Parser<Feature> PARSER;
+
+      public static com.google.protobuf.Parser<Feature> parser() {
+        return DEFAULT_INSTANCE.getParserForType();
+      }
+    }
+
+    public interface LayerOrBuilder extends 
+        // @@protoc_insertion_point(interface_extends:vector_tile.Tile.Layer)
+         com.google.protobuf.GeneratedMessageLite.
+              ExtendableMessageOrBuilder<
+                  Layer, Layer.Builder> {
+
+      /**
+       * <pre>
+       * Any compliant implementation must first read the version
+       * number encoded in this message and choose the correct
+       * implementation for this version number before proceeding to
+       * decode other parts of this message.
+       * </pre>
+       *
+       * <code>required uint32 version = 15 [default = 1];</code>
+       * @return Whether the version field is set.
+       */
+      boolean hasVersion();
+      /**
+       * <pre>
+       * Any compliant implementation must first read the version
+       * number encoded in this message and choose the correct
+       * implementation for this version number before proceeding to
+       * decode other parts of this message.
+       * </pre>
+       *
+       * <code>required uint32 version = 15 [default = 1];</code>
+       * @return The version.
+       */
+      int getVersion();
+
+      /**
+       * <code>required string name = 1;</code>
+       * @return Whether the name field is set.
+       */
+      boolean hasName();
+      /**
+       * <code>required string name = 1;</code>
+       * @return The name.
+       */
+      java.lang.String getName();
+      /**
+       * <code>required string name = 1;</code>
+       * @return The bytes for name.
+       */
+      com.google.protobuf.ByteString
+          getNameBytes();
+
+      /**
+       * <pre>
+       * The actual features in this tile.
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+       */
+      java.util.List<vector_tile.VectorTile.Tile.Feature> 
+          getFeaturesList();
+      /**
+       * <pre>
+       * The actual features in this tile.
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+       */
+      vector_tile.VectorTile.Tile.Feature getFeatures(int index);
+      /**
+       * <pre>
+       * The actual features in this tile.
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+       */
+      int getFeaturesCount();
+
+      /**
+       * <pre>
+       * Dictionary encoding for keys
+       * </pre>
+       *
+       * <code>repeated string keys = 3;</code>
+       * @return A list containing the keys.
+       */
+      java.util.List<java.lang.String>
+          getKeysList();
+      /**
+       * <pre>
+       * Dictionary encoding for keys
+       * </pre>
+       *
+       * <code>repeated string keys = 3;</code>
+       * @return The count of keys.
+       */
+      int getKeysCount();
+      /**
+       * <pre>
+       * Dictionary encoding for keys
+       * </pre>
+       *
+       * <code>repeated string keys = 3;</code>
+       * @param index The index of the element to return.
+       * @return The keys at the given index.
+       */
+      java.lang.String getKeys(int index);
+      /**
+       * <pre>
+       * Dictionary encoding for keys
+       * </pre>
+       *
+       * <code>repeated string keys = 3;</code>
+       * @param index The index of the element to return.
+       * @return The keys at the given index.
+       */
+      com.google.protobuf.ByteString
+          getKeysBytes(int index);
+
+      /**
+       * <pre>
+       * Dictionary encoding for values
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+       */
+      java.util.List<vector_tile.VectorTile.Tile.Value> 
+          getValuesList();
+      /**
+       * <pre>
+       * Dictionary encoding for values
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+       */
+      vector_tile.VectorTile.Tile.Value getValues(int index);
+      /**
+       * <pre>
+       * Dictionary encoding for values
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+       */
+      int getValuesCount();
+
+      /**
+       * <pre>
+       * Although this is an "optional" field it is required by the specification.
+       * See https://github.com/mapbox/vector-tile-spec/issues/47
+       * </pre>
+       *
+       * <code>optional uint32 extent = 5 [default = 4096];</code>
+       * @return Whether the extent field is set.
+       */
+      boolean hasExtent();
+      /**
+       * <pre>
+       * Although this is an "optional" field it is required by the specification.
+       * See https://github.com/mapbox/vector-tile-spec/issues/47
+       * </pre>
+       *
+       * <code>optional uint32 extent = 5 [default = 4096];</code>
+       * @return The extent.
+       */
+      int getExtent();
+    }
+    /**
+     * <pre>
+     * Layers are described in section 4.1 of the specification
+     * </pre>
+     *
+     * Protobuf type {@code vector_tile.Tile.Layer}
+     */
+    public  static final class Layer extends
+        com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
+          Layer, Layer.Builder> implements
+        // @@protoc_insertion_point(message_implements:vector_tile.Tile.Layer)
+        LayerOrBuilder {
+      private Layer() {
+        version_ = 1;
+        name_ = "";
+        features_ = emptyProtobufList();
+        keys_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
+        values_ = emptyProtobufList();
+        extent_ = 4096;
+      }
+      private int bitField0_;
+      public static final int VERSION_FIELD_NUMBER = 15;
+      private int version_;
+      /**
+       * <pre>
+       * Any compliant implementation must first read the version
+       * number encoded in this message and choose the correct
+       * implementation for this version number before proceeding to
+       * decode other parts of this message.
+       * </pre>
+       *
+       * <code>required uint32 version = 15 [default = 1];</code>
+       * @return Whether the version field is set.
+       */
+      @java.lang.Override
+      public boolean hasVersion() {
+        return ((bitField0_ & 0x00000001) != 0);
+      }
+      /**
+       * <pre>
+       * Any compliant implementation must first read the version
+       * number encoded in this message and choose the correct
+       * implementation for this version number before proceeding to
+       * decode other parts of this message.
+       * </pre>
+       *
+       * <code>required uint32 version = 15 [default = 1];</code>
+       * @return The version.
+       */
+      @java.lang.Override
+      public int getVersion() {
+        return version_;
+      }
+      /**
+       * <pre>
+       * Any compliant implementation must first read the version
+       * number encoded in this message and choose the correct
+       * implementation for this version number before proceeding to
+       * decode other parts of this message.
+       * </pre>
+       *
+       * <code>required uint32 version = 15 [default = 1];</code>
+       * @param value The version to set.
+       */
+      private void setVersion(int value) {
+        bitField0_ |= 0x00000001;
+        version_ = value;
+      }
+      /**
+       * <pre>
+       * Any compliant implementation must first read the version
+       * number encoded in this message and choose the correct
+       * implementation for this version number before proceeding to
+       * decode other parts of this message.
+       * </pre>
+       *
+       * <code>required uint32 version = 15 [default = 1];</code>
+       */
+      private void clearVersion() {
+        bitField0_ = (bitField0_ & ~0x00000001);
+        version_ = 1;
+      }
+
+      public static final int NAME_FIELD_NUMBER = 1;
+      private java.lang.String name_;
+      /**
+       * <code>required string name = 1;</code>
+       * @return Whether the name field is set.
+       */
+      @java.lang.Override
+      public boolean hasName() {
+        return ((bitField0_ & 0x00000002) != 0);
+      }
+      /**
+       * <code>required string name = 1;</code>
+       * @return The name.
+       */
+      @java.lang.Override
+      public java.lang.String getName() {
+        return name_;
+      }
+      /**
+       * <code>required string name = 1;</code>
+       * @return The bytes for name.
+       */
+      @java.lang.Override
+      public com.google.protobuf.ByteString
+          getNameBytes() {
+        return com.google.protobuf.ByteString.copyFromUtf8(name_);
+      }
+      /**
+       * <code>required string name = 1;</code>
+       * @param value The name to set.
+       */
+      private void setName(
+          java.lang.String value) {
+        java.lang.Class<?> valueClass = value.getClass();
+  bitField0_ |= 0x00000002;
+        name_ = value;
+      }
+      /**
+       * <code>required string name = 1;</code>
+       */
+      private void clearName() {
+        bitField0_ = (bitField0_ & ~0x00000002);
+        name_ = getDefaultInstance().getName();
+      }
+      /**
+       * <code>required string name = 1;</code>
+       * @param value The bytes for name to set.
+       */
+      private void setNameBytes(
+          com.google.protobuf.ByteString value) {
+        name_ = value.toStringUtf8();
+        bitField0_ |= 0x00000002;
+      }
+
+      public static final int FEATURES_FIELD_NUMBER = 2;
+      private com.google.protobuf.Internal.ProtobufList<vector_tile.VectorTile.Tile.Feature> features_;
+      /**
+       * <pre>
+       * The actual features in this tile.
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+       */
+      @java.lang.Override
+      public java.util.List<vector_tile.VectorTile.Tile.Feature> getFeaturesList() {
+        return features_;
+      }
+      /**
+       * <pre>
+       * The actual features in this tile.
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+       */
+      public java.util.List<? extends vector_tile.VectorTile.Tile.FeatureOrBuilder> 
+          getFeaturesOrBuilderList() {
+        return features_;
+      }
+      /**
+       * <pre>
+       * The actual features in this tile.
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+       */
+      @java.lang.Override
+      public int getFeaturesCount() {
+        return features_.size();
+      }
+      /**
+       * <pre>
+       * The actual features in this tile.
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+       */
+      @java.lang.Override
+      public vector_tile.VectorTile.Tile.Feature getFeatures(int index) {
+        return features_.get(index);
+      }
+      /**
+       * <pre>
+       * The actual features in this tile.
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+       */
+      public vector_tile.VectorTile.Tile.FeatureOrBuilder getFeaturesOrBuilder(
+          int index) {
+        return features_.get(index);
+      }
+      private void ensureFeaturesIsMutable() {
+        com.google.protobuf.Internal.ProtobufList<vector_tile.VectorTile.Tile.Feature> tmp = features_;
+        if (!tmp.isModifiable()) {
+          features_ =
+              com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
+         }
+      }
+
+      /**
+       * <pre>
+       * The actual features in this tile.
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+       */
+      private void setFeatures(
+          int index, vector_tile.VectorTile.Tile.Feature value) {
+        value.getClass();
+  ensureFeaturesIsMutable();
+        features_.set(index, value);
+      }
+      /**
+       * <pre>
+       * The actual features in this tile.
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+       */
+      private void addFeatures(vector_tile.VectorTile.Tile.Feature value) {
+        value.getClass();
+  ensureFeaturesIsMutable();
+        features_.add(value);
+      }
+      /**
+       * <pre>
+       * The actual features in this tile.
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+       */
+      private void addFeatures(
+          int index, vector_tile.VectorTile.Tile.Feature value) {
+        value.getClass();
+  ensureFeaturesIsMutable();
+        features_.add(index, value);
+      }
+      /**
+       * <pre>
+       * The actual features in this tile.
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+       */
+      private void addAllFeatures(
+          java.lang.Iterable<? extends vector_tile.VectorTile.Tile.Feature> values) {
+        ensureFeaturesIsMutable();
+        com.google.protobuf.AbstractMessageLite.addAll(
+            values, features_);
+      }
+      /**
+       * <pre>
+       * The actual features in this tile.
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+       */
+      private void clearFeatures() {
+        features_ = emptyProtobufList();
+      }
+      /**
+       * <pre>
+       * The actual features in this tile.
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+       */
+      private void removeFeatures(int index) {
+        ensureFeaturesIsMutable();
+        features_.remove(index);
+      }
+
+      public static final int KEYS_FIELD_NUMBER = 3;
+      private com.google.protobuf.Internal.ProtobufList<java.lang.String> keys_;
+      /**
+       * <pre>
+       * Dictionary encoding for keys
+       * </pre>
+       *
+       * <code>repeated string keys = 3;</code>
+       * @return A list containing the keys.
+       */
+      @java.lang.Override
+      public java.util.List<java.lang.String> getKeysList() {
+        return keys_;
+      }
+      /**
+       * <pre>
+       * Dictionary encoding for keys
+       * </pre>
+       *
+       * <code>repeated string keys = 3;</code>
+       * @return The count of keys.
+       */
+      @java.lang.Override
+      public int getKeysCount() {
+        return keys_.size();
+      }
+      /**
+       * <pre>
+       * Dictionary encoding for keys
+       * </pre>
+       *
+       * <code>repeated string keys = 3;</code>
+       * @param index The index of the element to return.
+       * @return The keys at the given index.
+       */
+      @java.lang.Override
+      public java.lang.String getKeys(int index) {
+        return keys_.get(index);
+      }
+      /**
+       * <pre>
+       * Dictionary encoding for keys
+       * </pre>
+       *
+       * <code>repeated string keys = 3;</code>
+       * @param index The index of the value to return.
+       * @return The bytes of the keys at the given index.
+       */
+      @java.lang.Override
+      public com.google.protobuf.ByteString
+          getKeysBytes(int index) {
+        return com.google.protobuf.ByteString.copyFromUtf8(
+            keys_.get(index));
+      }
+      private void ensureKeysIsMutable() {
+        com.google.protobuf.Internal.ProtobufList<java.lang.String> tmp =
+            keys_;  if (!tmp.isModifiable()) {
+          keys_ =
+              com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
+         }
+      }
+      /**
+       * <pre>
+       * Dictionary encoding for keys
+       * </pre>
+       *
+       * <code>repeated string keys = 3;</code>
+       * @param index The index to set the value at.
+       * @param value The keys to set.
+       */
+      private void setKeys(
+          int index, java.lang.String value) {
+        java.lang.Class<?> valueClass = value.getClass();
+  ensureKeysIsMutable();
+        keys_.set(index, value);
+      }
+      /**
+       * <pre>
+       * Dictionary encoding for keys
+       * </pre>
+       *
+       * <code>repeated string keys = 3;</code>
+       * @param value The keys to add.
+       */
+      private void addKeys(
+          java.lang.String value) {
+        java.lang.Class<?> valueClass = value.getClass();
+  ensureKeysIsMutable();
+        keys_.add(value);
+      }
+      /**
+       * <pre>
+       * Dictionary encoding for keys
+       * </pre>
+       *
+       * <code>repeated string keys = 3;</code>
+       * @param values The keys to add.
+       */
+      private void addAllKeys(
+          java.lang.Iterable<java.lang.String> values) {
+        ensureKeysIsMutable();
+        com.google.protobuf.AbstractMessageLite.addAll(
+            values, keys_);
+      }
+      /**
+       * <pre>
+       * Dictionary encoding for keys
+       * </pre>
+       *
+       * <code>repeated string keys = 3;</code>
+       */
+      private void clearKeys() {
+        keys_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
+      }
+      /**
+       * <pre>
+       * Dictionary encoding for keys
+       * </pre>
+       *
+       * <code>repeated string keys = 3;</code>
+       * @param value The bytes of the keys to add.
+       */
+      private void addKeysBytes(
+          com.google.protobuf.ByteString value) {
+        ensureKeysIsMutable();
+        keys_.add(value.toStringUtf8());
+      }
+
+      public static final int VALUES_FIELD_NUMBER = 4;
+      private com.google.protobuf.Internal.ProtobufList<vector_tile.VectorTile.Tile.Value> values_;
+      /**
+       * <pre>
+       * Dictionary encoding for values
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+       */
+      @java.lang.Override
+      public java.util.List<vector_tile.VectorTile.Tile.Value> getValuesList() {
+        return values_;
+      }
+      /**
+       * <pre>
+       * Dictionary encoding for values
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+       */
+      public java.util.List<? extends vector_tile.VectorTile.Tile.ValueOrBuilder> 
+          getValuesOrBuilderList() {
+        return values_;
+      }
+      /**
+       * <pre>
+       * Dictionary encoding for values
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+       */
+      @java.lang.Override
+      public int getValuesCount() {
+        return values_.size();
+      }
+      /**
+       * <pre>
+       * Dictionary encoding for values
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+       */
+      @java.lang.Override
+      public vector_tile.VectorTile.Tile.Value getValues(int index) {
+        return values_.get(index);
+      }
+      /**
+       * <pre>
+       * Dictionary encoding for values
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+       */
+      public vector_tile.VectorTile.Tile.ValueOrBuilder getValuesOrBuilder(
+          int index) {
+        return values_.get(index);
+      }
+      private void ensureValuesIsMutable() {
+        com.google.protobuf.Internal.ProtobufList<vector_tile.VectorTile.Tile.Value> tmp = values_;
+        if (!tmp.isModifiable()) {
+          values_ =
+              com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
+         }
+      }
+
+      /**
+       * <pre>
+       * Dictionary encoding for values
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+       */
+      private void setValues(
+          int index, vector_tile.VectorTile.Tile.Value value) {
+        value.getClass();
+  ensureValuesIsMutable();
+        values_.set(index, value);
+      }
+      /**
+       * <pre>
+       * Dictionary encoding for values
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+       */
+      private void addValues(vector_tile.VectorTile.Tile.Value value) {
+        value.getClass();
+  ensureValuesIsMutable();
+        values_.add(value);
+      }
+      /**
+       * <pre>
+       * Dictionary encoding for values
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+       */
+      private void addValues(
+          int index, vector_tile.VectorTile.Tile.Value value) {
+        value.getClass();
+  ensureValuesIsMutable();
+        values_.add(index, value);
+      }
+      /**
+       * <pre>
+       * Dictionary encoding for values
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+       */
+      private void addAllValues(
+          java.lang.Iterable<? extends vector_tile.VectorTile.Tile.Value> values) {
+        ensureValuesIsMutable();
+        com.google.protobuf.AbstractMessageLite.addAll(
+            values, values_);
+      }
+      /**
+       * <pre>
+       * Dictionary encoding for values
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+       */
+      private void clearValues() {
+        values_ = emptyProtobufList();
+      }
+      /**
+       * <pre>
+       * Dictionary encoding for values
+       * </pre>
+       *
+       * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+       */
+      private void removeValues(int index) {
+        ensureValuesIsMutable();
+        values_.remove(index);
+      }
+
+      public static final int EXTENT_FIELD_NUMBER = 5;
+      private int extent_;
+      /**
+       * <pre>
+       * Although this is an "optional" field it is required by the specification.
+       * See https://github.com/mapbox/vector-tile-spec/issues/47
+       * </pre>
+       *
+       * <code>optional uint32 extent = 5 [default = 4096];</code>
+       * @return Whether the extent field is set.
+       */
+      @java.lang.Override
+      public boolean hasExtent() {
+        return ((bitField0_ & 0x00000004) != 0);
+      }
+      /**
+       * <pre>
+       * Although this is an "optional" field it is required by the specification.
+       * See https://github.com/mapbox/vector-tile-spec/issues/47
+       * </pre>
+       *
+       * <code>optional uint32 extent = 5 [default = 4096];</code>
+       * @return The extent.
+       */
+      @java.lang.Override
+      public int getExtent() {
+        return extent_;
+      }
+      /**
+       * <pre>
+       * Although this is an "optional" field it is required by the specification.
+       * See https://github.com/mapbox/vector-tile-spec/issues/47
+       * </pre>
+       *
+       * <code>optional uint32 extent = 5 [default = 4096];</code>
+       * @param value The extent to set.
+       */
+      private void setExtent(int value) {
+        bitField0_ |= 0x00000004;
+        extent_ = value;
+      }
+      /**
+       * <pre>
+       * Although this is an "optional" field it is required by the specification.
+       * See https://github.com/mapbox/vector-tile-spec/issues/47
+       * </pre>
+       *
+       * <code>optional uint32 extent = 5 [default = 4096];</code>
+       */
+      private void clearExtent() {
+        bitField0_ = (bitField0_ & ~0x00000004);
+        extent_ = 4096;
+      }
+
+      public static vector_tile.VectorTile.Tile.Layer parseFrom(
+          java.nio.ByteBuffer data)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, data);
+      }
+      public static vector_tile.VectorTile.Tile.Layer parseFrom(
+          java.nio.ByteBuffer data,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, data, extensionRegistry);
+      }
+      public static vector_tile.VectorTile.Tile.Layer parseFrom(
+          com.google.protobuf.ByteString data)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, data);
+      }
+      public static vector_tile.VectorTile.Tile.Layer parseFrom(
+          com.google.protobuf.ByteString data,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, data, extensionRegistry);
+      }
+      public static vector_tile.VectorTile.Tile.Layer parseFrom(byte[] data)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, data);
+      }
+      public static vector_tile.VectorTile.Tile.Layer parseFrom(
+          byte[] data,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, data, extensionRegistry);
+      }
+      public static vector_tile.VectorTile.Tile.Layer parseFrom(java.io.InputStream input)
+          throws java.io.IOException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, input);
+      }
+      public static vector_tile.VectorTile.Tile.Layer parseFrom(
+          java.io.InputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws java.io.IOException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, input, extensionRegistry);
+      }
+      public static vector_tile.VectorTile.Tile.Layer parseDelimitedFrom(java.io.InputStream input)
+          throws java.io.IOException {
+        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
+      }
+      public static vector_tile.VectorTile.Tile.Layer parseDelimitedFrom(
+          java.io.InputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws java.io.IOException {
+        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
+      }
+      public static vector_tile.VectorTile.Tile.Layer parseFrom(
+          com.google.protobuf.CodedInputStream input)
+          throws java.io.IOException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, input);
+      }
+      public static vector_tile.VectorTile.Tile.Layer parseFrom(
+          com.google.protobuf.CodedInputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws java.io.IOException {
+        return com.google.protobuf.GeneratedMessageLite.parseFrom(
+            DEFAULT_INSTANCE, input, extensionRegistry);
+      }
+
+      public static Builder newBuilder() {
+        return (Builder) DEFAULT_INSTANCE.createBuilder();
+      }
+      public static Builder newBuilder(vector_tile.VectorTile.Tile.Layer prototype) {
+        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
+      }
+
+      /**
+       * <pre>
+       * Layers are described in section 4.1 of the specification
+       * </pre>
+       *
+       * Protobuf type {@code vector_tile.Tile.Layer}
+       */
+      public static final class Builder extends
+          com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
+            vector_tile.VectorTile.Tile.Layer, Builder> implements
+          // @@protoc_insertion_point(builder_implements:vector_tile.Tile.Layer)
+          vector_tile.VectorTile.Tile.LayerOrBuilder {
+        // Construct using vector_tile.VectorTile.Tile.Layer.newBuilder()
+        private Builder() {
+          super(DEFAULT_INSTANCE);
+        }
+
+
+        /**
+         * <pre>
+         * Any compliant implementation must first read the version
+         * number encoded in this message and choose the correct
+         * implementation for this version number before proceeding to
+         * decode other parts of this message.
+         * </pre>
+         *
+         * <code>required uint32 version = 15 [default = 1];</code>
+         * @return Whether the version field is set.
+         */
+        @java.lang.Override
+        public boolean hasVersion() {
+          return instance.hasVersion();
+        }
+        /**
+         * <pre>
+         * Any compliant implementation must first read the version
+         * number encoded in this message and choose the correct
+         * implementation for this version number before proceeding to
+         * decode other parts of this message.
+         * </pre>
+         *
+         * <code>required uint32 version = 15 [default = 1];</code>
+         * @return The version.
+         */
+        @java.lang.Override
+        public int getVersion() {
+          return instance.getVersion();
+        }
+        /**
+         * <pre>
+         * Any compliant implementation must first read the version
+         * number encoded in this message and choose the correct
+         * implementation for this version number before proceeding to
+         * decode other parts of this message.
+         * </pre>
+         *
+         * <code>required uint32 version = 15 [default = 1];</code>
+         * @param value The version to set.
+         * @return This builder for chaining.
+         */
+        public Builder setVersion(int value) {
+          copyOnWrite();
+          instance.setVersion(value);
+          return this;
+        }
+        /**
+         * <pre>
+         * Any compliant implementation must first read the version
+         * number encoded in this message and choose the correct
+         * implementation for this version number before proceeding to
+         * decode other parts of this message.
+         * </pre>
+         *
+         * <code>required uint32 version = 15 [default = 1];</code>
+         * @return This builder for chaining.
+         */
+        public Builder clearVersion() {
+          copyOnWrite();
+          instance.clearVersion();
+          return this;
+        }
+
+        /**
+         * <code>required string name = 1;</code>
+         * @return Whether the name field is set.
+         */
+        @java.lang.Override
+        public boolean hasName() {
+          return instance.hasName();
+        }
+        /**
+         * <code>required string name = 1;</code>
+         * @return The name.
+         */
+        @java.lang.Override
+        public java.lang.String getName() {
+          return instance.getName();
+        }
+        /**
+         * <code>required string name = 1;</code>
+         * @return The bytes for name.
+         */
+        @java.lang.Override
+        public com.google.protobuf.ByteString
+            getNameBytes() {
+          return instance.getNameBytes();
+        }
+        /**
+         * <code>required string name = 1;</code>
+         * @param value The name to set.
+         * @return This builder for chaining.
+         */
+        public Builder setName(
+            java.lang.String value) {
+          copyOnWrite();
+          instance.setName(value);
+          return this;
+        }
+        /**
+         * <code>required string name = 1;</code>
+         * @return This builder for chaining.
+         */
+        public Builder clearName() {
+          copyOnWrite();
+          instance.clearName();
+          return this;
+        }
+        /**
+         * <code>required string name = 1;</code>
+         * @param value The bytes for name to set.
+         * @return This builder for chaining.
+         */
+        public Builder setNameBytes(
+            com.google.protobuf.ByteString value) {
+          copyOnWrite();
+          instance.setNameBytes(value);
+          return this;
+        }
+
+        /**
+         * <pre>
+         * The actual features in this tile.
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+         */
+        @java.lang.Override
+        public java.util.List<vector_tile.VectorTile.Tile.Feature> getFeaturesList() {
+          return java.util.Collections.unmodifiableList(
+              instance.getFeaturesList());
+        }
+        /**
+         * <pre>
+         * The actual features in this tile.
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+         */
+        @java.lang.Override
+        public int getFeaturesCount() {
+          return instance.getFeaturesCount();
+        }/**
+         * <pre>
+         * The actual features in this tile.
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+         */
+        @java.lang.Override
+        public vector_tile.VectorTile.Tile.Feature getFeatures(int index) {
+          return instance.getFeatures(index);
+        }
+        /**
+         * <pre>
+         * The actual features in this tile.
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+         */
+        public Builder setFeatures(
+            int index, vector_tile.VectorTile.Tile.Feature value) {
+          copyOnWrite();
+          instance.setFeatures(index, value);
+          return this;
+        }
+        /**
+         * <pre>
+         * The actual features in this tile.
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+         */
+        public Builder setFeatures(
+            int index, vector_tile.VectorTile.Tile.Feature.Builder builderForValue) {
+          copyOnWrite();
+          instance.setFeatures(index,
+              builderForValue.build());
+          return this;
+        }
+        /**
+         * <pre>
+         * The actual features in this tile.
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+         */
+        public Builder addFeatures(vector_tile.VectorTile.Tile.Feature value) {
+          copyOnWrite();
+          instance.addFeatures(value);
+          return this;
+        }
+        /**
+         * <pre>
+         * The actual features in this tile.
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+         */
+        public Builder addFeatures(
+            int index, vector_tile.VectorTile.Tile.Feature value) {
+          copyOnWrite();
+          instance.addFeatures(index, value);
+          return this;
+        }
+        /**
+         * <pre>
+         * The actual features in this tile.
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+         */
+        public Builder addFeatures(
+            vector_tile.VectorTile.Tile.Feature.Builder builderForValue) {
+          copyOnWrite();
+          instance.addFeatures(builderForValue.build());
+          return this;
+        }
+        /**
+         * <pre>
+         * The actual features in this tile.
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+         */
+        public Builder addFeatures(
+            int index, vector_tile.VectorTile.Tile.Feature.Builder builderForValue) {
+          copyOnWrite();
+          instance.addFeatures(index,
+              builderForValue.build());
+          return this;
+        }
+        /**
+         * <pre>
+         * The actual features in this tile.
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+         */
+        public Builder addAllFeatures(
+            java.lang.Iterable<? extends vector_tile.VectorTile.Tile.Feature> values) {
+          copyOnWrite();
+          instance.addAllFeatures(values);
+          return this;
+        }
+        /**
+         * <pre>
+         * The actual features in this tile.
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+         */
+        public Builder clearFeatures() {
+          copyOnWrite();
+          instance.clearFeatures();
+          return this;
+        }
+        /**
+         * <pre>
+         * The actual features in this tile.
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Feature features = 2;</code>
+         */
+        public Builder removeFeatures(int index) {
+          copyOnWrite();
+          instance.removeFeatures(index);
+          return this;
+        }
+
+        /**
+         * <pre>
+         * Dictionary encoding for keys
+         * </pre>
+         *
+         * <code>repeated string keys = 3;</code>
+         * @return A list containing the keys.
+         */
+        @java.lang.Override
+        public java.util.List<java.lang.String>
+            getKeysList() {
+          return java.util.Collections.unmodifiableList(
+              instance.getKeysList());
+        }
+        /**
+         * <pre>
+         * Dictionary encoding for keys
+         * </pre>
+         *
+         * <code>repeated string keys = 3;</code>
+         * @return The count of keys.
+         */
+        @java.lang.Override
+        public int getKeysCount() {
+          return instance.getKeysCount();
+        }
+        /**
+         * <pre>
+         * Dictionary encoding for keys
+         * </pre>
+         *
+         * <code>repeated string keys = 3;</code>
+         * @param index The index of the element to return.
+         * @return The keys at the given index.
+         */
+        @java.lang.Override
+        public java.lang.String getKeys(int index) {
+          return instance.getKeys(index);
+        }
+        /**
+         * <pre>
+         * Dictionary encoding for keys
+         * </pre>
+         *
+         * <code>repeated string keys = 3;</code>
+         * @param index The index of the value to return.
+         * @return The bytes of the keys at the given index.
+         */
+        @java.lang.Override
+        public com.google.protobuf.ByteString
+            getKeysBytes(int index) {
+          return instance.getKeysBytes(index);
+        }
+        /**
+         * <pre>
+         * Dictionary encoding for keys
+         * </pre>
+         *
+         * <code>repeated string keys = 3;</code>
+         * @param index The index to set the value at.
+         * @param value The keys to set.
+         * @return This builder for chaining.
+         */
+        public Builder setKeys(
+            int index, java.lang.String value) {
+          copyOnWrite();
+          instance.setKeys(index, value);
+          return this;
+        }
+        /**
+         * <pre>
+         * Dictionary encoding for keys
+         * </pre>
+         *
+         * <code>repeated string keys = 3;</code>
+         * @param value The keys to add.
+         * @return This builder for chaining.
+         */
+        public Builder addKeys(
+            java.lang.String value) {
+          copyOnWrite();
+          instance.addKeys(value);
+          return this;
+        }
+        /**
+         * <pre>
+         * Dictionary encoding for keys
+         * </pre>
+         *
+         * <code>repeated string keys = 3;</code>
+         * @param values The keys to add.
+         * @return This builder for chaining.
+         */
+        public Builder addAllKeys(
+            java.lang.Iterable<java.lang.String> values) {
+          copyOnWrite();
+          instance.addAllKeys(values);
+          return this;
+        }
+        /**
+         * <pre>
+         * Dictionary encoding for keys
+         * </pre>
+         *
+         * <code>repeated string keys = 3;</code>
+         * @return This builder for chaining.
+         */
+        public Builder clearKeys() {
+          copyOnWrite();
+          instance.clearKeys();
+          return this;
+        }
+        /**
+         * <pre>
+         * Dictionary encoding for keys
+         * </pre>
+         *
+         * <code>repeated string keys = 3;</code>
+         * @param value The bytes of the keys to add.
+         * @return This builder for chaining.
+         */
+        public Builder addKeysBytes(
+            com.google.protobuf.ByteString value) {
+          copyOnWrite();
+          instance.addKeysBytes(value);
+          return this;
+        }
+
+        /**
+         * <pre>
+         * Dictionary encoding for values
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+         */
+        @java.lang.Override
+        public java.util.List<vector_tile.VectorTile.Tile.Value> getValuesList() {
+          return java.util.Collections.unmodifiableList(
+              instance.getValuesList());
+        }
+        /**
+         * <pre>
+         * Dictionary encoding for values
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+         */
+        @java.lang.Override
+        public int getValuesCount() {
+          return instance.getValuesCount();
+        }/**
+         * <pre>
+         * Dictionary encoding for values
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+         */
+        @java.lang.Override
+        public vector_tile.VectorTile.Tile.Value getValues(int index) {
+          return instance.getValues(index);
+        }
+        /**
+         * <pre>
+         * Dictionary encoding for values
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+         */
+        public Builder setValues(
+            int index, vector_tile.VectorTile.Tile.Value value) {
+          copyOnWrite();
+          instance.setValues(index, value);
+          return this;
+        }
+        /**
+         * <pre>
+         * Dictionary encoding for values
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+         */
+        public Builder setValues(
+            int index, vector_tile.VectorTile.Tile.Value.Builder builderForValue) {
+          copyOnWrite();
+          instance.setValues(index,
+              builderForValue.build());
+          return this;
+        }
+        /**
+         * <pre>
+         * Dictionary encoding for values
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+         */
+        public Builder addValues(vector_tile.VectorTile.Tile.Value value) {
+          copyOnWrite();
+          instance.addValues(value);
+          return this;
+        }
+        /**
+         * <pre>
+         * Dictionary encoding for values
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+         */
+        public Builder addValues(
+            int index, vector_tile.VectorTile.Tile.Value value) {
+          copyOnWrite();
+          instance.addValues(index, value);
+          return this;
+        }
+        /**
+         * <pre>
+         * Dictionary encoding for values
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+         */
+        public Builder addValues(
+            vector_tile.VectorTile.Tile.Value.Builder builderForValue) {
+          copyOnWrite();
+          instance.addValues(builderForValue.build());
+          return this;
+        }
+        /**
+         * <pre>
+         * Dictionary encoding for values
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+         */
+        public Builder addValues(
+            int index, vector_tile.VectorTile.Tile.Value.Builder builderForValue) {
+          copyOnWrite();
+          instance.addValues(index,
+              builderForValue.build());
+          return this;
+        }
+        /**
+         * <pre>
+         * Dictionary encoding for values
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+         */
+        public Builder addAllValues(
+            java.lang.Iterable<? extends vector_tile.VectorTile.Tile.Value> values) {
+          copyOnWrite();
+          instance.addAllValues(values);
+          return this;
+        }
+        /**
+         * <pre>
+         * Dictionary encoding for values
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+         */
+        public Builder clearValues() {
+          copyOnWrite();
+          instance.clearValues();
+          return this;
+        }
+        /**
+         * <pre>
+         * Dictionary encoding for values
+         * </pre>
+         *
+         * <code>repeated .vector_tile.Tile.Value values = 4;</code>
+         */
+        public Builder removeValues(int index) {
+          copyOnWrite();
+          instance.removeValues(index);
+          return this;
+        }
+
+        /**
+         * <pre>
+         * Although this is an "optional" field it is required by the specification.
+         * See https://github.com/mapbox/vector-tile-spec/issues/47
+         * </pre>
+         *
+         * <code>optional uint32 extent = 5 [default = 4096];</code>
+         * @return Whether the extent field is set.
+         */
+        @java.lang.Override
+        public boolean hasExtent() {
+          return instance.hasExtent();
+        }
+        /**
+         * <pre>
+         * Although this is an "optional" field it is required by the specification.
+         * See https://github.com/mapbox/vector-tile-spec/issues/47
+         * </pre>
+         *
+         * <code>optional uint32 extent = 5 [default = 4096];</code>
+         * @return The extent.
+         */
+        @java.lang.Override
+        public int getExtent() {
+          return instance.getExtent();
+        }
+        /**
+         * <pre>
+         * Although this is an "optional" field it is required by the specification.
+         * See https://github.com/mapbox/vector-tile-spec/issues/47
+         * </pre>
+         *
+         * <code>optional uint32 extent = 5 [default = 4096];</code>
+         * @param value The extent to set.
+         * @return This builder for chaining.
+         */
+        public Builder setExtent(int value) {
+          copyOnWrite();
+          instance.setExtent(value);
+          return this;
+        }
+        /**
+         * <pre>
+         * Although this is an "optional" field it is required by the specification.
+         * See https://github.com/mapbox/vector-tile-spec/issues/47
+         * </pre>
+         *
+         * <code>optional uint32 extent = 5 [default = 4096];</code>
+         * @return This builder for chaining.
+         */
+        public Builder clearExtent() {
+          copyOnWrite();
+          instance.clearExtent();
+          return this;
+        }
+
+        // @@protoc_insertion_point(builder_scope:vector_tile.Tile.Layer)
+      }
+      private byte memoizedIsInitialized = 2;
+      @java.lang.Override
+      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
+      protected final java.lang.Object dynamicMethod(
+          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
+          java.lang.Object arg0, java.lang.Object arg1) {
+        switch (method) {
+          case NEW_MUTABLE_INSTANCE: {
+            return new vector_tile.VectorTile.Tile.Layer();
+          }
+          case NEW_BUILDER: {
+            return new Builder();
+          }
+          case BUILD_MESSAGE_INFO: {
+              java.lang.Object[] objects = new java.lang.Object[] {
+                "bitField0_",
+                "name_",
+                "features_",
+                vector_tile.VectorTile.Tile.Feature.class,
+                "keys_",
+                "values_",
+                vector_tile.VectorTile.Tile.Value.class,
+                "extent_",
+                "version_",
+              };
+              java.lang.String info =
+                  "\u0001\u0006\u0000\u0001\u0001\u000f\u0006\u0000\u0003\u0003\u0001\u1508\u0001\u0002" +
+                  "\u001b\u0003\u001a\u0004\u041b\u0005\u100b\u0002\u000f\u150b\u0000";
+              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
+          }
+          // fall through
+          case GET_DEFAULT_INSTANCE: {
+            return DEFAULT_INSTANCE;
+          }
+          case GET_PARSER: {
+            com.google.protobuf.Parser<vector_tile.VectorTile.Tile.Layer> parser = PARSER;
+            if (parser == null) {
+              synchronized (vector_tile.VectorTile.Tile.Layer.class) {
+                parser = PARSER;
+                if (parser == null) {
+                  parser =
+                      new DefaultInstanceBasedParser<vector_tile.VectorTile.Tile.Layer>(
+                          DEFAULT_INSTANCE);
+                  PARSER = parser;
+                }
+              }
+            }
+            return parser;
+        }
+        case GET_MEMOIZED_IS_INITIALIZED: {
+          return memoizedIsInitialized;
+        }
+        case SET_MEMOIZED_IS_INITIALIZED: {
+          memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
+          return null;
+        }
+        }
+        throw new UnsupportedOperationException();
+      }
+
+
+      // @@protoc_insertion_point(class_scope:vector_tile.Tile.Layer)
+      private static final vector_tile.VectorTile.Tile.Layer DEFAULT_INSTANCE;
+      static {
+        Layer defaultInstance = new Layer();
+        // New instances are implicitly immutable so no need to make
+        // immutable.
+        DEFAULT_INSTANCE = defaultInstance;
+        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
+          Layer.class, defaultInstance);
+      }
+
+      public static vector_tile.VectorTile.Tile.Layer getDefaultInstance() {
+        return DEFAULT_INSTANCE;
+      }
+
+      private static volatile com.google.protobuf.Parser<Layer> PARSER;
+
+      public static com.google.protobuf.Parser<Layer> parser() {
+        return DEFAULT_INSTANCE.getParserForType();
+      }
+    }
+
+    public static final int LAYERS_FIELD_NUMBER = 3;
+    private com.google.protobuf.Internal.ProtobufList<vector_tile.VectorTile.Tile.Layer> layers_;
+    /**
+     * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+     */
+    @java.lang.Override
+    public java.util.List<vector_tile.VectorTile.Tile.Layer> getLayersList() {
+      return layers_;
+    }
+    /**
+     * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+     */
+    public java.util.List<? extends vector_tile.VectorTile.Tile.LayerOrBuilder> 
+        getLayersOrBuilderList() {
+      return layers_;
+    }
+    /**
+     * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+     */
+    @java.lang.Override
+    public int getLayersCount() {
+      return layers_.size();
+    }
+    /**
+     * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+     */
+    @java.lang.Override
+    public vector_tile.VectorTile.Tile.Layer getLayers(int index) {
+      return layers_.get(index);
+    }
+    /**
+     * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+     */
+    public vector_tile.VectorTile.Tile.LayerOrBuilder getLayersOrBuilder(
+        int index) {
+      return layers_.get(index);
+    }
+    private void ensureLayersIsMutable() {
+      com.google.protobuf.Internal.ProtobufList<vector_tile.VectorTile.Tile.Layer> tmp = layers_;
+      if (!tmp.isModifiable()) {
+        layers_ =
+            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
+       }
+    }
+
+    /**
+     * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+     */
+    private void setLayers(
+        int index, vector_tile.VectorTile.Tile.Layer value) {
+      value.getClass();
+  ensureLayersIsMutable();
+      layers_.set(index, value);
+    }
+    /**
+     * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+     */
+    private void addLayers(vector_tile.VectorTile.Tile.Layer value) {
+      value.getClass();
+  ensureLayersIsMutable();
+      layers_.add(value);
+    }
+    /**
+     * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+     */
+    private void addLayers(
+        int index, vector_tile.VectorTile.Tile.Layer value) {
+      value.getClass();
+  ensureLayersIsMutable();
+      layers_.add(index, value);
+    }
+    /**
+     * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+     */
+    private void addAllLayers(
+        java.lang.Iterable<? extends vector_tile.VectorTile.Tile.Layer> values) {
+      ensureLayersIsMutable();
+      com.google.protobuf.AbstractMessageLite.addAll(
+          values, layers_);
+    }
+    /**
+     * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+     */
+    private void clearLayers() {
+      layers_ = emptyProtobufList();
+    }
+    /**
+     * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+     */
+    private void removeLayers(int index) {
+      ensureLayersIsMutable();
+      layers_.remove(index);
+    }
+
+    public static vector_tile.VectorTile.Tile parseFrom(
+        java.nio.ByteBuffer data)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return com.google.protobuf.GeneratedMessageLite.parseFrom(
+          DEFAULT_INSTANCE, data);
+    }
+    public static vector_tile.VectorTile.Tile parseFrom(
+        java.nio.ByteBuffer data,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return com.google.protobuf.GeneratedMessageLite.parseFrom(
+          DEFAULT_INSTANCE, data, extensionRegistry);
+    }
+    public static vector_tile.VectorTile.Tile parseFrom(
+        com.google.protobuf.ByteString data)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return com.google.protobuf.GeneratedMessageLite.parseFrom(
+          DEFAULT_INSTANCE, data);
+    }
+    public static vector_tile.VectorTile.Tile parseFrom(
+        com.google.protobuf.ByteString data,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return com.google.protobuf.GeneratedMessageLite.parseFrom(
+          DEFAULT_INSTANCE, data, extensionRegistry);
+    }
+    public static vector_tile.VectorTile.Tile parseFrom(byte[] data)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return com.google.protobuf.GeneratedMessageLite.parseFrom(
+          DEFAULT_INSTANCE, data);
+    }
+    public static vector_tile.VectorTile.Tile parseFrom(
+        byte[] data,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return com.google.protobuf.GeneratedMessageLite.parseFrom(
+          DEFAULT_INSTANCE, data, extensionRegistry);
+    }
+    public static vector_tile.VectorTile.Tile parseFrom(java.io.InputStream input)
+        throws java.io.IOException {
+      return com.google.protobuf.GeneratedMessageLite.parseFrom(
+          DEFAULT_INSTANCE, input);
+    }
+    public static vector_tile.VectorTile.Tile parseFrom(
+        java.io.InputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return com.google.protobuf.GeneratedMessageLite.parseFrom(
+          DEFAULT_INSTANCE, input, extensionRegistry);
+    }
+    public static vector_tile.VectorTile.Tile parseDelimitedFrom(java.io.InputStream input)
+        throws java.io.IOException {
+      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
+    }
+    public static vector_tile.VectorTile.Tile parseDelimitedFrom(
+        java.io.InputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
+    }
+    public static vector_tile.VectorTile.Tile parseFrom(
+        com.google.protobuf.CodedInputStream input)
+        throws java.io.IOException {
+      return com.google.protobuf.GeneratedMessageLite.parseFrom(
+          DEFAULT_INSTANCE, input);
+    }
+    public static vector_tile.VectorTile.Tile parseFrom(
+        com.google.protobuf.CodedInputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return com.google.protobuf.GeneratedMessageLite.parseFrom(
+          DEFAULT_INSTANCE, input, extensionRegistry);
+    }
+
+    public static Builder newBuilder() {
+      return (Builder) DEFAULT_INSTANCE.createBuilder();
+    }
+    public static Builder newBuilder(vector_tile.VectorTile.Tile prototype) {
+      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
+    }
+
+    /**
+     * Protobuf type {@code vector_tile.Tile}
+     */
+    public static final class Builder extends
+        com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
+          vector_tile.VectorTile.Tile, Builder> implements
+        // @@protoc_insertion_point(builder_implements:vector_tile.Tile)
+        vector_tile.VectorTile.TileOrBuilder {
+      // Construct using vector_tile.VectorTile.Tile.newBuilder()
+      private Builder() {
+        super(DEFAULT_INSTANCE);
+      }
+
+
+      /**
+       * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+       */
+      @java.lang.Override
+      public java.util.List<vector_tile.VectorTile.Tile.Layer> getLayersList() {
+        return java.util.Collections.unmodifiableList(
+            instance.getLayersList());
+      }
+      /**
+       * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+       */
+      @java.lang.Override
+      public int getLayersCount() {
+        return instance.getLayersCount();
+      }/**
+       * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+       */
+      @java.lang.Override
+      public vector_tile.VectorTile.Tile.Layer getLayers(int index) {
+        return instance.getLayers(index);
+      }
+      /**
+       * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+       */
+      public Builder setLayers(
+          int index, vector_tile.VectorTile.Tile.Layer value) {
+        copyOnWrite();
+        instance.setLayers(index, value);
+        return this;
+      }
+      /**
+       * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+       */
+      public Builder setLayers(
+          int index, vector_tile.VectorTile.Tile.Layer.Builder builderForValue) {
+        copyOnWrite();
+        instance.setLayers(index,
+            builderForValue.build());
+        return this;
+      }
+      /**
+       * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+       */
+      public Builder addLayers(vector_tile.VectorTile.Tile.Layer value) {
+        copyOnWrite();
+        instance.addLayers(value);
+        return this;
+      }
+      /**
+       * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+       */
+      public Builder addLayers(
+          int index, vector_tile.VectorTile.Tile.Layer value) {
+        copyOnWrite();
+        instance.addLayers(index, value);
+        return this;
+      }
+      /**
+       * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+       */
+      public Builder addLayers(
+          vector_tile.VectorTile.Tile.Layer.Builder builderForValue) {
+        copyOnWrite();
+        instance.addLayers(builderForValue.build());
+        return this;
+      }
+      /**
+       * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+       */
+      public Builder addLayers(
+          int index, vector_tile.VectorTile.Tile.Layer.Builder builderForValue) {
+        copyOnWrite();
+        instance.addLayers(index,
+            builderForValue.build());
+        return this;
+      }
+      /**
+       * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+       */
+      public Builder addAllLayers(
+          java.lang.Iterable<? extends vector_tile.VectorTile.Tile.Layer> values) {
+        copyOnWrite();
+        instance.addAllLayers(values);
+        return this;
+      }
+      /**
+       * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+       */
+      public Builder clearLayers() {
+        copyOnWrite();
+        instance.clearLayers();
+        return this;
+      }
+      /**
+       * <code>repeated .vector_tile.Tile.Layer layers = 3;</code>
+       */
+      public Builder removeLayers(int index) {
+        copyOnWrite();
+        instance.removeLayers(index);
+        return this;
+      }
+
+      // @@protoc_insertion_point(builder_scope:vector_tile.Tile)
+    }
+    private byte memoizedIsInitialized = 2;
+    @java.lang.Override
+    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
+    protected final java.lang.Object dynamicMethod(
+        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
+        java.lang.Object arg0, java.lang.Object arg1) {
+      switch (method) {
+        case NEW_MUTABLE_INSTANCE: {
+          return new vector_tile.VectorTile.Tile();
+        }
+        case NEW_BUILDER: {
+          return new Builder();
+        }
+        case BUILD_MESSAGE_INFO: {
+            java.lang.Object[] objects = new java.lang.Object[] {
+              "layers_",
+              vector_tile.VectorTile.Tile.Layer.class,
+            };
+            java.lang.String info =
+                "\u0001\u0001\u0000\u0000\u0003\u0003\u0001\u0000\u0001\u0001\u0003\u041b";
+            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
+        }
+        // fall through
+        case GET_DEFAULT_INSTANCE: {
+          return DEFAULT_INSTANCE;
+        }
+        case GET_PARSER: {
+          com.google.protobuf.Parser<vector_tile.VectorTile.Tile> parser = PARSER;
+          if (parser == null) {
+            synchronized (vector_tile.VectorTile.Tile.class) {
+              parser = PARSER;
+              if (parser == null) {
+                parser =
+                    new DefaultInstanceBasedParser<vector_tile.VectorTile.Tile>(
+                        DEFAULT_INSTANCE);
+                PARSER = parser;
+              }
+            }
+          }
+          return parser;
+      }
+      case GET_MEMOIZED_IS_INITIALIZED: {
+        return memoizedIsInitialized;
+      }
+      case SET_MEMOIZED_IS_INITIALIZED: {
+        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
+        return null;
+      }
+      }
+      throw new UnsupportedOperationException();
+    }
+
+
+    // @@protoc_insertion_point(class_scope:vector_tile.Tile)
+    private static final vector_tile.VectorTile.Tile DEFAULT_INSTANCE;
+    static {
+      Tile defaultInstance = new Tile();
+      // New instances are implicitly immutable so no need to make
+      // immutable.
+      DEFAULT_INSTANCE = defaultInstance;
+      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
+        Tile.class, defaultInstance);
+    }
+
+    public static vector_tile.VectorTile.Tile getDefaultInstance() {
+      return DEFAULT_INSTANCE;
+    }
+
+    private static volatile com.google.protobuf.Parser<Tile> PARSER;
+
+    public static com.google.protobuf.Parser<Tile> parser() {
+      return DEFAULT_INSTANCE.getParserForType();
+    }
+  }
+
+
+  static {
+  }
+
+  // @@protoc_insertion_point(outer_class_scope)
+}
diff --git a/node_modules/react-native-maps/ios/.DS_Store b/node_modules/react-native-maps/ios/.DS_Store
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMap.m b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMap.m
index cfcac70..5d0e5fc 100644
--- a/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMap.m
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMap.m
@@ -8,57 +8,62 @@
 #ifdef HAVE_GOOGLE_MAPS
 
 #import "AIRGoogleMap.h"
+#import "AIRGoogleMapCircle.h"
+#import "AIRGoogleMapHeatmap.h"
 #import "AIRGoogleMapMarker.h"
 #import "AIRGoogleMapMarkerManager.h"
+#import "AIRGoogleMapOverlay.h"
+#import "AIRGoogleMapPMTile.h"
 #import "AIRGoogleMapPolygon.h"
 #import "AIRGoogleMapPolyline.h"
-#import "AIRGoogleMapCircle.h"
-#import "AIRGoogleMapHeatmap.h"
 #import "AIRGoogleMapUrlTile.h"
 #import "AIRGoogleMapWMSTile.h"
-#import "AIRGoogleMapOverlay.h"
+#import "RCTConvert+AirMap.h"
 #import <GoogleMaps/GoogleMaps.h>
 #import <MapKit/MapKit.h>
-#import <React/UIView+React.h>
 #import <React/RCTBridge.h>
-#import "RCTConvert+AirMap.h"
+#import <React/UIView+React.h>
 #import <objc/runtime.h>
 
 #ifdef HAVE_GOOGLE_MAPS_UTILS
+#import "GMUGeometryRenderer.h"
 #import "GMUKMLParser.h"
 #import "GMUPlacemark.h"
 #import "GMUPoint.h"
-#import "GMUGeometryRenderer.h"
-#define REQUIRES_GOOGLE_MAPS_UTILS(feature) do {} while (0)
+#define REQUIRES_GOOGLE_MAPS_UTILS(feature)                                    \
+  do {                                                                         \
+  } while (0)
 #else
 #define GMUKMLParser void
 #define GMUPlacemark void
-#define REQUIRES_GOOGLE_MAPS_UTILS(feature) do { \
- [NSException raise:@"ReactNativeMapsDependencyMissing" \
-             format:@"Use of " feature "requires Google-Maps-iOS-Utils, you  must install via CocoaPods to use this feature"]; \
-} while (0)
+#define REQUIRES_GOOGLE_MAPS_UTILS(feature)                                    \
+  do {                                                                         \
+    [NSException raise:@"ReactNativeMapsDependencyMissing"                     \
+                format:@"Use of " feature                                      \
+                        "requires Google-Maps-iOS-Utils, you  must install "   \
+                        "via CocoaPods to use this feature"];                  \
+  } while (0)
 #endif
 
-
 id regionAsJSON(MKCoordinateRegion region) {
   return @{
-           @"latitude": [NSNumber numberWithDouble:region.center.latitude],
-           @"longitude": [NSNumber numberWithDouble:region.center.longitude],
-           @"latitudeDelta": [NSNumber numberWithDouble:region.span.latitudeDelta],
-           @"longitudeDelta": [NSNumber numberWithDouble:region.span.longitudeDelta],
-           };
+    @"latitude" : [NSNumber numberWithDouble:region.center.latitude],
+    @"longitude" : [NSNumber numberWithDouble:region.center.longitude],
+    @"latitudeDelta" : [NSNumber numberWithDouble:region.span.latitudeDelta],
+    @"longitudeDelta" : [NSNumber numberWithDouble:region.span.longitudeDelta],
+  };
 }
 
 @interface AIRGoogleMap () <GMSIndoorDisplayDelegate>
 
 - (id)eventFromCoordinate:(CLLocationCoordinate2D)coordinate;
 
-@property (nonatomic, strong) NSMutableDictionary<NSNumber *, NSDictionary*> *origGestureRecognizersMeta;
+@property(nonatomic, strong)
+    NSMutableDictionary<NSNumber *, NSDictionary *> *origGestureRecognizersMeta;
 
 @end
 
-@implementation AIRGoogleMap
-{
+@implementation AIRGoogleMap {
   NSMutableArray<UIView *> *_reactSubviews;
   MKCoordinateRegion _initialRegion;
   MKCoordinateRegion _region;
@@ -93,8 +98,10 @@ - (instancetype)initWithMapId:(NSString *)mapId
     _overlays = [NSMutableArray array];
     _initialCamera = nil;
     _cameraProp = nil;
-    _initialRegion = MKCoordinateRegionMake(CLLocationCoordinate2DMake(0.0, 0.0), MKCoordinateSpanMake(0.0, 0.0));
-    _region = MKCoordinateRegionMake(CLLocationCoordinate2DMake(0.0, 0.0), MKCoordinateSpanMake(0.0, 0.0));
+    _initialRegion = MKCoordinateRegionMake(
+        CLLocationCoordinate2DMake(0.0, 0.0), MKCoordinateSpanMake(0.0, 0.0));
+    _region = MKCoordinateRegionMake(CLLocationCoordinate2DMake(0.0, 0.0),
+                                     MKCoordinateSpanMake(0.0, 0.0));
     _initialRegionSet = false;
     _initialCameraSet = false;
     _didLayoutSubviews = false;
@@ -120,9 +127,7 @@ - (instancetype) init {
 }
 
 - (void)dealloc {
-  [self removeObserver:self
-            forKeyPath:@"myLocation"
-               context:NULL];
+  [self removeObserver:self forKeyPath:@"myLocation" context:NULL];
 }
 
 - (id)eventFromCoordinate:(CLLocationCoordinate2D)coordinate {
@@ -130,52 +135,58 @@ - (id)eventFromCoordinate:(CLLocationCoordinate2D)coordinate {
   CGPoint touchPoint = [self.projection pointForCoordinate:coordinate];
 
   return @{
-           @"coordinate": @{
-               @"latitude": @(coordinate.latitude),
-               @"longitude": @(coordinate.longitude),
-               },
-           @"position": @{
-               @"x": @(touchPoint.x),
-               @"y": @(touchPoint.y),
-               },
-           };
+    @"coordinate" : @{
+      @"latitude" : @(coordinate.latitude),
+      @"longitude" : @(coordinate.longitude),
+    },
+    @"position" : @{
+      @"x" : @(touchPoint.x),
+      @"y" : @(touchPoint.y),
+    },
+  };
 }
 
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wobjc-missing-super-calls"
-- (void)insertReactSubview:(id<RCTComponent>)subview atIndex:(NSInteger)atIndex {
-  // Our desired API is to pass up markers/overlays as children to the mapview component.
-  // This is where we intercept them and do the appropriate underlying mapview action.
+- (void)insertReactSubview:(id<RCTComponent>)subview
+                   atIndex:(NSInteger)atIndex {
+  // Our desired API is to pass up markers/overlays as children to the mapview
+  // component. This is where we intercept them and do the appropriate
+  // underlying mapview action.
   if ([subview isKindOfClass:[AIRGoogleMapMarker class]]) {
-    AIRGoogleMapMarker *marker = (AIRGoogleMapMarker*)subview;
+    AIRGoogleMapMarker *marker = (AIRGoogleMapMarker *)subview;
     marker.realMarker.map = self;
     [self.markers addObject:marker];
   } else if ([subview isKindOfClass:[AIRGoogleMapPolygon class]]) {
-    AIRGoogleMapPolygon *polygon = (AIRGoogleMapPolygon*)subview;
+    AIRGoogleMapPolygon *polygon = (AIRGoogleMapPolygon *)subview;
     polygon.polygon.map = self;
     [self.polygons addObject:polygon];
   } else if ([subview isKindOfClass:[AIRGoogleMapPolyline class]]) {
-    AIRGoogleMapPolyline *polyline = (AIRGoogleMapPolyline*)subview;
+    AIRGoogleMapPolyline *polyline = (AIRGoogleMapPolyline *)subview;
     polyline.polyline.map = self;
     [self.polylines addObject:polyline];
   } else if ([subview isKindOfClass:[AIRGoogleMapCircle class]]) {
-    AIRGoogleMapCircle *circle = (AIRGoogleMapCircle*)subview;
+    AIRGoogleMapCircle *circle = (AIRGoogleMapCircle *)subview;
     circle.circle.map = self;
     [self.circles addObject:circle];
   } else if ([subview isKindOfClass:[AIRGoogleMapUrlTile class]]) {
-    AIRGoogleMapUrlTile *tile = (AIRGoogleMapUrlTile*)subview;
+    AIRGoogleMapUrlTile *tile = (AIRGoogleMapUrlTile *)subview;
+    tile.tileLayer.map = self;
+    [self.tiles addObject:tile];
+  } else if ([subview isKindOfClass:[AIRGoogleMapPMTile class]]) {
+    AIRGoogleMapPMTile *tile = (AIRGoogleMapPMTile *)subview;
     tile.tileLayer.map = self;
     [self.tiles addObject:tile];
   } else if ([subview isKindOfClass:[AIRGoogleMapWMSTile class]]) {
-    AIRGoogleMapWMSTile *tile = (AIRGoogleMapWMSTile*)subview;
+    AIRGoogleMapWMSTile *tile = (AIRGoogleMapWMSTile *)subview;
     tile.tileLayer.map = self;
     [self.tiles addObject:tile];
   } else if ([subview isKindOfClass:[AIRGoogleMapOverlay class]]) {
-    AIRGoogleMapOverlay *overlay = (AIRGoogleMapOverlay*)subview;
+    AIRGoogleMapOverlay *overlay = (AIRGoogleMapOverlay *)subview;
     overlay.overlay.map = self;
     [self.overlays addObject:overlay];
-  } else if ([subview isKindOfClass:[AIRGoogleMapHeatmap class]]){
-    AIRGoogleMapHeatmap *heatmap = (AIRGoogleMapHeatmap*)subview;
+  } else if ([subview isKindOfClass:[AIRGoogleMapHeatmap class]]) {
+    AIRGoogleMapHeatmap *heatmap = (AIRGoogleMapHeatmap *)subview;
     heatmap.heatmap.map = self;
     [self.heatmaps addObject:heatmap];
   } else {
@@ -184,46 +195,49 @@ - (void)insertReactSubview:(id<RCTComponent>)subview atIndex:(NSInteger)atIndex
       [self insertReactSubview:(UIView *)childSubviews[i] atIndex:atIndex];
     }
   }
-  [_reactSubviews insertObject:(UIView *)subview atIndex:(NSUInteger) atIndex];
+  [_reactSubviews insertObject:(UIView *)subview atIndex:(NSUInteger)atIndex];
 }
 #pragma clang diagnostic pop
 
-
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wobjc-missing-super-calls"
 - (void)removeReactSubview:(id<RCTComponent>)subview {
-  // similarly, when the children are being removed we have to do the appropriate
-  // underlying mapview action here.
+  // similarly, when the children are being removed we have to do the
+  // appropriate underlying mapview action here.
   if ([subview isKindOfClass:[AIRGoogleMapMarker class]]) {
-    AIRGoogleMapMarker *marker = (AIRGoogleMapMarker*)subview;
+    AIRGoogleMapMarker *marker = (AIRGoogleMapMarker *)subview;
     marker.realMarker.map = nil;
     [self.markers removeObject:marker];
   } else if ([subview isKindOfClass:[AIRGoogleMapPolygon class]]) {
-    AIRGoogleMapPolygon *polygon = (AIRGoogleMapPolygon*)subview;
+    AIRGoogleMapPolygon *polygon = (AIRGoogleMapPolygon *)subview;
     polygon.polygon.map = nil;
     [self.polygons removeObject:polygon];
   } else if ([subview isKindOfClass:[AIRGoogleMapPolyline class]]) {
-    AIRGoogleMapPolyline *polyline = (AIRGoogleMapPolyline*)subview;
+    AIRGoogleMapPolyline *polyline = (AIRGoogleMapPolyline *)subview;
     polyline.polyline.map = nil;
     [self.polylines removeObject:polyline];
   } else if ([subview isKindOfClass:[AIRGoogleMapCircle class]]) {
-    AIRGoogleMapCircle *circle = (AIRGoogleMapCircle*)subview;
+    AIRGoogleMapCircle *circle = (AIRGoogleMapCircle *)subview;
     circle.circle.map = nil;
     [self.circles removeObject:circle];
   } else if ([subview isKindOfClass:[AIRGoogleMapUrlTile class]]) {
-    AIRGoogleMapUrlTile *tile = (AIRGoogleMapUrlTile*)subview;
+    AIRGoogleMapUrlTile *tile = (AIRGoogleMapUrlTile *)subview;
+    tile.tileLayer.map = nil;
+    [self.tiles removeObject:tile];
+  } else if ([subview isKindOfClass:[AIRGoogleMapPMTile class]]) {
+    AIRGoogleMapPMTile *tile = (AIRGoogleMapPMTile *)subview;
     tile.tileLayer.map = nil;
     [self.tiles removeObject:tile];
   } else if ([subview isKindOfClass:[AIRGoogleMapWMSTile class]]) {
-    AIRGoogleMapWMSTile *tile = (AIRGoogleMapWMSTile*)subview;
+    AIRGoogleMapWMSTile *tile = (AIRGoogleMapWMSTile *)subview;
     tile.tileLayer.map = nil;
     [self.tiles removeObject:tile];
   } else if ([subview isKindOfClass:[AIRGoogleMapOverlay class]]) {
-    AIRGoogleMapOverlay *overlay = (AIRGoogleMapOverlay*)subview;
+    AIRGoogleMapOverlay *overlay = (AIRGoogleMapOverlay *)subview;
     overlay.overlay.map = nil;
     [self.overlays removeObject:overlay];
-  } else if ([subview isKindOfClass:[AIRGoogleMapHeatmap class]]){
-    AIRGoogleMapHeatmap *heatmap = (AIRGoogleMapHeatmap*)subview;
+  } else if ([subview isKindOfClass:[AIRGoogleMapHeatmap class]]) {
+    AIRGoogleMapHeatmap *heatmap = (AIRGoogleMapHeatmap *)subview;
     heatmap.heatmap.map = nil;
     [self.heatmaps removeObject:heatmap];
   } else {
@@ -335,22 +349,26 @@ - (void)didPrepareMap {
 }
 
 - (void)mapViewDidFinishTileRendering {
-  if (self.onMapLoaded) self.onMapLoaded(@{});
+  if (self.onMapLoaded)
+    self.onMapLoaded(@{});
 }
 
 - (BOOL)didTapMarker:(GMSMarker *)marker {
   AIRGMSMarker *airMarker = (AIRGMSMarker *)marker;
 
-  id event = @{@"action": @"marker-press",
-               @"id": airMarker.identifier ?: @"unknown",
-               @"coordinate": @{
-                   @"latitude": @(airMarker.position.latitude),
-                   @"longitude": @(airMarker.position.longitude)
-                   }
-               };
+  id event = @{
+    @"action" : @"marker-press",
+    @"id" : airMarker.identifier ?: @"unknown",
+    @"coordinate" : @{
+      @"latitude" : @(airMarker.position.latitude),
+      @"longitude" : @(airMarker.position.longitude)
+    }
+  };
 
-  if (airMarker.onPress) airMarker.onPress(event);
-  if (self.onMarkerPress) self.onMarkerPress(event);
+  if (airMarker.onPress)
+    airMarker.onPress(event);
+  if (self.onMarkerPress)
+    self.onMarkerPress(event);
 
   // TODO: not sure why this is necessary
   [self setSelectedMarker:marker];
@@ -361,62 +379,80 @@ - (BOOL)didTapMarker:(GMSMarker *)marker {
 - (void)didTapPolyline:(GMSOverlay *)polyline {
   AIRGMSPolyline *airPolyline = (AIRGMSPolyline *)polyline;
 
-  id event = @{@"action": @"polyline-press",
-               @"id": airPolyline.identifier ?: @"unknown",
-               };
+  id event = @{
+    @"action" : @"polyline-press",
+    @"id" : airPolyline.identifier ?: @"unknown",
+  };
 
-   if (airPolyline.onPress) airPolyline.onPress(event);
+  if (airPolyline.onPress)
+    airPolyline.onPress(event);
 }
 
 - (void)didTapPolygon:(GMSOverlay *)polygon {
-    AIRGMSPolygon *airPolygon = (AIRGMSPolygon *)polygon;
+  AIRGMSPolygon *airPolygon = (AIRGMSPolygon *)polygon;
 
-    id event = @{@"action": @"polygon-press",
-                 @"id": airPolygon.identifier ?: @"unknown",
-                 };
+  id event = @{
+    @"action" : @"polygon-press",
+    @"id" : airPolygon.identifier ?: @"unknown",
+  };
 
-    if (airPolygon.onPress) airPolygon.onPress(event);
+  if (airPolygon.onPress)
+    airPolygon.onPress(event);
 }
 
 - (void)didTapAtCoordinate:(CLLocationCoordinate2D)coordinate {
-  if (!self.onPress) return;
+  if (!self.onPress)
+    return;
   self.onPress([self eventFromCoordinate:coordinate]);
 }
 
 - (void)didLongPressAtCoordinate:(CLLocationCoordinate2D)coordinate {
-  if (!self.onLongPress) return;
+  if (!self.onLongPress)
+    return;
   self.onLongPress([self eventFromCoordinate:coordinate]);
 }
 
-- (void)didChangeCameraPosition:(GMSCameraPosition *)position isGesture:(BOOL)isGesture{
-  id event = @{@"continuous": @YES,
-               @"region": regionAsJSON([AIRGoogleMap makeGMSCameraPositionFromMap:self andGMSCameraPosition:position]),
-               @"isGesture": [NSNumber numberWithBool:isGesture],
-               };
+- (void)didChangeCameraPosition:(GMSCameraPosition *)position
+                      isGesture:(BOOL)isGesture {
+  id event = @{
+    @"continuous" : @YES,
+    @"region" :
+        regionAsJSON([AIRGoogleMap makeGMSCameraPositionFromMap:self
+                                           andGMSCameraPosition:position]),
+    @"isGesture" : [NSNumber numberWithBool:isGesture],
+  };
 
-  if (self.onChange) self.onChange(event);
+  if (self.onChange)
+    self.onChange(event);
 }
 
 - (void)didTapPOIWithPlaceID:(NSString *)placeID
                         name:(NSString *)name
                     location:(CLLocationCoordinate2D)location {
-  id event = @{@"placeId": placeID,
-               @"name": name,
-               @"coordinate": @{
-                   @"latitude": @(location.latitude),
-                   @"longitude": @(location.longitude)
-                   }
-               };
+  id event = @{
+    @"placeId" : placeID,
+    @"name" : name,
+    @"coordinate" : @{
+      @"latitude" : @(location.latitude),
+      @"longitude" : @(location.longitude)
+    }
+  };
 
-  if (self.onPoiClick) self.onPoiClick(event);
+  if (self.onPoiClick)
+    self.onPoiClick(event);
 }
 
-- (void)idleAtCameraPosition:(GMSCameraPosition *)position  isGesture:(BOOL)isGesture{
-  id event = @{@"continuous": @NO,
-               @"region": regionAsJSON([AIRGoogleMap makeGMSCameraPositionFromMap:self andGMSCameraPosition:position]),
-               @"isGesture": [NSNumber numberWithBool:isGesture],
-               };
-  if (self.onChange) self.onChange(event);  // complete
+- (void)idleAtCameraPosition:(GMSCameraPosition *)position
+                   isGesture:(BOOL)isGesture {
+  id event = @{
+    @"continuous" : @NO,
+    @"region" :
+        regionAsJSON([AIRGoogleMap makeGMSCameraPositionFromMap:self
+                                           andGMSCameraPosition:position]),
+    @"isGesture" : [NSNumber numberWithBool:isGesture],
+  };
+  if (self.onChange)
+    self.onChange(event); // complete
 }
 
 - (void)setMapPadding:(UIEdgeInsets)mapPadding {
@@ -427,35 +463,29 @@ - (UIEdgeInsets)mapPadding {
   return self.padding;
 }
 
-- (void)setPaddingAdjustmentBehaviorString:(NSString *)str
-{
-  if ([str isEqualToString:@"never"])
-  {
+- (void)setPaddingAdjustmentBehaviorString:(NSString *)str {
+  if ([str isEqualToString:@"never"]) {
     self.paddingAdjustmentBehavior = kGMSMapViewPaddingAdjustmentBehaviorNever;
-  }
-  else if ([str isEqualToString:@"automatic"])
-  {
-    self.paddingAdjustmentBehavior = kGMSMapViewPaddingAdjustmentBehaviorAutomatic;
-  }
-  else //if ([str isEqualToString:@"always"]) <-- default
+  } else if ([str isEqualToString:@"automatic"]) {
+    self.paddingAdjustmentBehavior =
+        kGMSMapViewPaddingAdjustmentBehaviorAutomatic;
+  } else // if ([str isEqualToString:@"always"]) <-- default
   {
     self.paddingAdjustmentBehavior = kGMSMapViewPaddingAdjustmentBehaviorAlways;
   }
 }
 
-- (NSString *)paddingAdjustmentBehaviorString
-{
-  switch (self.paddingAdjustmentBehavior)
-  {
-    case kGMSMapViewPaddingAdjustmentBehaviorNever:
-      return @"never";
-    case kGMSMapViewPaddingAdjustmentBehaviorAutomatic:
-      return @"automatic";
-    case kGMSMapViewPaddingAdjustmentBehaviorAlways:
-      return @"always";
-
-    default:
-      return @"unknown";
+- (NSString *)paddingAdjustmentBehaviorString {
+  switch (self.paddingAdjustmentBehavior) {
+  case kGMSMapViewPaddingAdjustmentBehaviorNever:
+    return @"never";
+  case kGMSMapViewPaddingAdjustmentBehaviorAutomatic:
+    return @"automatic";
+  case kGMSMapViewPaddingAdjustmentBehaviorAlways:
+    return @"always";
+
+  default:
+    return @"unknown";
   }
 }
 
@@ -475,8 +505,10 @@ - (BOOL)zoomEnabled {
   return self.settings.zoomGestures;
 }
 
-- (void)setScrollDuringRotateOrZoomEnabled:(BOOL)enableScrollGesturesDuringRotateOrZoom {
-  self.settings.allowScrollGesturesDuringRotateOrZoom = enableScrollGesturesDuringRotateOrZoom;
+- (void)setScrollDuringRotateOrZoomEnabled:
+    (BOOL)enableScrollGesturesDuringRotateOrZoom {
+  self.settings.allowScrollGesturesDuringRotateOrZoom =
+      enableScrollGesturesDuringRotateOrZoom;
 }
 
 - (BOOL)scrollDuringRotateOrZoomEnabled {
@@ -484,11 +516,11 @@ - (BOOL)scrollDuringRotateOrZoomEnabled {
 }
 
 - (void)setZoomTapEnabled:(BOOL)zoomTapEnabled {
-    _zoomTapEnabled = zoomTapEnabled;
+  _zoomTapEnabled = zoomTapEnabled;
 }
 
 - (BOOL)zoomTapEnabled {
-    return _zoomTapEnabled;
+  return _zoomTapEnabled;
 }
 
 - (void)setRotateEnabled:(BOOL)rotateEnabled {
@@ -530,7 +562,8 @@ - (void)setShowsCompass:(BOOL)showsCompass {
 - (void)setCustomMapStyleString:(NSString *)customMapStyleString {
   NSError *error;
 
-  GMSMapStyle *style = [GMSMapStyle styleWithJSONString:customMapStyleString error:&error];
+  GMSMapStyle *style = [GMSMapStyle styleWithJSONString:customMapStyleString
+                                                  error:&error];
 
   if (!style) {
     NSLog(@"The style definition could not be loaded: %@", error);
@@ -560,11 +593,11 @@ - (BOOL)showsMyLocationButton {
 }
 
 - (void)setMinZoomLevel:(CGFloat)minZoomLevel {
-  [self setMinZoom:minZoomLevel maxZoom:self.maxZoom ];
+  [self setMinZoom:minZoomLevel maxZoom:self.maxZoom];
 }
 
 - (void)setMaxZoomLevel:(CGFloat)maxZoomLevel {
-  [self setMinZoom:self.minZoom maxZoom:maxZoomLevel ];
+  [self setMinZoom:self.minZoom maxZoom:maxZoomLevel];
 }
 
 - (void)setShowsIndoors:(BOOL)showsIndoors {
@@ -891,7 +924,8 @@ + (NSString *)GetIconUrl:(GMUPlacemark *) marker parser:(GMUKMLParser *) parser
 
   return marker.style.iconUrl;
 #else
-    REQUIRES_GOOGLE_MAPS_UTILS("GetIconUrl:parser:"); return @"";
+  REQUIRES_GOOGLE_MAPS_UTILS("GetIconUrl:parser:");
+  return @"";
 #endif
 }
 
@@ -917,13 +951,14 @@ - (void)setKmlSrc:(NSString *)kmlUrl {
   [parser parse];
 
   NSUInteger index = 0;
-  NSMutableArray *markers = [[NSMutableArray alloc]init];
+  NSMutableArray *markers = [[NSMutableArray alloc] init];
 
   for (GMUPlacemark *place in parser.placemarks) {
 
-    CLLocationCoordinate2D location =((GMUPoint *) place.geometry).coordinate;
+    CLLocationCoordinate2D location = ((GMUPoint *)place.geometry).coordinate;
 
-    AIRGoogleMapMarker *marker = (AIRGoogleMapMarker *)[[AIRGoogleMapMarkerManager alloc] view];
+    AIRGoogleMapMarker *marker =
+        (AIRGoogleMapMarker *)[[AIRGoogleMapMarkerManager alloc] view];
     if (!marker.bridge) {
       marker.bridge = _bridge;
     }
@@ -936,84 +971,86 @@ - (void)setKmlSrc:(NSString *)kmlUrl {
     marker.layer.backgroundColor = [UIColor clearColor].CGColor;
     marker.layer.position = CGPointZero;
 
-    [self insertReactSubview:(UIView *) marker atIndex:index];
+    [self insertReactSubview:(UIView *)marker atIndex:index];
 
-    [markers addObject:@{@"id": marker.identifier,
-                         @"title": marker.title,
-                         @"description": marker.subtitle,
-                         @"coordinate": @{
-                             @"latitude": @(location.latitude),
-                             @"longitude": @(location.longitude)
-                             }
-                         }];
+    [markers addObject:@{
+      @"id" : marker.identifier,
+      @"title" : marker.title,
+      @"description" : marker.subtitle,
+      @"coordinate" : @{
+        @"latitude" : @(location.latitude),
+        @"longitude" : @(location.longitude)
+      }
+    }];
 
     index++;
   }
 
-  id event = @{@"markers": markers};
-  if (self.onKmlReady) self.onKmlReady(event);
+  id event = @{@"markers" : markers};
+  if (self.onKmlReady)
+    self.onKmlReady(event);
 #else
-    REQUIRES_GOOGLE_MAPS_UTILS();
+  REQUIRES_GOOGLE_MAPS_UTILS();
 #endif
 }
 
-
-- (void) didChangeActiveBuilding: (nullable GMSIndoorBuilding *) building {
-    if (!building) {
-        if (!self.onIndoorBuildingFocused) {
-            return;
-        }
-        self.onIndoorBuildingFocused(@{
-            @"IndoorBuilding": @{
-                    @"activeLevelIndex": @0,
-                    @"underground": @false,
-                    @"levels": [[NSMutableArray alloc]init]
-            }
-        });
-    }
-    NSInteger i = 0;
-    NSMutableArray *arrayLevels = [[NSMutableArray alloc]init];
-    for (GMSIndoorLevel *level in building.levels) {
-        [arrayLevels addObject: @{
-            @"index": @(i),
-            @"name" : level.name,
-            @"shortName" : level.shortName,
-        }];
-        i++;
-    }
+- (void)didChangeActiveBuilding:(nullable GMSIndoorBuilding *)building {
+  if (!building) {
     if (!self.onIndoorBuildingFocused) {
-        return;
+      return;
     }
     self.onIndoorBuildingFocused(@{
-        @"IndoorBuilding": @{
-                @"activeLevelIndex": @(building.defaultLevelIndex),
-                @"underground": @(building.underground),
-                @"levels": arrayLevels
-        }
+      @"IndoorBuilding" : @{
+        @"activeLevelIndex" : @0,
+        @"underground" : @false,
+        @"levels" : [[NSMutableArray alloc] init]
+      }
     });
+  }
+  NSInteger i = 0;
+  NSMutableArray *arrayLevels = [[NSMutableArray alloc] init];
+  for (GMSIndoorLevel *level in building.levels) {
+    [arrayLevels addObject:@{
+      @"index" : @(i),
+      @"name" : level.name,
+      @"shortName" : level.shortName,
+    }];
+    i++;
+  }
+  if (!self.onIndoorBuildingFocused) {
+    return;
+  }
+  self.onIndoorBuildingFocused(@{
+    @"IndoorBuilding" : @{
+      @"activeLevelIndex" : @(building.defaultLevelIndex),
+      @"underground" : @(building.underground),
+      @"levels" : arrayLevels
+    }
+  });
 }
 
-- (void) didChangeActiveLevel: (nullable GMSIndoorLevel *)     level {
-    if (!self.onIndoorLevelActivated || !self.indoorDisplay  || !level) {
-        return;
+- (void)didChangeActiveLevel:(nullable GMSIndoorLevel *)level {
+  if (!self.onIndoorLevelActivated || !self.indoorDisplay || !level) {
+    return;
+  }
+  NSInteger i = 0;
+  for (GMSIndoorLevel *buildingLevel in self.indoorDisplay.activeBuilding
+           .levels) {
+    if (buildingLevel.name == level.name &&
+        buildingLevel.shortName == level.shortName) {
+      break;
     }
-    NSInteger i = 0;
-    for (GMSIndoorLevel *buildingLevel in self.indoorDisplay.activeBuilding.levels) {
-        if (buildingLevel.name == level.name && buildingLevel.shortName == level.shortName) {
-            break;
-        }
-        i++;
+    i++;
+  }
+  self.onIndoorLevelActivated(@{
+    @"IndoorLevel" : @{
+      @"activeLevelIndex" : @(i),
+      @"name" : level.name,
+      @"shortName" : level.shortName
     }
-    self.onIndoorLevelActivated(@{
-        @"IndoorLevel": @{
-                @"activeLevelIndex": @(i),
-                @"name": level.name,
-                @"shortName": level.shortName
-        }
-    });
+  });
 }
 
-
 @end
 
 #endif
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapPMTile.h b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapPMTile.h
new file mode 100644
index 0000000..20969d1
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapPMTile.h
@@ -0,0 +1,32 @@
+//
+//  AIRGoogleMapPMTile.h
+//
+//
+
+#ifdef HAVE_GOOGLE_MAPS
+
+#import <Foundation/Foundation.h>
+#import <GoogleMaps/GoogleMaps.h>
+#import "AIRGoogleMapPMTileOverlay.h"
+
+@interface AIRGoogleMapPMTile : UIView
+
+@property(nonatomic, strong) AIRGoogleMapPMTileOverlay *tileLayer;
+@property(nonatomic, copy) NSString *urlTemplate;
+@property(nonatomic, copy) NSString *styleURL;
+@property(nonatomic, assign) int zIndex;
+@property(nonatomic, assign) float opacity;
+@property(nonatomic, assign) BOOL doubleTileSize;
+@property(nonatomic, assign) BOOL isVector;
+@property(nonatomic, assign) NSInteger maximumZ;
+@property(nonatomic, assign) NSInteger minimumZ;
+@property(nonatomic, assign) NSInteger maximumNativeZ;
+@property(nonatomic, assign) NSInteger tileSize;
+@property(nonatomic, assign) BOOL flipY;
+@property(nonatomic, assign) BOOL offlineMode;
+@property(nonatomic, copy) NSString *tileCachePath;
+@property(nonatomic, assign) NSInteger tileCacheMaxAge;
+
+@end
+
+#endif
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapPMTile.m b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapPMTile.m
new file mode 100644
index 0000000..5ebc662
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapPMTile.m
@@ -0,0 +1,172 @@
+//
+//  AIRGoogleMapPMTile.m
+//
+//
+
+#ifdef HAVE_GOOGLE_MAPS
+
+#import "AIRGoogleMapPMTile.h"
+#import "AIRGoogleMapPMTileOverlay.h"
+#import "RCTConvert+GMSMapViewType.h"
+#import <React/RCTConvert.h>
+
+@implementation AIRGoogleMapPMTile
+
+- (id)init {
+  self = [super init];
+  _opacity = 1;
+  return self;
+}
+- (void)setZIndex:(int)zIndex {
+  _zIndex = zIndex;
+  _tileLayer.zIndex = zIndex;
+}
+
+- (void)setFlipY:(BOOL)flipY {
+  _flipY = flipY;
+  if (self.tileLayer && flipY) {
+    [self.tileLayer setFlipY:_flipY];
+    [self.tileLayer clearTileCache];
+  }
+}
+
+- (void)setIsVector:(BOOL)isVector {
+  _isVector = isVector;
+  if (self.tileLayer && isVector) {
+    [self.tileLayer setIsVector:_isVector];
+    [self.tileLayer clearTileCache];
+    [self updateTileLayer];
+  }
+}
+
+- (void)setTileSize:(NSInteger)tileSize {
+  _tileSize = tileSize;
+  if (self.tileLayer && tileSize) {
+    self.tileLayer.tileSize = tileSize;
+    [self.tileLayer clearTileCache];
+  }
+}
+
+- (void)setMinimumZ:(NSInteger)minimumZ {
+  _minimumZ = minimumZ;
+  if (self.tileLayer && minimumZ) {
+    [self.tileLayer setMinimumZ:_minimumZ];
+    [self.tileLayer clearTileCache];
+  }
+}
+
+- (void)setMaximumZ:(NSInteger)maximumZ {
+  _maximumZ = maximumZ;
+  if (self.tileLayer && maximumZ) {
+    [self.tileLayer setMaximumZ:_maximumZ];
+    [self.tileLayer clearTileCache];
+  }
+}
+
+- (void)setMaximumNativeZ:(NSInteger)maximumNativeZ {
+  _maximumNativeZ = maximumNativeZ;
+  if (self.tileLayer && maximumNativeZ) {
+    [self.tileLayer setMaximumNativeZ:maximumNativeZ];
+    [self.tileLayer clearTileCache];
+  }
+}
+
+- (void)setDoubleTileSize:(BOOL)doubleTileSize {
+  if (_tileSize)
+    return;
+  // float screenTileSize =
+  //    [[UIScreen mainScreen] bounds].size.width * [UIScreen mainScreen].scale;
+  // float screenTileSize = 256 * [UIScreen mainScreen].scale;
+  // これが正解
+  float screenTileSize =
+      [[UIScreen mainScreen] nativeBounds].size.width / 256 * 256;
+
+  _tileSize = doubleTileSize ? screenTileSize / 2 : screenTileSize;
+  // NSLog(@"tileSizeA %ld", _tileSize);
+  if (self.tileLayer) {
+    self.tileLayer.tileSize = _tileSize;
+    //[self.tileLayer setTileSize:_tileSize];//上のじゃないとできない？
+    [self.tileLayer setDoubleTileSize:doubleTileSize];
+    [self.tileLayer clearTileCache];
+  }
+}
+
+- (void)setOpacity:(float)opacity {
+  _opacity = opacity;
+  if (self.tileLayer) {
+    [self.tileLayer setOpacity:opacity];
+    [self.tileLayer clearTileCache];
+  }
+}
+
+- (void)setUrlTemplate:(NSString *)urlTemplate {
+
+  _urlTemplate = urlTemplate;
+
+  AIRGoogleMapPMTileOverlay *tile = [[AIRGoogleMapPMTileOverlay alloc] init];
+  [tile setTemplate:urlTemplate];
+  [tile setFlipY:_flipY];
+  [tile setMaximumZ:_maximumZ];
+  [tile setMinimumZ:_minimumZ];
+  [tile setTileSize:_tileSize];
+  [tile setDoubleTileSize:_doubleTileSize];
+  [tile setMaximumNativeZ:_maximumNativeZ];
+  [tile setZIndex:_zIndex];
+  [tile setOpacity:_opacity];
+  [tile setOfflineMode:_offlineMode];
+  [tile setTileCachePath:_tileCachePath];
+  [tile setTileCacheMaxAge:_tileCacheMaxAge];
+  [tile setStyleURL:_styleURL];
+  [tile setIsVector:_isVector];
+  _tileLayer = tile;
+  [self updateTileLayer];
+}
+
+- (void)setStyleURL:(NSString *)styleURL {
+  // NSLog(@"setStyleURL %@", styleURL);
+  _styleURL = styleURL;
+  if (self.tileLayer) {
+
+    self.tileLayer.styleURL = [NSURL URLWithString:_styleURL];
+    [self.tileLayer clearTileCache];
+    [self updateTileLayer];
+  }
+}
+
+- (void)setOfflineMode:(BOOL)offlineMode {
+  _offlineMode = offlineMode;
+  if (self.tileLayer && offlineMode && self.urlTemplate) {
+    self.tileLayer.offlineMode =
+        _offlineMode && ![self.urlTemplate containsString:@"file://"];
+    [self.tileLayer clearTileCache];
+    [self updateTileLayer];
+  }
+}
+
+- (void)setTileCachePath:(NSString *)tileCachePath {
+  if (!tileCachePath)
+    return;
+  _tileCachePath = tileCachePath;
+  self.tileLayer.tileCachePath = [NSURL URLWithString:_tileCachePath];
+  [self.tileLayer clearTileCache];
+  [self updateTileLayer];
+}
+
+- (void)setTileCacheMaxAge:(NSInteger)tileCacheMaxAge {
+  _tileCacheMaxAge = tileCacheMaxAge;
+  if (self.tileLayer && tileCacheMaxAge) {
+    self.tileLayer.tileCacheMaxAge = _tileCacheMaxAge;
+    [self.tileLayer clearTileCache];
+  }
+}
+
+- (void)updateTileLayer {
+
+  if (_urlTemplate && _tileCachePath) {
+
+    [self.tileLayer updateTileLayer];
+  }
+}
+@end
+
+#endif
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapPMTileManager.h b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapPMTileManager.h
new file mode 100644
index 0000000..da08699
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapPMTileManager.h
@@ -0,0 +1,14 @@
+//
+//  AIRGoogleMapPMTileManager.h
+//
+//
+
+#ifdef HAVE_GOOGLE_MAPS
+
+#import <Foundation/Foundation.h>
+#import <React/RCTViewManager.h>
+
+@interface AIRGoogleMapPMTileManager : RCTViewManager
+@end
+
+#endif
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapPMTileManager.m b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapPMTileManager.m
new file mode 100644
index 0000000..c89f26d
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapPMTileManager.m
@@ -0,0 +1,40 @@
+//
+//  AIRGoogleMapPMTileManager.m
+//
+//
+
+#ifdef HAVE_GOOGLE_MAPS
+
+#import "AIRGoogleMapPMTileManager.h"
+#import "AIRGoogleMapPMTile.h"
+
+@interface AIRGoogleMapPMTileManager ()
+
+@end
+
+@implementation AIRGoogleMapPMTileManager
+
+RCT_EXPORT_MODULE()
+
+- (UIView *)view {
+  AIRGoogleMapPMTile *tileLayer = [AIRGoogleMapPMTile new];
+  return tileLayer;
+}
+
+RCT_EXPORT_VIEW_PROPERTY(urlTemplate, NSString)
+RCT_EXPORT_VIEW_PROPERTY(zIndex, int)
+RCT_EXPORT_VIEW_PROPERTY(opacity, float)
+RCT_EXPORT_VIEW_PROPERTY(doubleTileSize, BOOL)
+RCT_EXPORT_VIEW_PROPERTY(maximumZ, NSInteger)
+RCT_EXPORT_VIEW_PROPERTY(minimumZ, NSInteger)
+RCT_EXPORT_VIEW_PROPERTY(maximumNativeZ, NSInteger)
+RCT_EXPORT_VIEW_PROPERTY(flipY, BOOL)
+RCT_EXPORT_VIEW_PROPERTY(offlineMode, BOOL)
+RCT_EXPORT_VIEW_PROPERTY(tileCachePath, NSString)
+RCT_EXPORT_VIEW_PROPERTY(tileCacheMaxAge, NSInteger)
+RCT_EXPORT_VIEW_PROPERTY(styleURL, NSString)
+RCT_EXPORT_VIEW_PROPERTY(isVector, BOOL)
+
+@end
+
+#endif
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapPMTileOverlay.h b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapPMTileOverlay.h
new file mode 100644
index 0000000..49710a5
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapPMTileOverlay.h
@@ -0,0 +1,36 @@
+//
+//  AIRGoogleMapPMTile.h
+//
+//
+
+#ifdef HAVE_GOOGLE_MAPS
+
+#import <GoogleMaps/GoogleMaps.h>
+#import "PMTiles/PMTiles.h"
+#import "VectorTile/VectorTile.pbobjc.h"
+#import "VectorTile/LineData.h"
+#import "VectorTile/PolygonData.h"
+#import "VectorTile/VectorSource.h"
+#import "VectorTile/StyleManager.h"
+
+@interface AIRGoogleMapPMTileOverlay : GMSSyncTileLayer
+- (void)updateTileLayer;
+@property(nonatomic, strong) PMTiles *pmtiles;
+@property(nonatomic, strong) StyleManager *styleManager;
+@property(nonatomic, copy) NSString *template;
+@property(nonatomic, copy) NSString *styleURL;
+@property(nonatomic, assign) NSInteger maximumZ;
+@property(nonatomic, assign) NSInteger minimumZ;
+@property(nonatomic) NSInteger maximumNativeZ;
+@property(nonatomic, assign) NSInteger tileSize;
+@property(nonatomic) NSInteger doubleTileSize;
+@property(nonatomic, assign) BOOL flipY;
+@property(nonatomic, assign) BOOL offlineMode;
+@property(nonatomic, assign) BOOL isVector;
+@property(nonatomic, copy) NSString *tileCachePath;
+@property(nonatomic, assign) NSInteger tileCacheMaxAge;
+@property(nonatomic, assign) NSInteger tileType;
+@property(nonatomic, strong) NSDictionary *metadata;
+@end
+
+#endif
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapPMTileOverlay.m b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapPMTileOverlay.m
new file mode 100644
index 0000000..a94b80d
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapPMTileOverlay.m
@@ -0,0 +1,1265 @@
+//
+//  AIRGoogleMapPMTile.m
+//
+//
+
+#ifdef HAVE_GOOGLE_MAPS
+
+#import "AIRGoogleMapPMTileOverlay.h"
+#import "VectorTile/UIColor+Hex.h"
+
+@implementation AIRGoogleMapPMTileOverlay
+- (id)init {
+  self = [super init];
+  return self;
+}
+
+- (void)updateTileLayer {
+
+  // templateに.pbfが含まれている場合は、そのまま使用する
+  if ([self.template containsString:@".pbf"]) {
+    self.tileType = 0;
+  } else if (self.offlineMode) {
+    if (self.isVector) {
+      // NSLog(@"offline and vector");
+      self.tileType = 1;
+    } else {
+      self.tileType = 2;
+    }
+  } else {
+    PMTiles *pmtiles = [[PMTiles alloc] initWithURL:self.template];
+    self.pmtiles = pmtiles;
+    headerv3 header = [pmtiles fetchHeader];
+    if (header.tile_entries_count == 0) {
+      // NSLog(@"Error fetching header");
+      self.tileType = -1;
+    } else {
+      self.tileType = header.tile_type;
+      // //タイルサイズはpmtilesがラスタの場合はheaderから取得しても良いかも
+    }
+  }
+  // self.tileSize = 256;
+  if (self.tileType == 0 || self.tileType == 1) {
+    self.metadata = [self loadMetadata];
+    self.styleManager =
+        [[StyleManager alloc] initWithURLTemplate:self.template
+                                    tileCachePath:self.tileCachePath
+                                         styleURL:self.styleURL
+                                      offlineMode:self.offlineMode];
+  }
+}
+
+- (NSDictionary *)loadMetadata {
+  NSError *error = nil;
+  // ローカルのメタデータを取得。なければネットワークから取得して保存
+
+  NSURL *metadataURL;
+  NSString *metadataPath =
+      [NSString stringWithFormat:@"%@/metadata.json", self.tileCachePath];
+  metadataURL = [NSURL URLWithString:metadataPath];
+
+  NSString *metadataString =
+      [NSString stringWithContentsOfFile:metadataURL
+                                encoding:NSUTF8StringEncoding
+                                   error:&error];
+  if (metadataString) {
+    // NSLog(@"metadata loaded from cache");
+    return (NSDictionary *)[NSJSONSerialization
+        JSONObjectWithData:[metadataString
+                               dataUsingEncoding:NSUTF8StringEncoding]
+                   options:NSJSONReadingMutableContainers
+                     error:nil];
+  } else {
+    NSDictionary *metadata = [self.pmtiles fetchMetadata];
+    if (metadata) {
+      // NSDictionaryをJSONデータに変換して保存
+      NSData *jsonData = [NSJSONSerialization dataWithJSONObject:metadata
+                                                         options:0
+                                                           error:&error];
+      if (jsonData) {
+        // ディレクトリの存在確認と作成
+        NSFileManager *fileManager = [NSFileManager defaultManager];
+        NSURL *directoryURL;
+        directoryURL = [NSURL URLWithString:self.tileCachePath];
+
+        if (![fileManager fileExistsAtPath:[directoryURL path]]) {
+          NSError *dirError = nil;
+          [fileManager createDirectoryAtPath:[directoryURL path]
+                 withIntermediateDirectories:YES
+                                  attributes:nil
+                                       error:&dirError];
+          if (dirError) {
+            // NSLog(@"Failed to create directory: %@",
+            //       dirError.localizedDescription);
+            return metadata; // ディレクトリ作成に失敗した場合、メタデータを返して終了
+          }
+        }
+
+        NSError *writeError = nil;
+        BOOL success = [jsonData writeToFile:[metadataURL path]
+                                     options:NSDataWritingAtomic
+                                       error:&writeError];
+        if (!success) {
+          // NSLog(@"Failed to write metadata to file: %@",
+          //       writeError.localizedDescription);
+        } else {
+          // NSLog(@"Metadata successfully saved to %@", metadataPath);
+        }
+      } else {
+        // NSLog(@"Failed to serialize metadata to JSON: %@",
+        //       error.localizedDescription);
+      }
+      return metadata;
+    } else {
+      // NSLog(@"Failed to fetch metadata from network.");
+      return @{};
+    }
+  }
+}
+
+- (UIImage *)tileForX:(NSUInteger)x y:(NSUInteger)y zoom:(NSUInteger)zoom {
+  // if (!self.offlineMode && self.tileType == -1) {
+  //   return kGMSTileLayerNoTile;
+  // }
+
+  if (self.maximumZ && zoom > self.maximumZ) {
+    return kGMSTileLayerNoTile;
+  }
+
+  if (self.minimumZ && zoom < self.minimumZ) {
+    return kGMSTileLayerNoTile;
+  }
+
+  int drawType = 0; // 0:original 1:high-resolution 2:overzoom
+
+  if (zoom > self.maximumNativeZ && !self.doubleTileSize) {
+    drawType = 2;
+  } else if (zoom > self.maximumNativeZ - 1 && self.doubleTileSize) {
+    drawType = 2;
+  } else if (zoom <= self.maximumNativeZ && !self.doubleTileSize) {
+    drawType = 0;
+  } else if (zoom <= self.maximumNativeZ - 1 && self.doubleTileSize) {
+    drawType = 1;
+  }
+  // NSLog(@"drawType %d,%ld,%ld", drawType, zoom, self.maximumNativeZ);
+  NSData *data;
+  if (drawType == 0 || drawType == 1) {
+    data = [self getTile:zoom x:x y:y];
+  } else if (drawType == 2) {
+    data = [self drawOverZoomTile:zoom x:x y:y minZ:self.maximumNativeZ];
+  }
+  // if (!data && self.offlineMode && self.tileCachePath) {
+  //   NSInteger zoomLevelToStart = (zoom > self.maximumZ) ? self.maximumZ :
+  //   zoom; NSInteger minimumZoomToSearch = self.minimumZ >= zoomLevelToStart -
+  //   3
+  //                                       ? self.minimumZ
+  //                                       : zoomLevelToStart - 3;
+  //   data = [self drawOverZoomTile:(NSUInteger)zoomLevelToStart
+  //                               x:(NSUInteger)x
+  //                               y:(NSUInteger)y
+  //                            minZ:minimumZoomToSearch];
+  // }
+  if (data) {
+    UIImage *img = [[UIImage alloc] initWithData:data];
+    return img;
+  }
+  return kGMSTileLayerNoTile;
+}
+
+- (NSData *)getTile:(NSUInteger)zoom x:(NSUInteger)x y:(NSUInteger)y {
+
+  // NSString *url = self.offlineMode && self.tileCachePath ?  [NSString
+  // stringWithFormat:@"%@%@",self.tileCachePath,@"/{z}/{x}/{y}.png"] :
+  // self.template; NSLog(@"%@", url);
+  if (self.flipY == YES) {
+    y = (1 << zoom) - y - 1;
+  }
+
+  NSString *urlXYZ = self.template;
+  urlXYZ = [urlXYZ
+      stringByReplacingOccurrencesOfString:@"{x}"
+                                withString:[NSString stringWithFormat:@"%ld",
+                                                                      (long)x]];
+  urlXYZ = [urlXYZ
+      stringByReplacingOccurrencesOfString:@"{y}"
+                                withString:[NSString stringWithFormat:@"%ld",
+                                                                      (long)y]];
+  urlXYZ = [urlXYZ
+      stringByReplacingOccurrencesOfString:@"{z}"
+                                withString:[NSString
+                                               stringWithFormat:@"%ld",
+                                                                (long)zoom]];
+  NSString *tileCacheXYZ =
+      [NSString stringWithFormat:@"%@/%ld/%ld/%ld", self.tileCachePath,
+                                 (long)zoom, (long)x, (long)y];
+  NSURL *tileCacheFileDirectory =
+      [NSURL URLWithString:[NSString stringWithFormat:@"%@/%ld/%ld/",
+                                                      self.tileCachePath,
+                                                      (long)zoom, (long)x]];
+  NSURL *tileCacheFilePath =
+      [NSURL URLWithString:(self.tileCachePath ? tileCacheXYZ : urlXYZ)];
+
+  NSString *url =
+      self.offlineMode && self.tileCachePath ? tileCacheXYZ : urlXYZ;
+  NSData *data;
+
+  data = [self readTileImage:tileCacheFilePath];
+  // if (data) {
+  //   NSLog(@"read from cache %d %d %d", zoom, x, y);
+  //   // if ([self doesFileNeedRefresh:tileCacheFilePath
+  //   //                    withMaxAge:self.tileCacheMaxAge]) {
+  //   //   data = nil;
+  //   //   // NSLog(@"!cache expired");
+  //   // }
+  // }
+  if (!data) {
+    if (self.tileType == 0 || self.tileType == 1) {
+      data = [self fetchVectorTile:zoom x:x y:y];
+    } else if (self.tileType == 2) {
+      data = [self fetchRasterTile:zoom x:x y:y];
+    }
+
+    if (!data) {
+      return nil;
+    } else {
+      // NSLog(@"fetch from url %d %d %d", zoom, x, y);
+      if (self.tileCachePath) {
+        [self writeTileImage:tileCacheFileDirectory
+            withTileCacheFilePath:tileCacheFilePath
+                     withTileData:data];
+        // NSLog(@"write to cache");
+      }
+      return data;
+    }
+  } else {
+    return data;
+  }
+}
+
+- (NSData *)getPbfTileWithZ:(NSUInteger)zoom x:(NSUInteger)x y:(NSUInteger)y {
+  __block NSData *data = nil;
+  __block NSError *error = nil;
+
+  NSString *urlString = [self.template
+      stringByReplacingOccurrencesOfString:@"{z}"
+                                withString:[NSString
+                                               stringWithFormat:@"%ld",
+                                                                (long)zoom]];
+  urlString = [urlString
+      stringByReplacingOccurrencesOfString:@"{x}"
+                                withString:[NSString stringWithFormat:@"%ld",
+                                                                      (long)x]];
+  urlString = [urlString
+      stringByReplacingOccurrencesOfString:@"{y}"
+                                withString:[NSString stringWithFormat:@"%ld",
+                                                                      (long)y]];
+  NSURL *url = [NSURL URLWithString:urlString];
+
+  // 非同期タスクを待機するためのセマフォを作成
+  dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
+
+  // NSURLSessionConfigurationを作成し、タイムアウトを設定
+  NSURLSessionConfiguration *config =
+      [NSURLSessionConfiguration defaultSessionConfiguration];
+  config.timeoutIntervalForRequest =
+      1; // タイムアウト時間を秒単位で設定（例：10秒）
+
+  NSURLSession *session = [NSURLSession sessionWithConfiguration:config];
+
+  NSURLSessionDataTask *task =
+      [session dataTaskWithURL:url
+             completionHandler:^(NSData *_Nullable receivedData,
+                                 NSURLResponse *_Nullable response,
+                                 NSError *_Nullable receivedError) {
+               data = receivedData;
+               error = receivedError;
+               // 非同期タスクが完了したことをセマフォに通知
+               dispatch_semaphore_signal(semaphore);
+             }];
+
+  [task resume];
+
+  // タイムアウト時間を設定してセマフォで待機
+  dispatch_time_t timeoutTime =
+      dispatch_time(DISPATCH_TIME_NOW,
+                    (int64_t)(config.timeoutIntervalForRequest * NSEC_PER_SEC));
+  long result = dispatch_semaphore_wait(semaphore, timeoutTime);
+
+  if (result != 0) {
+    // タイムアウトが発生した場合
+    // NSLog(@"Request timed out.");
+    [task cancel]; // タスクをキャンセル
+    return nil;
+  }
+
+  if (error) {
+    // NSLog(@"Error fetching PBF tile: %@", [error localizedDescription]);
+    return nil;
+  } else {
+    return data;
+  }
+}
+
+- (NSData *)readPbfData:(NSURL *)url {
+  NSError *error = nil;
+
+  // ファイルからBase64エンコードされた文字列を読み込む
+  NSString *base64String =
+      [NSString stringWithContentsOfURL:url
+                               encoding:NSUTF8StringEncoding
+                                  error:&error];
+  // エラーチェック
+  if (error) {
+    // NSLog(@"Failed to read file from URL: %@", url);
+    return nil;
+  }
+  // Base64デコードを行い、NSDataを取得
+  NSData *data = [[NSData alloc]
+      initWithBase64EncodedString:base64String
+                          options:NSDataBase64DecodingIgnoreUnknownCharacters];
+  if (!data) {
+    // NSLog(@"Failed to decode Base64 string");
+    return nil;
+  }
+  return data;
+}
+
+- (NSData *)readTileImage:(NSURL *)url {
+  NSError *error = nil;
+  NSData *data = [NSData dataWithContentsOfURL:url
+                                       options:NSDataReadingUncached
+                                         error:&error];
+  if (error) {
+    // NSLog(@"!!!! %@", [error localizedDescription]);
+    return nil;
+  } else {
+    return data;
+  }
+}
+
+- (CGContextRef)createTransparentImageContext {
+  // 透明な256x256の画像を生成. 1はscale factor.
+  UIGraphicsBeginImageContextWithOptions(CGSizeMake(512, 512), NO, 1);
+  CGContextRef context = UIGraphicsGetCurrentContext();
+
+  return context;
+}
+
+// 属性（Attributes）を出力し、対応する色と値を返す関数
+NSDictionary *getFeatureAttributes(Tile_Layer *layer, Tile_Feature *feature) {
+  NSMutableDictionary *attributeDict = [NSMutableDictionary dictionary];
+  NSUInteger tagsCount = feature.tagsArray_Count;
+  for (NSUInteger i = 0; i < tagsCount; i += 2) {
+    NSUInteger keyIndex = [feature.tagsArray valueAtIndex:i];
+    NSUInteger valueIndex = [feature.tagsArray valueAtIndex:i + 1];
+
+    NSString *key = layer.keysArray[keyIndex];
+    Tile_Value *valueObj = layer.valuesArray[valueIndex];
+    NSString *valueStr = @"";
+    if (valueObj.hasStringValue) {
+      valueStr = valueObj.stringValue;
+    } else if (valueObj.hasIntValue) {
+      valueStr = [NSString stringWithFormat:@"%lld", valueObj.intValue];
+    } else if (valueObj.hasFloatValue) {
+      valueStr = [NSString stringWithFormat:@"%.1f", valueObj.floatValue];
+    } else if (valueObj.hasDoubleValue) {
+      valueStr = [NSString stringWithFormat:@"%.1f", valueObj.doubleValue];
+    }
+    // 他の型についても同様に処理
+
+    [attributeDict setObject:valueStr forKey:key];
+  }
+  return attributeDict;
+}
+
+// getValueToUse 関数の定義
+NSString *getLabelToUse(NSDictionary *attributes, NSString *key) {
+  return attributes[key] ?: @""; // デフォルト値として空文字列を使用
+}
+
+NSMutableDictionary *colorMapping;
+// getColorToUse 関数の定義
+UIColor *getColorToUse(NSDictionary *attributes, NSString *key) {
+  NSString *valueToUse =
+      attributes[key] ?: @""; // デフォルト値として空文字列を使用
+
+  // すでに colorMapping で色が割り当てられている場合は、その色を使う
+  if (colorMapping[valueToUse]) {
+    return colorMapping[valueToUse];
+  }
+
+  // ランダムな色を生成
+  float red = (float)arc4random_uniform(256) / 255.0;
+  float green = (float)arc4random_uniform(256) / 255.0;
+  float blue = (float)arc4random_uniform(256) / 255.0;
+  UIColor *randomColor = [UIColor colorWithRed:red
+                                         green:green
+                                          blue:blue
+                                         alpha:1.0];
+  // valueToUseに基づいて色を選択
+  if ([valueToUse isEqualToString:@"28"]) {
+    randomColor = [UIColor colorWithRed:0.53 green:0.81 blue:0.98 alpha:1.0];
+  }
+  // colorMapping に保存
+  colorMapping[valueToUse] = randomColor;
+
+  return randomColor;
+}
+
+- (NSMutableArray *)createMultiPointData:(GPBUInt32Array *)geometryArray
+                              withExtent:(float)extent {
+
+  NSMutableArray *points = [NSMutableArray array];
+  int index = 0;
+  float cursorX = 0;
+  float cursorY = 0;
+  float scaleFactor = 512 / extent;
+  while (index < geometryArray.count) {
+    uint32_t commandInteger = [geometryArray valueAtIndex:index++];
+    uint32_t commandId = commandInteger & 0x7;
+    uint32_t commandCount = commandInteger >> 3;
+
+    if (commandId == 1) { // MoveTo
+      for (NSUInteger i = 0; i < commandCount; ++i) {
+        int32_t dx = (int32_t)(([geometryArray valueAtIndex:index++] >> 1) ^
+                               (-([geometryArray valueAtIndex:index - 1] & 1)));
+        int32_t dy = (int32_t)(([geometryArray valueAtIndex:index++] >> 1) ^
+                               (-([geometryArray valueAtIndex:index - 1] & 1)));
+
+        cursorX += dx;
+        cursorY += dy;
+
+        float scaledX = cursorX * scaleFactor;
+        float scaledY = cursorY * scaleFactor;
+
+        NSValue *pointValue =
+            [NSValue valueWithCGPoint:CGPointMake(scaledX, scaledY)];
+        [points addObject:pointValue];
+      }
+    }
+  }
+  return points;
+}
+
+- (LineData *)createLinePath:(GPBUInt32Array *)geometryArray
+                  withExtent:(float)extent {
+  UIBezierPath *path = [UIBezierPath bezierPath];
+  NSMutableArray<NSValue *> *points = [NSMutableArray array];
+  NSUInteger index = 0;
+  float cursorX = 0;
+  float cursorY = 0;
+  float totalLength = 0;
+  float scaleFactor = 512 / extent;
+
+  while (index < geometryArray.count) {
+    uint32_t commandInteger = [geometryArray valueAtIndex:index++];
+    uint32_t commandId = commandInteger & 0x7;
+    uint32_t commandCount = commandInteger >> 3;
+
+    for (NSUInteger i = 0; i < commandCount; ++i) {
+      int32_t dx = (int32_t)(([geometryArray valueAtIndex:index++] >> 1) ^
+                             (-([geometryArray valueAtIndex:index - 1] & 1)));
+      int32_t dy = (int32_t)(([geometryArray valueAtIndex:index++] >> 1) ^
+                             (-([geometryArray valueAtIndex:index - 1] & 1)));
+
+      cursorX += dx;
+      cursorY += dy;
+
+      float scaledX = cursorX * scaleFactor;
+      float scaledY = cursorY * scaleFactor;
+
+      if (commandId == 2) { // LineTo
+        [path addLineToPoint:CGPointMake(scaledX, scaledY)];
+      } else if (commandId == 1) { // MoveTo
+        [path moveToPoint:CGPointMake(scaledX, scaledY)];
+      }
+
+      [points
+          addObject:[NSValue valueWithCGPoint:CGPointMake(scaledX, scaledY)]];
+    }
+  }
+
+  // Compute the midpoint along the length of the line
+  float midLength = totalLength / 2;
+  CGPoint labelPoint = CGPointMake(0, 0);
+  float lengths[geometryArray.count / 2]; // Approximate allocation
+  NSUInteger lengthIndex = 0;
+
+  for (NSUInteger i = 1; i < lengthIndex; i++) {
+    float segmentLength =
+        hypotf(points[i].CGPointValue.x - points[i - 1].CGPointValue.x,
+               points[i].CGPointValue.y - points[i - 1].CGPointValue.y);
+    totalLength += segmentLength;
+    lengths[lengthIndex++] = totalLength;
+
+    if (lengths[i] >= midLength) {
+      float ratio =
+          (midLength - lengths[i - 1]) / (lengths[i] - lengths[i - 1]);
+      labelPoint.x =
+          points[i - 1].CGPointValue.x +
+          ratio * (points[i].CGPointValue.x - points[i - 1].CGPointValue.x);
+      labelPoint.y =
+          points[i - 1].CGPointValue.y +
+          ratio * (points[i].CGPointValue.y - points[i - 1].CGPointValue.y);
+      break;
+    }
+  }
+
+  return [[LineData alloc] initWithPath:path
+                                centerX:labelPoint.x
+                                centerY:labelPoint.y];
+}
+
+- (PolygonData *)createPolygonPath:(GPBUInt32Array *)geometryArray
+                        withExtent:(float)extent {
+  UIBezierPath *path = [UIBezierPath bezierPath];
+  NSUInteger index = 0;
+  NSUInteger pointCount = 0;
+  float cursorX = 0;
+  float cursorY = 0;
+  float scaleFactor = 512 / extent; // タイルのサイズ / extent
+  float totalX = 0;
+  float totalY = 0;
+
+  while (index < geometryArray.count) {
+    uint32_t commandInteger = [geometryArray valueAtIndex:index++];
+    uint32_t commandId = commandInteger & 0x7;   // lower 3 bits
+    uint32_t commandCount = commandInteger >> 3; // higher bits
+
+    switch (commandId) {
+    case 1: // MoveTo
+      for (NSUInteger i = 0; i < commandCount; ++i) {
+        int32_t dx = (int32_t)(([geometryArray valueAtIndex:index++] >> 1) ^
+                               (-([geometryArray valueAtIndex:index - 1] & 1)));
+        int32_t dy = (int32_t)(([geometryArray valueAtIndex:index++] >> 1) ^
+                               (-([geometryArray valueAtIndex:index - 1] & 1)));
+
+        cursorX += dx;
+        cursorY += dy;
+
+        float scaledX = cursorX * scaleFactor;
+        float scaledY = cursorY * scaleFactor;
+
+        // CGContextMoveToPoint(context, scaledX, scaledY);
+        [path moveToPoint:CGPointMake(scaledX, scaledY)];
+        totalX += scaledX;
+        totalY += scaledY;
+        pointCount++;
+      }
+      break;
+
+    case 2: // LineTo
+      for (NSUInteger i = 0; i < commandCount; ++i) {
+        int32_t dx = (int32_t)(([geometryArray valueAtIndex:index++] >> 1) ^
+                               (-([geometryArray valueAtIndex:index - 1] & 1)));
+        int32_t dy = (int32_t)(([geometryArray valueAtIndex:index++] >> 1) ^
+                               (-([geometryArray valueAtIndex:index - 1] & 1)));
+
+        cursorX += dx;
+        cursorY += dy;
+
+        float scaledX = cursorX * scaleFactor;
+        float scaledY = cursorY * scaleFactor;
+        [path addLineToPoint:CGPointMake(scaledX, scaledY)];
+        // CGContextAddLineToPoint(context, scaledX, scaledY);
+
+        totalX += scaledX;
+        totalY += scaledY;
+        pointCount++;
+      }
+      break;
+
+    case 7: // ClosePath
+            // CGContextClosePath(context);
+      [path closePath];
+      break;
+
+    default:
+      // Unknown command, handle error
+      break;
+    }
+  }
+
+  // ポリゴンの中心点を計算
+  float centerX = totalX / pointCount;
+  float centerY = totalY / pointCount;
+
+  return [[PolygonData alloc] initWithPath:path
+                                   centerX:centerX
+                                   centerY:centerY];
+}
+
+- (VectorSource *)getVectorSource:(NSString *)layerName
+                      fromSources:(NSArray *)sources {
+  for (VectorSource *source in sources) {
+    if ([source.name isEqualToString:layerName]) {
+      return source;
+    }
+  }
+  return nil; // または適当な例外を投げる
+}
+
+- (NSString *)computeDynamicColor:(NSArray *)colors
+                       attributes:(NSDictionary *)attributes {
+  if (colors.count > 0 && [colors[0] isEqualToString:@"match"]) {
+    NSArray *conditions =
+        [colors subarrayWithRange:NSMakeRange(2, colors.count - 3)];
+    NSArray *getFieldList = colors[1];
+    NSString *field = getFieldList[1];
+    NSString *value = attributes[field] ? attributes[field] : @"";
+    NSString *defaultColor = colors.lastObject;
+
+    for (int i = 0; i < conditions.count; i += 2) {
+      NSString *key = conditions[i];
+      if ([key isEqualToString:value]) {
+        return conditions[i + 1];
+      }
+    }
+    return defaultColor;
+  }
+  return nil;
+}
+
+- (NSString *)evaluateExpression:(NSArray *)expression
+                      attributes:(NSDictionary<NSString *, NSString *> *)attributes {
+  if (expression == nil || [expression count] == 0) {
+    return @"";
+  }
+  
+  NSString *operator = expression[0];
+  
+  if ([operator isEqualToString:@"get"] && [expression count] >= 2) {
+    // ["get", "field_name"]
+    NSString *fieldName = expression[1];
+    return attributes[fieldName] ? attributes[fieldName] : @"";
+  } else if ([operator isEqualToString:@"slice"] && [expression count] >= 4) {
+    // ["slice", string_expression, start, end]
+    NSString *sourceValue;
+    id sourceExpr = expression[1];
+    if ([sourceExpr isKindOfClass:[NSString class]]) {
+      sourceValue = (NSString *)sourceExpr;
+    } else if ([sourceExpr isKindOfClass:[NSArray class]]) {
+      sourceValue = [self evaluateExpression:(NSArray *)sourceExpr attributes:attributes];
+    } else {
+      sourceValue = @"";
+    }
+    
+    @try {
+      NSInteger start = [expression[2] integerValue];
+      NSInteger end = [expression[3] integerValue];
+      
+      if (start < 0) start = 0;
+      if (end > [sourceValue length]) end = [sourceValue length];
+      if (start > end) return @"";
+      
+      NSRange range = NSMakeRange(start, end - start);
+      return [sourceValue substringWithRange:range];
+    } @catch (NSException *exception) {
+      return @"";
+    }
+  }
+  
+  return @"";
+}
+
+- (BOOL)checkFilter:(NSArray *)filter
+         attributes:(NSDictionary<NSString *, NSString *> *)attributes {
+  if (filter == nil)
+    return YES;
+  if ([filter count] == 3) {
+    // NSLog(@"##filter: %@", filter);
+    NSString *op = filter[0];
+    
+    // Evaluate the left operand (could be a string key or an expression)
+    id leftOperand = filter[1];
+    NSString *leftValue;
+    if ([leftOperand isKindOfClass:[NSString class]]) {
+      leftValue = attributes[leftOperand] ? attributes[leftOperand] : @"";
+    } else if ([leftOperand isKindOfClass:[NSArray class]]) {
+      leftValue = [self evaluateExpression:(NSArray *)leftOperand attributes:attributes];
+    } else {
+      leftValue = @"";
+    }
+    
+    // Evaluate the right operand
+    id rightOperand = filter[2];
+    NSString *rightValue;
+    if ([rightOperand isKindOfClass:[NSString class]]) {
+      rightValue = (NSString *)rightOperand;
+    } else if ([rightOperand isKindOfClass:[NSArray class]]) {
+      rightValue = [self evaluateExpression:(NSArray *)rightOperand attributes:attributes];
+    } else {
+      rightValue = [NSString stringWithFormat:@"%@", rightOperand];
+    }
+
+    if ([op isEqualToString:@"=="]) {
+      return [leftValue isEqualToString:rightValue];
+    } else if ([op isEqualToString:@"!="]) {
+      return ![leftValue isEqualToString:rightValue];
+    } else if ([op isEqualToString:@">"]) {
+      return [leftValue floatValue] > [rightValue floatValue];
+    } else if ([op isEqualToString:@">="]) {
+      return [leftValue floatValue] >= [rightValue floatValue];
+    } else if ([op isEqualToString:@"<"]) {
+      return [leftValue floatValue] < [rightValue floatValue];
+    } else if ([op isEqualToString:@"<="]) {
+      return [leftValue floatValue] <= [rightValue floatValue];
+    } else if ([op isEqualToString:@"in"]) {
+      return [rightValue containsString:leftValue];
+    } else if ([op isEqualToString:@"!in"]) {
+      return ![rightValue containsString:leftValue];
+    } else if ([op isEqualToString:@"has"]) {
+      return leftValue.length > 0;
+    } else if ([op isEqualToString:@"!has"]) {
+      return leftValue.length == 0;
+    }
+  }
+  return NO;
+}
+
+- (void)applyStyleToContext:(CGContextRef)context
+             withStyleLayer:(NSDictionary *)styleLayer
+                  andSource:(VectorSource *)source {
+
+  NSString *type = styleLayer[@"type"];
+  if ([type isEqualToString:@"circle"]) {
+    // Drawing settings for circle
+    for (FeatureData *feature in source.features) {
+      if (![feature.geometry isKindOfClass:[NSMutableArray class]])
+        continue;
+      NSDictionary *attributes = feature.attributes;
+      if (![self checkFilter:styleLayer[@"filter"] attributes:attributes])
+        continue;
+
+      NSDictionary *paint =
+          styleLayer[@"paint"]; // Explicitly define the paint dictionary
+      NSString *circleColor = @"#ff0000"; // Default circle color
+
+      if ([paint[@"circle-color"] isKindOfClass:[NSString class]]) {
+        circleColor = paint[@"circle-color"];
+      } else if ([paint[@"circle-color"] isKindOfClass:[NSArray class]]) {
+        NSString *dynamicColor =
+            [self computeDynamicColor:paint[@"circle-color"]
+                           attributes:attributes];
+        if (dynamicColor) {
+          circleColor = dynamicColor;
+        }
+      }
+
+      UIColor *fillColor = [UIColor
+          colorWithHexString:circleColor]; // Now using the existing method
+      CGContextSetFillColorWithColor(context, fillColor.CGColor);
+
+      NSString *outlineColor = circleColor; // Default to circleColor
+      if (paint[@"circle-stroke-color"] &&
+          [paint[@"circle-stroke-color"] isKindOfClass:[NSString class]]) {
+        outlineColor = paint[@"circle-stroke-color"];
+      }
+
+      CGFloat strokeWidth = paint[@"circle-stroke-width"]
+                                ? [paint[@"circle-stroke-width"] floatValue]
+                                : 0;
+      UIColor *strokeColor = [UIColor
+          colorWithHexString:outlineColor]; // Now using the existing method
+      CGContextSetStrokeColorWithColor(context, strokeColor.CGColor);
+      CGContextSetLineWidth(context, strokeWidth);
+
+      CGFloat circleRadius =
+          paint[@"circle-radius"] ? [paint[@"circle-radius"] floatValue] : 5;
+
+      // Using NSValue to wrap CGPoint as PointData type is not shown
+      NSArray<NSValue *> *points = (NSArray<NSValue *> *)feature.geometry;
+      // NSLog(@"points %@", points);
+      for (NSValue *pointValue in points) {
+        CGPoint point = [pointValue CGPointValue];
+        float scaledX = point.x;
+        float scaledY = point.y;
+
+        CGRect circleRect =
+            CGRectMake(scaledX - circleRadius, scaledY - circleRadius,
+                       circleRadius * 2, circleRadius * 2);
+        CGContextFillEllipseInRect(context, circleRect); // Draw the circle
+
+        if (strokeWidth > 0) {
+          CGContextStrokeEllipseInRect(context,
+                                       circleRect); // Draw the outline
+        }
+      }
+    }
+  } else if ([type isEqualToString:@"line"]) {
+    for (FeatureData *feature in source.features) {
+      NSDictionary *attributes = feature.attributes;
+      if (![self checkFilter:styleLayer[@"filter"] attributes:attributes])
+        continue;
+      NSDictionary *paint =
+          styleLayer[@"paint"]; // Explicitly define the paint dictionary
+      UIBezierPath *path = nil;
+
+      if ([feature.geometry isKindOfClass:[LineData class]]) {
+        LineData *lineData = (LineData *)feature.geometry;
+        path = lineData.path;
+      } else if ([feature.geometry isKindOfClass:[PolygonData class]]) {
+        PolygonData *polygonData = (PolygonData *)feature.geometry;
+        path = polygonData.path;
+      } else {
+        continue; // Skip to the next iteration if geometry is neither
+                  // LineData
+        // nor PolygonData
+      }
+
+      NSString *lineColor = @"#ff0000"; // Default line color is red
+      if ([paint[@"line-color"] isKindOfClass:[NSString class]]) {
+        lineColor = paint[@"line-color"];
+      } else if ([paint[@"line-color"] isKindOfClass:[NSArray class]]) {
+        NSString *dynamicColor = [self computeDynamicColor:paint[@"line-color"]
+                                                attributes:attributes];
+        if (dynamicColor) {
+          lineColor = dynamicColor;
+        }
+      }
+
+      CGFloat lineWidth = paint[@"line-width"]
+                              ? [paint[@"line-width"] floatValue]
+                              : 1.0; // Default line width is 1
+
+      CGContextRef context = UIGraphicsGetCurrentContext();
+      CGContextSetStrokeColorWithColor(
+          context, [UIColor colorWithHexString:lineColor]
+                       .CGColor); // Use existing colorWithHexString method
+      CGContextSetLineWidth(context, lineWidth);
+
+      CGContextAddPath(context, path.CGPath);
+      CGContextDrawPath(context, kCGPathStroke);
+    }
+  } else if ([type isEqualToString:@"fill"]) {
+    for (FeatureData *feature in source.features) {
+      if (![feature.geometry isKindOfClass:[PolygonData class]])
+        continue;
+      NSDictionary *attributes = feature.attributes;
+      if (![self checkFilter:styleLayer[@"filter"] attributes:attributes])
+        continue;
+      NSDictionary *paint =
+          styleLayer[@"paint"]; // Explicitly define the paint dictionary
+
+      if (![feature.geometry isKindOfClass:[PolygonData class]]) {
+        continue; // Skip to the next iteration if geometry is not PolygonData
+      }
+
+      PolygonData *polygonData = (PolygonData *)feature.geometry;
+
+      NSString *fillColorString =
+          @"#ffffffff"; // Default fill color is white with full opacity
+      if ([paint[@"fill-color"] isKindOfClass:[NSString class]]) {
+        fillColorString = paint[@"fill-color"];
+      } else if ([paint[@"fill-color"] isKindOfClass:[NSArray class]]) {
+        NSString *dynamicColor = [self computeDynamicColor:paint[@"fill-color"]
+                                                attributes:attributes];
+        if (dynamicColor) {
+          fillColorString = dynamicColor;
+        }
+      }
+
+      UIColor *fillColor = [UIColor colorWithHexString:fillColorString];
+
+      CGFloat fillOpacity = paint[@"fill-opacity"]
+                                ? [paint[@"fill-opacity"] floatValue]
+                                : 1.0; // Default fill opacity is 1
+
+      CGContextRef context = UIGraphicsGetCurrentContext();
+
+      CGContextSetFillColorWithColor(context, fillColor.CGColor);
+      CGContextSetStrokeColorWithColor(context, fillColor.CGColor);
+
+      CGContextSetLineWidth(context, 1.0); // Default stroke width is 1
+
+      NSString *outlineColorString = fillColorString;
+      if (paint[@"fill-outline-color"] &&
+          [paint[@"fill-outline-color"] isKindOfClass:[NSString class]]) {
+        outlineColorString = paint[@"fill-outline-color"];
+      }
+
+      UIColor *outlineColor = [UIColor colorWithHexString:outlineColorString];
+      CGContextSetStrokeColorWithColor(context, outlineColor.CGColor);
+
+      CGContextAddPath(context, polygonData.path.CGPath);
+      CGContextSetAlpha(context, fillOpacity);
+      CGContextDrawPath(context, kCGPathEOFillStroke);
+      CGContextSetAlpha(context, 1);
+    }
+  } else if ([type isEqualToString:@"symbol"]) {
+    // 既に描画されたラベルの位置を保存する配列
+    NSMutableArray<NSValue *> *drawnLabelsRects = [NSMutableArray array];
+
+    CGFloat labelSize =
+        [styleLayer[@"layout"][@"text-size"] floatValue] ?: 16.0;
+    UIColor *labelHaloColor =
+        [UIColor colorWithHexString:styleLayer[@"paint"][@"text-halo-color"]]
+            ?: [UIColor whiteColor];
+    CGFloat labelHaloWidth =
+        [styleLayer[@"paint"][@"text-halo-width"] floatValue] ?: 0.0;
+    NSString *labelField = styleLayer[@"layout"][@"text-field"][1];
+
+    UIColor *labelColor =
+        [UIColor colorWithHexString:styleLayer[@"paint"][@"text-color"]]
+            ?: [UIColor blackColor];
+
+    for (FeatureData *feature in source.features) {
+      NSDictionary *attributes = feature.attributes;
+      if (![self checkFilter:styleLayer[@"filter"] attributes:attributes])
+        continue;
+      float X = 0;
+      float Y = 0;
+
+      if ([feature.geometry isKindOfClass:[NSArray class]]) {
+        NSArray<NSValue *> *multiPoints =
+            (NSArray<NSValue *> *)feature.geometry;
+        CGPoint firstPoint = [multiPoints[0] CGPointValue];
+        X = firstPoint.x;
+        Y = firstPoint.y;
+      } else if ([feature.geometry isKindOfClass:[LineData class]]) {
+        LineData *line = (LineData *)feature.geometry;
+        X = line.centerX;
+        Y = line.centerY;
+      } else if ([feature.geometry isKindOfClass:[PolygonData class]]) {
+        PolygonData *polygon = (PolygonData *)feature.geometry;
+        X = polygon.centerX;
+        Y = polygon.centerY;
+      }
+
+      NSString *label = attributes[labelField] ?: @"";
+
+      CGSize labelSizeCalc = [label sizeWithAttributes:@{
+        NSFontAttributeName : [UIFont systemFontOfSize:labelSize]
+      }];
+
+      float textWidth = labelSizeCalc.width;
+      float textHeight = labelSizeCalc.height;
+      float textX = X - textWidth / 2;
+      float textY = Y - textHeight / 2;
+
+      CGRect newLabelRect = CGRectMake(textX, textY, textWidth, textHeight);
+
+      BOOL shouldDraw = YES;
+      for (NSValue *rectValue in drawnLabelsRects) {
+        CGRect existingRect = [rectValue CGRectValue];
+        if (CGRectIntersectsRect(existingRect, newLabelRect)) {
+          shouldDraw = NO;
+          break;
+        }
+      }
+
+      if (shouldDraw) {
+        CGContextSetLineWidth(context, labelHaloWidth);
+        CGContextSetStrokeColorWithColor(context, labelHaloColor.CGColor);
+        CGContextSetTextDrawingMode(context, kCGTextStroke);
+        [label drawAtPoint:CGPointMake(X, Y)
+            withAttributes:@{
+              NSFontAttributeName : [UIFont systemFontOfSize:labelSize],
+              NSForegroundColorAttributeName : labelHaloColor
+            }];
+
+        CGContextSetTextDrawingMode(context, kCGTextFill);
+        [label drawAtPoint:CGPointMake(X, Y)
+            withAttributes:@{
+              NSFontAttributeName : [UIFont systemFontOfSize:labelSize],
+              NSForegroundColorAttributeName : labelColor
+            }];
+
+        [drawnLabelsRects addObject:[NSValue valueWithCGRect:newLabelRect]];
+      }
+    }
+  } else {
+    return;
+  }
+}
+
+- (NSData *)fetchRasterTile:(NSUInteger)zoom x:(NSUInteger)x y:(NSUInteger)y {
+  NSData *data = [self.pmtiles getTileWithZ:zoom x:x y:y];
+
+  return data;
+}
+
+- (NSData *)fetchVectorTile:(NSUInteger)zoom x:(NSUInteger)x y:(NSUInteger)y {
+  NSError *error;
+
+  NSURL *tileCacheFileDirectory =
+      [NSURL URLWithString:[NSString stringWithFormat:@"%@/%ld/%ld/",
+                                                      self.tileCachePath,
+                                                      (long)zoom, (long)x]];
+  NSURL *pbfCacheFilePath = [NSURL
+      URLWithString:[NSString stringWithFormat:@"%@/%ld/%ld/%ld.pbf",
+                                               self.tileCachePath, (long)zoom,
+                                               (long)x, (long)y]];
+
+  NSData *pbfData;
+  pbfData = [self readPbfData:pbfCacheFilePath];
+
+  if (!pbfData) {
+    if (self.offlineMode) {
+      return nil;
+    }
+    if (self.tileType == 0) {
+      pbfData = [self getPbfTileWithZ:zoom x:x y:y];
+    } else if (self.tileType == 1) {
+      pbfData = [self.pmtiles getTileWithZ:zoom x:x y:y];
+    }
+
+    if (!pbfData) {
+      return nil;
+    }
+    // NSLog(@"fetch from url %d %d %d", zoom, x, y);
+    if (self.tileCachePath) {
+      [self writePbfData:tileCacheFileDirectory
+          withPbfCacheFilePath:pbfCacheFilePath
+                   withPbfData:pbfData];
+    }
+  }
+
+  // NSLog(@"data %@", data);
+  Tile *decodedTile = [Tile parseFromData:pbfData error:&error];
+
+  if (error) {
+    // NSLog(@"Failed to decode Tile: %@", error);
+    return nil;
+  }
+  NSArray *styleLayers = [self.styleManager getStyleLayers];
+  if (styleLayers.count == 0) {
+    // NSLog(@"スタイルレイヤーが見つかりません");
+    styleLayers =
+        [self.styleManager getDefaultStyleLayersWithMetadata:self.metadata];
+  }
+  NSMutableArray *sources = [NSMutableArray array];
+  for (Tile_Layer *layer in decodedTile.layersArray) {
+    float extent = layer.extent;
+    NSMutableArray *features = [NSMutableArray array];
+    for (Tile_Feature *feature in layer.featuresArray) {
+      NSDictionary *attributes = getFeatureAttributes(layer, feature);
+      id geometry = nil;
+
+      if (feature.type == Tile_GeomType_Point) {
+        geometry = [self createMultiPointData:feature.geometryArray
+                                   withExtent:extent];
+      } else if (feature.type == Tile_GeomType_Linestring) {
+        geometry = [self createLinePath:feature.geometryArray
+                             withExtent:extent];
+      } else if (feature.type == Tile_GeomType_Polygon) {
+        geometry = [self createPolygonPath:feature.geometryArray
+                                withExtent:extent];
+      }
+
+      if (geometry != nil) {
+        FeatureData *featureData =
+            [[FeatureData alloc] initWithAttributes:attributes
+                                           geometry:geometry];
+        [features addObject:featureData];
+      }
+
+      // NSString *key = @"基本分類C";
+      // NSString *labelToUse = getLabelToUse(attributes, key);
+      // UIColor *colorToUse = getColorToUse(attributes, key);
+    }
+    if (features.count > 0) {
+      // NSLog(@"!!create source: %@", layer.name);
+      VectorSource *newSource = [[VectorSource alloc] initWithName:layer.name
+                                                          features:features];
+      [sources addObject:newSource];
+    }
+  }
+
+  CGContextRef context = [self createTransparentImageContext];
+
+  for (NSDictionary *styleLayer in styleLayers) {
+    NSString *sourceLayer = styleLayer[@"source-layer"];
+
+    VectorSource *source = [self getVectorSource:sourceLayer
+                                     fromSources:sources];
+
+    if (source == nil)
+      continue;
+
+    NSNumber *minzoom = styleLayer[@"minzoom"];
+    NSNumber *maxzoom = styleLayer[@"maxzoom"];
+
+    // nilの場合のデフォルト値をセット
+    double actualMinzoom = (minzoom != nil) ? [minzoom doubleValue] : 0;
+    double actualMaxzoom = (maxzoom != nil) ? [maxzoom doubleValue] : 22;
+
+    // NSLog(@"zoom %f %f %d", actualMinzoom, actualMaxzoom, zoom);
+    if (actualMinzoom > zoom || actualMaxzoom < zoom)
+      continue;
+
+    [self applyStyleToContext:context
+               withStyleLayer:styleLayer
+                    andSource:source];
+  }
+
+  // 描画したイメージを取得
+  UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
+  UIGraphicsEndImageContext();
+
+  // UIImageからNSDataへ変換（PNG形式）
+  NSData *tileData = UIImagePNGRepresentation(image);
+
+  if (error) {
+    // NSLog(@"%@", [error localizedDescription]);
+    return nil;
+  } else {
+    return tileData;
+  }
+}
+
+- (void)writePbfData:(NSURL *)tileCacheFileDirectory
+    withPbfCacheFilePath:(NSURL *)pbfCacheFilePath
+             withPbfData:(NSData *)data {
+
+  NSError *error;
+
+  // NSDataをBase64エンコードしたNSStringを取得
+  NSString *base64String = [data base64EncodedStringWithOptions:0];
+
+  if (![[NSFileManager defaultManager]
+          fileExistsAtPath:[tileCacheFileDirectory path]]) {
+    [[NSFileManager defaultManager]
+              createDirectoryAtPath:[tileCacheFileDirectory path]
+        withIntermediateDirectories:YES
+                         attributes:nil
+                              error:&error];
+    if (error) {
+      // NSLog(@"Directory creation Error: %@", error.localizedDescription);
+      error = nil;
+    }
+  }
+
+  // Base64エンコードされた文字列を直接ファイルに書き込む
+  [base64String writeToFile:[pbfCacheFilePath path]
+                 atomically:YES
+                   encoding:NSUTF8StringEncoding
+                      error:&error];
+
+  if (error) {
+    // NSLog(@"File writing Error: %@", error.localizedDescription);
+    return;
+  }
+
+  // NSLog(@"tileCache SAVED tile %@", [pbfCacheFilePath path]);
+}
+
+- (void)writeTileImage:(NSURL *)tileCacheFileDirectory
+    withTileCacheFilePath:(NSURL *)tileCacheFilePath
+             withTileData:(NSData *)data {
+  NSError *error;
+
+  if (![[NSFileManager defaultManager]
+          fileExistsAtPath:[tileCacheFileDirectory path]]) {
+    [[NSFileManager defaultManager]
+              createDirectoryAtPath:[tileCacheFileDirectory path]
+        withIntermediateDirectories:YES
+                         attributes:nil
+                              error:&error];
+    if (error) {
+      // NSLog(@"Error: %@", error);
+      return;
+    }
+  }
+  [[NSFileManager defaultManager] createFileAtPath:[tileCacheFilePath path]
+                                          contents:data
+                                        attributes:nil];
+  // NSLog(@"tileCache SAVED tile %@", [tileCacheFilePath path]);
+}
+
+- (NSData *)getHalfTile:(NSData *)data
+             leftColumn:(NSUInteger)leftColumn
+                 topRow:(NSUInteger)topRow {
+  UIImage *image = [UIImage imageWithData:data];
+  CGRect originalRect = CGRectMake(0, 0, image.size.width, image.size.height);
+
+  UIGraphicsBeginImageContext(originalRect.size);
+  {
+    CGRect drawRect = CGRectApplyAffineTransform(
+        originalRect, CGAffineTransformMakeScale(2, 2));
+    drawRect = CGRectApplyAffineTransform(
+        drawRect,
+        CGAffineTransformMakeTranslation(-image.size.width * leftColumn,
+                                         -image.size.height * topRow));
+    [image drawInRect:drawRect];
+    image = UIGraphicsGetImageFromCurrentImageContext();
+  }
+  UIGraphicsEndImageContext();
+
+  return UIImagePNGRepresentation(image);
+}
+
+// - (NSData *)drawOverZoomTile:(NSUInteger)zoom x:(NSUInteger)x
+// y:(NSUInteger)y
+// {
+//   if (zoom <= self.maximumNativeZ) {
+//     return [self getTile:zoom x:x y:y];
+//   }
+//   BOOL leftColumn = x % 2 == 0;
+//   BOOL topRow = y % 2 == 0;
+//   NSData *Data = [self drawOverZoomTile:(zoom - 1) x:(x / 2) y:(y / 2)];
+//   return [self getHalfTile:Data leftColumn:1 - leftColumn topRow:1 -
+//   topRow];
+// }
+
+- (NSData *)drawOverZoomTile:(NSUInteger)tryZ
+                           x:(NSUInteger)x
+                           y:(NSUInteger)y
+                        minZ:(NSInteger)minZ {
+  // NSLog(@"#$#$#$#$#$ %ld,%ld,%ld,%ld", tryZ,x,y,minZ);
+  if (tryZ <= minZ) {
+    return [self getTile:tryZ x:x y:y];
+
+  } else if (tryZ > minZ) {
+    NSData *Data = [self drawOverZoomTile:(tryZ - 1)
+                                        x:(x / 2)
+                                        y:(y / 2)
+                                     minZ:minZ];
+    if (!Data) {
+      return nil;
+    }
+    BOOL leftColumn = x % 2 == 0;
+    BOOL topRow = y % 2 == 0;
+    return [self getHalfTile:Data leftColumn:1 - leftColumn topRow:1 - topRow];
+
+  } else {
+    return nil;
+  }
+}
+
+- (BOOL)doesFileNeedRefresh:(NSURL *)tileCacheFilePath
+                 withMaxAge:(NSInteger)tileCacheMaxAge {
+  NSError *error;
+  NSFileManager *fileManager = [NSFileManager defaultManager];
+  NSDictionary *fileAttributes =
+      [fileManager attributesOfItemAtPath:[tileCacheFilePath path]
+                                    error:&error];
+  long long _lastUpdatedTime = [self.styleManager getLastUpdatedTime];
+
+  if (fileAttributes) {
+    NSDate *modificationDate = fileAttributes[NSFileModificationDate];
+
+    // NSLog(@"tileCacheFilePath %@", [tileCacheFilePath path]);
+    // NSLog(@"%ld   %ld", _lastUpdatedTime,
+    //       (long long)[modificationDate timeIntervalSince1970]);
+    if (_lastUpdatedTime >
+            (long long)[modificationDate timeIntervalSince1970] ||
+        _lastUpdatedTime == 0) {
+      // NSLog(@"!#!# style updated");
+      return YES;
+    }
+
+    if (modificationDate) {
+      if (-1 * (int)modificationDate.timeIntervalSinceNow > tileCacheMaxAge) {
+        // NSLog(@"!#!# cache expired");
+        return YES;
+      }
+    }
+  }
+
+  return NO;
+}
+
+@end
+
+#endif
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapURLTileManager.m b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapURLTileManager.m
index ee501d8..6851fd9 100644
--- a/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapURLTileManager.m
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapURLTileManager.m
@@ -8,7 +8,7 @@
 #import "AIRGoogleMapUrlTileManager.h"
 #import "AIRGoogleMapUrlTile.h"
 
-@interface AIRGoogleMapUrlTileManager()
+@interface AIRGoogleMapUrlTileManager ()
 
 @end
 
@@ -16,17 +16,23 @@ @implementation AIRGoogleMapUrlTileManager
 
 RCT_EXPORT_MODULE()
 
-- (UIView *)view
-{
+- (UIView *)view {
   AIRGoogleMapUrlTile *tileLayer = [AIRGoogleMapUrlTile new];
   return tileLayer;
 }
 
 RCT_EXPORT_VIEW_PROPERTY(urlTemplate, NSString)
 RCT_EXPORT_VIEW_PROPERTY(zIndex, int)
+RCT_EXPORT_VIEW_PROPERTY(opacity, float)
+RCT_EXPORT_VIEW_PROPERTY(tileSize, NSInteger)
+RCT_EXPORT_VIEW_PROPERTY(doubleTileSize, BOOL)
 RCT_EXPORT_VIEW_PROPERTY(maximumZ, NSInteger)
 RCT_EXPORT_VIEW_PROPERTY(minimumZ, NSInteger)
+RCT_EXPORT_VIEW_PROPERTY(maximumNativeZ, NSInteger)
 RCT_EXPORT_VIEW_PROPERTY(flipY, BOOL)
+RCT_EXPORT_VIEW_PROPERTY(offlineMode, BOOL)
+RCT_EXPORT_VIEW_PROPERTY(tileCachePath, NSString)
+RCT_EXPORT_VIEW_PROPERTY(tileCacheMaxAge, NSInteger)
 
 @end
 
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapUrlTile.h b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapUrlTile.h
index 05b2afd..31f77d7 100644
--- a/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapUrlTile.h
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapUrlTile.h
@@ -7,16 +7,25 @@
 
 #import <Foundation/Foundation.h>
 #import <GoogleMaps/GoogleMaps.h>
+#import "AIRGoogleMapUrlTileOverlay.h"
 
 @interface AIRGoogleMapUrlTile : UIView
 
-@property (nonatomic, strong) GMSURLTileLayer *tileLayer;
-@property (nonatomic, assign) NSString *urlTemplate;
+@property (nonatomic, strong) AIRGoogleMapUrlTileOverlay *tileLayer;
+@property (nonatomic, copy) NSString *urlTemplate;
 @property (nonatomic, assign) int zIndex;
-@property NSInteger *maximumZ;
-@property NSInteger *minimumZ;
-@property BOOL flipY;
+@property (nonatomic, assign) float opacity;
+@property (nonatomic, assign) BOOL doubleTileSize;
+@property (nonatomic, assign) NSInteger maximumZ;
+@property (nonatomic, assign) NSInteger minimumZ;
+@property (nonatomic, assign) NSInteger maximumNativeZ;
+@property (nonatomic, assign) NSInteger tileSize;
+@property (nonatomic, assign) BOOL flipY;
+@property (nonatomic, assign) BOOL offlineMode;
+@property (nonatomic, copy) NSString *tileCachePath;
+@property (nonatomic, assign) NSInteger tileCacheMaxAge;
 
 @end
 
 #endif
+
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapUrlTile.m b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapUrlTile.m
index c9beb39..64aae38 100644
--- a/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapUrlTile.m
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapUrlTile.m
@@ -6,51 +6,174 @@
 #ifdef HAVE_GOOGLE_MAPS
 
 #import "AIRGoogleMapUrlTile.h"
+#import "AIRGoogleMapUrlTileOverlay.h"
+#import "RCTConvert+GMSMapViewType.h"
+#import <React/RCTConvert.h>
 
 @implementation AIRGoogleMapUrlTile
 
-- (void)setZIndex:(int)zIndex
-{
+- (id)init {
+  self = [super init];
+  _opacity = 1;
+  return self;
+}
+- (void)setZIndex:(int)zIndex {
   _zIndex = zIndex;
   _tileLayer.zIndex = zIndex;
 }
 
-- (void)setUrlTemplate:(NSString *)urlTemplate
-{
-  _urlTemplate = urlTemplate;
-  _tileLayer = [GMSURLTileLayer tileLayerWithURLConstructor:[self _getTileURLConstructor]];
-  _tileLayer.tileSize = [[UIScreen mainScreen] scale] * 256;
+- (void)setFlipY:(BOOL)flipY {
+  _flipY = flipY;
+  if (self.tileLayer && flipY) {
+    [self.tileLayer setFlipY:_flipY];
+    [self.tileLayer clearTileCache];
+  }
+}
+
+- (void)setTileSize:(NSInteger)tileSize {
+
+  // 実際にはdoubleTileSizeの設定によってtileSizeを設定しているので、ここの設定は不要
+  // scale倍すると元のズームレベルの表示になるはずだが、これだとtileSizeとズームレベルが合わなくなる
+  _tileSize = [[UIScreen mainScreen] scale] * tileSize;
+  if (self.tileLayer) {
+    self.tileLayer.tileSize = _tileSize;
+    [self.tileLayer clearTileCache];
+  }
+}
+
+- (void)setMinimumZ:(NSInteger)minimumZ {
+  _minimumZ = minimumZ;
+  if (self.tileLayer && minimumZ) {
+    [self.tileLayer setMinimumZ:_minimumZ];
+    [self.tileLayer clearTileCache];
+  }
 }
 
-- (GMSTileURLConstructor)_getTileURLConstructor
-{
-  NSString *urlTemplate = self.urlTemplate;
-  NSInteger *maximumZ = self.maximumZ;
-  NSInteger *minimumZ = self.minimumZ;
-  GMSTileURLConstructor urls = ^NSURL* _Nullable (NSUInteger x, NSUInteger y, NSUInteger zoom) {
+- (void)setMaximumZ:(NSInteger)maximumZ {
+  _maximumZ = maximumZ;
+  if (self.tileLayer && maximumZ) {
+    [self.tileLayer setMaximumZ:_maximumZ];
+    [self.tileLayer clearTileCache];
+  }
+}
     
-    if (self.flipY == YES) {
-      y = (1 << zoom) - y - 1;
-    }
+- (void)setMaximumNativeZ:(NSInteger)maximumNativeZ {
+  _maximumNativeZ = maximumNativeZ;
+  if (self.tileLayer && maximumNativeZ) {
+    [self.tileLayer setMaximumNativeZ:maximumNativeZ];
+    [self.tileLayer clearTileCache];
+  }
+}
     
-    NSString *url = urlTemplate;
-    url = [url stringByReplacingOccurrencesOfString:@"{x}" withString:[NSString stringWithFormat: @"%ld", (long)x]];
-    url = [url stringByReplacingOccurrencesOfString:@"{y}" withString:[NSString stringWithFormat: @"%ld", (long)y]];
-    url = [url stringByReplacingOccurrencesOfString:@"{z}" withString:[NSString stringWithFormat: @"%ld", (long)zoom]];
+- (void)setDoubleTileSize:(BOOL)doubleTileSize {
+  // iOSの場合tileSizeがディスプレイのスケール倍で通常のズームレベルの表示になる
+  // tileSizeを小さくすると上のズームレベルのタイルで高解像度になる。（drawFromHigherZoomLevelと同じ効果）
 
-   if(maximumZ && (long)zoom > (long)maximumZ) {
-      return nil;
-    }
+  // 256の整数倍になるようにしているっぽい。
+  float screenTileSize =
+      [[UIScreen mainScreen] nativeBounds].size.width / 256 * 256;
+  _tileSize = doubleTileSize ? screenTileSize / 2 : screenTileSize;
+  // 元のコードだと以下のようになっているが、これだとtileSizeとズームレベルが合わなくなる
+  // _tileSize = doubleTileSize ? ([[UIScreen mainScreen] scale] * 256) / 2
+  //                            : [[UIScreen mainScreen] scale] * 256;
+  // NSLog(@"tileSizeA %ld", _tileSize);
+  if (self.tileLayer) {
+    self.tileLayer.tileSize = _tileSize;
+    //[self.tileLayer setTileSize:_tileSize];//上のじゃないとできない？
+    [self.tileLayer setDoubleTileSize:doubleTileSize];
+    [self.tileLayer clearTileCache];
+  }
+}
 
-    if(minimumZ && (long)zoom < (long)minimumZ) {
-      return nil;
-    }
+- (void)setOpacity:(float)opacity {
+  _opacity = opacity;
+  if (self.tileLayer) {
+    [self.tileLayer setOpacity:opacity];
+    [self.tileLayer clearTileCache];
+  }
+}
+
+- (void)setUrlTemplate:(NSString *)urlTemplate {
+
+  _urlTemplate = urlTemplate;
 
-    return [NSURL URLWithString:url];
-  };
-  return urls;
+  //  _tileLayer = [GMSURLTileLayer tileLayerWithURLConstructor:[self
+  //  _getTileURLConstructor]];
+  AIRGoogleMapUrlTileOverlay *tile = [[AIRGoogleMapUrlTileOverlay alloc] init];
+  [tile setTemplate:urlTemplate];
+  [tile setFlipY:_flipY];
+  [tile setMaximumZ:_maximumZ];
+  [tile setMinimumZ:_minimumZ];
+  [tile setTileSize:_tileSize];
+  [tile setDoubleTileSize:_doubleTileSize];
+  [tile setMaximumNativeZ:_maximumNativeZ];
+  [tile setZIndex:_zIndex];
+  [tile setOpacity:_opacity];
+  [tile setOfflineMode:_offlineMode];
+  [tile setTileCachePath:_tileCachePath];
+  [tile setTileCacheMaxAge:_tileCacheMaxAge];
+  _tileLayer = tile;
+}
+
+- (void)setOfflineMode:(BOOL)offlineMode {
+  _offlineMode = offlineMode;
+  if (self.tileLayer && offlineMode) {
+    self.tileLayer.offlineMode = _offlineMode;
+    [self.tileLayer clearTileCache];
+  }
+}
+
+- (void)setTileCachePath:(NSString *)tileCachePath {
+  if (!tileCachePath)
+    return;
+  _tileCachePath = tileCachePath;
+  self.tileLayer.tileCachePath = [NSURL URLWithString:_tileCachePath];
+  [self.tileLayer clearTileCache];
+}
+
+- (void)setTileCacheMaxAge:(NSInteger)tileCacheMaxAge {
+  _tileCacheMaxAge = tileCacheMaxAge;
+  if (self.tileLayer && tileCacheMaxAge) {
+    self.tileLayer.tileCacheMaxAge = _tileCacheMaxAge;
+    [self.tileLayer clearTileCache];
+  }
 }
 
 @end
 
+// - (GMSTileURLConstructor)_getTileURLConstructor
+// {
+//   NSString *urlTemplate = self.urlTemplate;
+//   NSInteger *maximumZ = self.maximumZ;
+//   NSInteger *minimumZ = self.minimumZ;
+//   GMSTileURLConstructor urls = ^NSURL* _Nullable (NSUInteger x, NSUInteger y,
+//   NSUInteger zoom) {
+
+//     if (self.flipY == YES) {
+//       y = (1 << zoom) - y - 1;
+//     }
+
+//     NSString *url = urlTemplate;
+//     url = [url stringByReplacingOccurrencesOfString:@"{x}"
+//     withString:[NSString stringWithFormat: @"%ld", (long)x]]; url = [url
+//     stringByReplacingOccurrencesOfString:@"{y}" withString:[NSString
+//     stringWithFormat: @"%ld", (long)y]]; url = [url
+//     stringByReplacingOccurrencesOfString:@"{z}" withString:[NSString
+//     stringWithFormat: @"%ld", (long)zoom]];
+
+//    if(maximumZ && (long)zoom > (long)maximumZ) {
+//       return nil;
+//     }
+
+//     if(minimumZ && (long)zoom < (long)minimumZ) {
+//       return nil;
+//     }
+
+//     return [NSURL URLWithString:url];
+//   };
+//   return urls;
+// }
+
+// @end
+
 #endif
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapUrlTileOverlay.h b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapUrlTileOverlay.h
new file mode 100644
index 0000000..5043e41
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapUrlTileOverlay.h
@@ -0,0 +1,23 @@
+//
+//  AIRGoogleMapURLTile.h
+//  Created by Nick Italiano on 11/5/16.
+//
+
+#ifdef HAVE_GOOGLE_MAPS
+
+#import <GoogleMaps/GoogleMaps.h>
+
+@interface AIRGoogleMapUrlTileOverlay : GMSSyncTileLayer
+@property(nonatomic, copy) NSString *template;
+@property(nonatomic, assign) NSInteger maximumZ;
+@property(nonatomic, assign) NSInteger minimumZ;
+@property(nonatomic) NSInteger maximumNativeZ;
+@property(nonatomic, assign) NSInteger tileSize;
+@property(nonatomic) NSInteger doubleTileSize;
+@property(nonatomic, assign) BOOL flipY;
+@property(nonatomic, assign) BOOL offlineMode;
+@property(nonatomic, copy) NSString *tileCachePath;
+@property(nonatomic, assign) NSInteger tileCacheMaxAge;
+@end
+
+#endif
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapUrlTileOverlay.m b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapUrlTileOverlay.m
new file mode 100644
index 0000000..7759cb5
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/AIRGoogleMapUrlTileOverlay.m
@@ -0,0 +1,372 @@
+//
+//  AIRGoogleMapURLTile.m
+//  Created by Nick Italiano on 11/5/16.
+//
+
+#ifdef HAVE_GOOGLE_MAPS
+
+#import "AIRGoogleMapUrlTileOverlay.h"
+@implementation AIRGoogleMapUrlTileOverlay
+- (id)init {
+  self = [super init];
+  return self;
+}
+
+- (UIImage *)tileForX:(NSUInteger)x y:(NSUInteger)y zoom:(NSUInteger)zoom {
+
+  // NSLog(@"RNM: tileSize %ld", self.tileSize);
+
+  if (zoom > self.maximumZ) {
+    return kGMSTileLayerNoTile;
+  }
+  if (self.maximumNativeZ == 0) {
+    // このあとNSUIntegerの比較があるため-1をすると予期せぬ挙動をするので0の場合はここでreturnする
+    return kGMSTileLayerNoTile;
+  }
+
+  int drawType = 0; // 0:original 1:high-resolution 2:overzoom
+  NSData *data;
+  if (zoom < self.minimumZ) {
+    // minimumZより小さいズームレベルは一つ上のズームレベルのタイルから生成する
+    // 現時点ではPDFの読み込み用。
+    drawType = 1;
+    data = [self drawFromHigherZoomTile:zoom x:x y:y];
+  } else if (zoom > self.maximumNativeZ && !self.doubleTileSize) {
+    drawType = 2;
+    data = [self drawOverZoomTile:zoom x:x y:y minZ:self.maximumNativeZ];
+  } else if (zoom > self.maximumNativeZ - 1 && self.doubleTileSize) {
+    drawType = 2;
+    data = [self drawOverZoomTile:zoom x:x y:y minZ:self.maximumNativeZ - 1];
+  } else if (zoom <= self.maximumZ && !self.doubleTileSize) {
+    drawType = 0;
+    data = [self getTile:zoom x:x y:y];
+  } else if (zoom <= self.maximumZ - 1 && self.doubleTileSize) {
+    // iOSの場合、doubleTileSizeがtrueの場合、tileSizeを小さくセットすることによって、
+    // 一つ上のズームレベルのタイルを取得するという仕様になっている。
+    // そのため、drawTypeは1でなく0でOK。
+    drawType = 0;
+    data = [self getTile:zoom x:x y:y];
+  }
+  // NSLog(@"drawType %d,%ld,%ld,%ld", drawType, zoom, self.maximumNativeZ,
+  //       self.minimumZ);
+
+  // if (!data && self.offlineMode && self.tileCachePath) {
+  //   // NSLog(@"RNM:offlineMode %ld,%ld,%ld", zoom, x, y);
+  //   // タイルダウンロードが16で固定ズームが18のため、その間を埋めるための処理
+  //   // 現在のzoomから3つ前までのタイルを探す
+  //   NSInteger zoomLevelToStart =
+  //       (zoom > self.maximumNativeZ) ? self.maximumNativeZ - 1 : zoom - 1;
+  //   NSInteger minimumZoomToSearch = self.minimumZ >= zoomLevelToStart - 3
+  //                                       ? self.minimumZ
+  //                                       : zoomLevelToStart - 3;
+  //   for (NSInteger tryZoom = zoomLevelToStart; tryZoom >=
+  //   minimumZoomToSearch;
+  //        tryZoom--) {
+  //     data = [self drawOverZoomTile:(NSUInteger)zoom
+  //                                 x:(NSUInteger)x
+  //                                 y:(NSUInteger)y
+  //                              minZ:tryZoom];
+  //     if (data) {
+  //       break;
+  //     }
+  //   }
+  // }
+
+  if (data) {
+    UIImage *img = [[UIImage alloc] initWithData:data];
+    return img;
+  }
+  return kGMSTileLayerNoTile;
+}
+
+- (NSData *)getTile:(NSUInteger)zoom x:(NSUInteger)x y:(NSUInteger)y {
+
+  if (self.flipY == YES) {
+    y = (1 << zoom) - y - 1;
+  }
+
+  NSData *data;
+  data = [self readTileImage:(NSUInteger)zoom x:(NSUInteger)x y:(NSUInteger)y];
+  if (data == nil && !self.offlineMode && self.tileCachePath) {
+    data = [self fetchTile:(NSUInteger)zoom x:(NSUInteger)x y:(NSUInteger)y];
+    if (data) {
+      [self writeTileImage:(NSUInteger)zoom
+                         x:(NSUInteger)x
+                         y:(NSUInteger)y
+              withTileData:data];
+    }
+  }
+  return data;
+}
+
+- (NSData *)readTileImage:(NSUInteger)zoom x:(NSUInteger)x y:(NSUInteger)y {
+  NSError *error = nil;
+
+  NSURL *tileCacheFilePath = [NSURL
+      URLWithString:[NSString stringWithFormat:@"%@/%ld/%ld/%ld",
+                                               self.tileCachePath, (long)zoom,
+                                               (long)x, (long)y]];
+
+  // NSLog(@"read tile %@", tileCacheFilePath);
+  NSData *data = [NSData dataWithContentsOfURL:tileCacheFilePath
+                                       options:NSDataReadingUncached
+                                         error:&error];
+  if (error) {
+    // NSLog(@"%@", [error localizedDescription]);
+    return nil;
+  } else {
+    return data;
+  }
+}
+
+- (NSURL *)generateURLwithTemplate:(NSString *)template
+                                 x:(NSUInteger)x
+                                 y:(NSUInteger)y
+                                 z:(NSUInteger)z {
+  NSString *url = template;
+  //{x} {y} {z}が含まれていない場合はnilを返す
+  if (![url containsString:@"{x}"] || ![url containsString:@"{y}"] ||
+      ![url containsString:@"{z}"]) {
+    return nil;
+  }
+  url = [url
+      stringByReplacingOccurrencesOfString:@"{x}"
+                                withString:[NSString stringWithFormat:@"%ld",
+                                                                      (long)x]];
+  url = [url
+      stringByReplacingOccurrencesOfString:@"{y}"
+                                withString:[NSString stringWithFormat:@"%ld",
+                                                                      (long)y]];
+  url = [url
+      stringByReplacingOccurrencesOfString:@"{z}"
+                                withString:[NSString stringWithFormat:@"%ld",
+                                                                      (long)z]];
+  return [NSURL URLWithString:url];
+}
+
+- (NSData *)fetchTile:(NSUInteger)zoom x:(NSUInteger)x y:(NSUInteger)y {
+  __block NSData *data = nil;
+  __block NSError *error = nil;
+
+  NSURL *url = [self generateURLwithTemplate:self.template x:x y:y z:zoom];
+  if (!url) {
+    return nil;
+  }
+
+  // セマフォを作成して非同期処理を待機
+  dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
+
+  // NSURLSessionConfigurationを作成し、タイムアウトを設定
+  NSURLSessionConfiguration *config =
+      [NSURLSessionConfiguration defaultSessionConfiguration];
+  config.timeoutIntervalForRequest =
+      1; // タイムアウト時間を秒単位で設定（ここでは10秒）
+
+  NSURLSession *session = [NSURLSession sessionWithConfiguration:config];
+
+  NSURLSessionDataTask *task =
+      [session dataTaskWithURL:url
+             completionHandler:^(NSData *_Nullable receivedData,
+                                 NSURLResponse *_Nullable response,
+                                 NSError *_Nullable receivedError) {
+               data = receivedData;
+               error = receivedError;
+               // 非同期処理が完了したことをセマフォに通知
+               dispatch_semaphore_signal(semaphore);
+             }];
+
+  [task resume];
+
+  // タイムアウト時間を設定してセマフォで待機
+  dispatch_time_t timeout =
+      dispatch_time(DISPATCH_TIME_NOW,
+                    (int64_t)(config.timeoutIntervalForRequest * NSEC_PER_SEC));
+  long waitResult = dispatch_semaphore_wait(semaphore, timeout);
+
+  if (waitResult != 0) {
+    // タイムアウトが発生した場合
+    // NSLog(@"Request timed out.");
+    [task cancel]; // タスクをキャンセル
+    return nil;
+  }
+
+  if (error) {
+    // エラーが発生した場合
+    // NSLog(@"Error fetching tile: %@", [error localizedDescription]);
+    return nil;
+  } else {
+    return data;
+  }
+}
+
+- (void)writeTileImage:(NSUInteger)zoom
+                     x:(NSUInteger)x
+                     y:(NSUInteger)y
+          withTileData:(NSData *)data {
+  NSError *error;
+
+  NSURL *tileCacheFileDirectory =
+      [NSURL URLWithString:[NSString stringWithFormat:@"%@/%ld/%ld/",
+                                                      self.tileCachePath,
+                                                      (long)zoom, (long)x]];
+
+  NSURL *tileCacheFilePath = [NSURL
+      URLWithString:[NSString stringWithFormat:@"%@/%ld/%ld/%ld",
+                                               self.tileCachePath, (long)zoom,
+                                               (long)x, (long)y]];
+
+  if (![[NSFileManager defaultManager]
+          fileExistsAtPath:[tileCacheFileDirectory path]]) {
+    [[NSFileManager defaultManager]
+              createDirectoryAtPath:[tileCacheFileDirectory path]
+        withIntermediateDirectories:YES
+                         attributes:nil
+                              error:&error];
+    if (error) {
+      // NSLog(@"Error: %@", error);
+      return;
+    }
+  }
+
+  [[NSFileManager defaultManager] createFileAtPath:[tileCacheFilePath path]
+                                          contents:data
+                                        attributes:nil];
+  // NSLog(@"write tile %@", [tileCacheFilePath path]);
+}
+
+- (NSData *)drawOverZoomTile:(NSUInteger)tryZ
+                           x:(NSUInteger)x
+                           y:(NSUInteger)y
+                        minZ:(NSInteger)minZ {
+
+  int overZoomLevel = tryZ - minZ;
+  int zoomFactor = 1 << overZoomLevel;
+  int xParent = x >> overZoomLevel;
+  int yParent = y >> overZoomLevel;
+  int zoomParent = tryZ - overZoomLevel;
+  int xOffset = x % zoomFactor;
+  int yOffset = y % zoomFactor;
+  // NSLog(@"RNM:overZoom %ld,%ld", tryZ, minZ);
+  // if (overZoomLevel > 5) {
+  //   return nil;
+  // }
+  NSData *data = [self getTile:zoomParent x:xParent y:yParent];
+  if (!data) {
+    return nil;
+  }
+  UIImage *image = [UIImage imageWithData:data];
+  if (!image) {
+    NSLog(@"Error: Failed to create the image from the data.");
+    return nil;
+  }
+  CGRect originalRect = CGRectMake(0, 0, image.size.width, image.size.height);
+
+  int subTileSizeX = image.size.width / zoomFactor;
+  int subTileSizeY = image.size.height / zoomFactor;
+  UIGraphicsBeginImageContextWithOptions(originalRect.size, NO, 0.0);
+  {
+    CGRect drawRect = CGRectApplyAffineTransform(
+        originalRect, CGAffineTransformMakeScale(zoomFactor, zoomFactor));
+    drawRect = CGRectApplyAffineTransform(
+        drawRect,
+        CGAffineTransformMakeTranslation(-image.size.width * xOffset,
+                                         -image.size.height * yOffset));
+
+    [image drawInRect:drawRect];
+    image = UIGraphicsGetImageFromCurrentImageContext();
+    if (!image) {
+      NSLog(@"Error: Failed to draw the image in the context.");
+      UIGraphicsEndImageContext();
+      return nil;
+    }
+  }
+  UIGraphicsEndImageContext();
+
+  NSData *imageData = UIImagePNGRepresentation(image);
+  if (!imageData) {
+    NSLog(@"Error: Could not convert the image to PNG format.");
+    return nil;
+  }
+
+  return imageData;
+}
+
+- (NSData *)drawFromHigherZoomTile:(NSUInteger)zoom
+                                 x:(NSUInteger)x
+                                 y:(NSUInteger)y {
+  // NSLog(@"RNM:fromHigher %ld,%ld,%ld", zoom, x, y);
+  NSUInteger X = x * 2;
+  NSUInteger Y = y * 2;
+  NSData *leftTop = [self getTile:zoom + 1 x:X y:Y];
+  NSData *leftBottom = [self getTile:zoom + 1 x:X y:Y + 1];
+  NSData *rightTop = [self getTile:zoom + 1 x:X + 1 y:Y];
+  NSData *rightBottom = [self getTile:zoom + 1 x:X + 1 y:Y + 1];
+
+  // 画像があるものからsizeを取得
+  NSInteger width;
+  NSInteger height;
+  if (leftTop) {
+    width = [UIImage imageWithData:leftTop].size.width;
+    height = [UIImage imageWithData:leftTop].size.height;
+  } else if (leftBottom) {
+    width = [UIImage imageWithData:leftBottom].size.width;
+    height = [UIImage imageWithData:leftBottom].size.height;
+  } else if (rightTop) {
+    width = [UIImage imageWithData:rightTop].size.width;
+    height = [UIImage imageWithData:rightTop].size.height;
+  } else if (rightBottom) {
+    width = [UIImage imageWithData:rightBottom].size.width;
+    height = [UIImage imageWithData:rightBottom].size.height;
+  } else {
+    // NSLog(@"RNM:No image");
+    return nil;
+  }
+  CGSize tileSize = CGSizeMake(width / 2, height / 2);
+  // NSLog(@"RNM: width %ld", width);
+  UIGraphicsBeginImageContextWithOptions(CGSizeMake(width, height), NO, 1);
+  CGContextRef context = UIGraphicsGetCurrentContext();
+
+  if (leftTop) {
+    UIImage *image = [UIImage imageWithData:leftTop];
+    if (image) {
+      [image drawInRect:CGRectMake(0, 0, tileSize.width, tileSize.height)];
+    }
+  }
+  if (leftBottom) {
+    UIImage *image = [UIImage imageWithData:leftBottom];
+    if (image) {
+      [image drawInRect:CGRectMake(0, tileSize.height, tileSize.width,
+                                   tileSize.height)];
+    }
+  }
+  if (rightTop) {
+    UIImage *image = [UIImage imageWithData:rightTop];
+    if (image) {
+      [image drawInRect:CGRectMake(tileSize.width, 0, tileSize.width,
+                                   tileSize.height)];
+    }
+  }
+  if (rightBottom) {
+    UIImage *image = [UIImage imageWithData:rightBottom];
+    if (image) {
+      [image drawInRect:CGRectMake(tileSize.width, tileSize.height,
+                                   tileSize.width, tileSize.height)];
+    }
+  }
+  UIImage *combinedImage = UIGraphicsGetImageFromCurrentImageContext();
+  UIGraphicsEndImageContext();
+
+  NSData *data = UIImagePNGRepresentation(combinedImage);
+  // キャッシュに保存
+  if (self.tileCachePath) {
+    [self writeTileImage:(NSUInteger)zoom
+                       x:(NSUInteger)x
+                       y:(NSUInteger)y
+            withTileData:data];
+  }
+  return data;
+}
+
+@end
+
+#endif
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/Decompress.h b/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/Decompress.h
new file mode 100644
index 0000000..f4c6ece
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/Decompress.h
@@ -0,0 +1,8 @@
+#import <Foundation/Foundation.h>
+#import <zlib.h>
+
+@interface Decompress : NSObject
+
++ (NSData *)decompress:(NSData *)data compression:(NSUInteger)compression;
+
+@end
\ No newline at end of file
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/Decompress.m b/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/Decompress.m
new file mode 100644
index 0000000..bd3880f
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/Decompress.m
@@ -0,0 +1,67 @@
+#import "Decompress.h"
+
+@implementation Decompress
+
++ (NSData *)decompress:(NSData *)data compression:(NSUInteger)compression {
+  if (compression == 1 || compression == 0) {
+    return data;
+  } else if (compression == 2) {
+    return [self decompressGzip:data];
+  } else {
+    @throw [NSException exceptionWithName:NSInvalidArgumentException
+                                   reason:@"Compression method not supported"
+                                 userInfo:nil];
+  }
+}
+
++ (NSData *)decompressGzip:(NSData *)data {
+  if ([data length] == 0)
+    return data;
+
+  NSUInteger full_length = [data length];
+  NSUInteger half_length = [data length] / 2;
+
+  NSMutableData *decompressed =
+      [NSMutableData dataWithLength:full_length + half_length];
+  BOOL done = NO;
+  int status;
+
+  z_stream strm;
+  strm.next_in = (Bytef *)[data bytes];
+  strm.avail_in = (uInt)[data length];
+  strm.total_out = 0;
+  strm.zalloc = Z_NULL;
+  strm.zfree = Z_NULL;
+
+  if (inflateInit2(&strm, (15 + 32)) != Z_OK)
+    return nil;
+
+  while (!done) {
+    if (strm.total_out >= [decompressed length]) {
+      [decompressed increaseLengthBy:half_length];
+    }
+
+    strm.next_out = [decompressed mutableBytes] + strm.total_out;
+    strm.avail_out = (uInt)([decompressed length] - strm.total_out);
+
+    status = inflate(&strm, Z_SYNC_FLUSH);
+
+    if (status == Z_STREAM_END) {
+      done = YES;
+    } else if (status != Z_OK) {
+      break;
+    }
+  }
+
+  if (inflateEnd(&strm) != Z_OK)
+    return nil;
+
+  if (done) {
+    [decompressed setLength:strm.total_out];
+    return [NSData dataWithData:decompressed];
+  } else {
+    return nil;
+  }
+}
+
+@end
\ No newline at end of file
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/FetchSource.h b/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/FetchSource.h
new file mode 100644
index 0000000..9f3ef17
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/FetchSource.h
@@ -0,0 +1,15 @@
+#import <Foundation/Foundation.h>
+
+@interface FetchSource : NSObject
+
+@property(nonatomic, strong) NSString *url;
+
+- (instancetype)initWithURL:(NSString *)url;
+- (NSString *)getKey;
+- (void)getBytesWithOffset:(NSUInteger)offset
+                    length:(NSUInteger)length
+                    signal:(NSProgress *)signal
+                completion:(void (^)(NSDictionary *rangeResponse,
+                                     NSError *error))completion;
+
+@end
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/FetchSource.m b/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/FetchSource.m
new file mode 100644
index 0000000..5c77432
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/FetchSource.m
@@ -0,0 +1,186 @@
+#import "FetchSource.h"
+
+@interface FetchSource ()
+
+@property(nonatomic, assign) BOOL isLocalFile;
+
+@end
+
+@implementation FetchSource
+
+- (instancetype)initWithURL:(NSString *)url {
+  self = [super init];
+  if (self) {
+    self.url = url;
+    self.isLocalFile =
+        [url hasPrefix:@"file://"] || [url hasPrefix:@"documents://"];
+  }
+  return self;
+}
+
+- (NSString *)getKey {
+  return self.url;
+}
+
+- (void)getBytesWithOffset:(NSUInteger)offset
+                    length:(NSUInteger)length
+                    signal:(NSProgress *)signal
+                completion:(void (^)(NSDictionary *rangeResponse,
+                                     NSError *error))completion {
+  if (self.isLocalFile) {
+    [self getBytesFromLocalFileWithOffset:offset
+                                   length:length
+                               completion:completion];
+  } else {
+    [self getBytesFromRemoteURLWithOffset:offset
+                                   length:length
+                                   signal:signal
+                               completion:completion];
+  }
+}
+
+- (void)getBytesFromLocalFileWithOffset:(NSUInteger)offset
+                                 length:(NSUInteger)length
+                             completion:(void (^)(NSDictionary *rangeResponse,
+                                                  NSError *error))completion {
+  NSString *filePath = [self.url stringByReplacingOccurrencesOfString:@"file://"
+                                                           withString:@""];
+  if ([self.url hasPrefix:@"documents://"]) {
+    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,
+                                                         NSUserDomainMask, YES);
+    NSString *documentsDirectory = [paths objectAtIndex:0];
+    filePath = [documentsDirectory
+        stringByAppendingPathComponent:[self.url
+                                           substringFromIndex:[@"documents://"
+                                                                  length]]];
+  }
+
+  NSFileHandle *fileHandle = [NSFileHandle fileHandleForReadingAtPath:filePath];
+  if (!fileHandle) {
+    NSError *error = [NSError
+        errorWithDomain:@"FetchSourceErrorDomain"
+                   code:0
+               userInfo:@{
+                 NSLocalizedDescriptionKey : @"Unable to open local file"
+               }];
+    completion(nil, error);
+    return;
+  }
+
+  @try {
+    [fileHandle seekToFileOffset:offset];
+    NSData *data = [fileHandle readDataOfLength:length];
+
+    NSDictionary *rangeResponse = @{
+      @"data" : data,
+      @"etag" : [NSNull null],
+      @"cacheControl" : [NSNull null],
+      @"expires" : [NSNull null],
+    };
+    completion(rangeResponse, nil);
+  } @catch (NSException *exception) {
+    NSError *error = [NSError
+        errorWithDomain:@"FetchSourceErrorDomain"
+                   code:0
+               userInfo:@{NSLocalizedDescriptionKey : exception.reason}];
+    completion(nil, error);
+  } @finally {
+    [fileHandle closeFile];
+  }
+}
+
+- (void)getBytesFromRemoteURLWithOffset:(NSUInteger)offset
+                                 length:(NSUInteger)length
+                                 signal:(NSProgress *)signal
+                             completion:(void (^)(NSDictionary *rangeResponse,
+                                                  NSError *error))completion {
+  NSString *encodedUrlString =
+      [self.url stringByAddingPercentEncodingWithAllowedCharacters:
+                    [NSCharacterSet URLQueryAllowedCharacterSet]];
+  NSMutableURLRequest *request = [NSMutableURLRequest
+      requestWithURL:[NSURL URLWithString:encodedUrlString]];
+
+  [request setValue:[NSString
+                        stringWithFormat:@"bytes=%lu-%lu",
+                                         (unsigned long)offset,
+                                         (unsigned long)(offset + length - 1)]
+      forHTTPHeaderField:@"Range"];
+
+  if (signal) {
+    [signal addObserver:self
+             forKeyPath:@"cancelled"
+                options:NSKeyValueObservingOptionNew
+                context:nil];
+  }
+
+  NSURLSessionDataTask *dataTask = [[NSURLSession sharedSession]
+      dataTaskWithRequest:request
+        completionHandler:^(NSData *data, NSURLResponse *response,
+                            NSError *error) {
+          if (error) {
+            completion(nil, error);
+            return;
+          }
+
+          NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;
+          if (httpResponse.statusCode >= 300) {
+            completion(
+                nil,
+                [NSError
+                    errorWithDomain:@"FetchSourceErrorDomain"
+                               code:httpResponse.statusCode
+                           userInfo:@{
+                             NSLocalizedDescriptionKey : [NSString
+                                 stringWithFormat:@"Bad response code: %ld",
+                                                  (long)httpResponse.statusCode]
+                           }]);
+            return;
+          }
+
+          NSString *contentLength =
+              httpResponse.allHeaderFields[@"Content-Length"];
+          if (httpResponse.statusCode == 200 &&
+              (!contentLength || contentLength.integerValue > length)) {
+            if (signal) {
+              [signal removeObserver:self forKeyPath:@"cancelled"];
+            }
+            completion(nil,
+                       [NSError
+                           errorWithDomain:@"FetchSourceErrorDomain"
+                                      code:0
+                                  userInfo:@{
+                                    NSLocalizedDescriptionKey :
+                                        @"Server returned no content-length "
+                                        @"header or content-length exceeding "
+                                        @"request. Check that your storage "
+                                        @"backend supports HTTP Byte Serving."
+                                  }]);
+            return;
+          }
+
+          NSDictionary *rangeResponse = @{
+            @"data" : data,
+            @"etag" : httpResponse.allHeaderFields[@"ETag"] ?: [NSNull null],
+            @"cacheControl" : httpResponse.allHeaderFields[@"Cache-Control"]
+                ?: [NSNull null],
+            @"expires" : httpResponse.allHeaderFields[@"Expires"]
+                ?: [NSNull null],
+          };
+          completion(rangeResponse, nil);
+        }];
+
+  [dataTask resume];
+}
+
+- (void)observeValueForKeyPath:(NSString *)keyPath
+                      ofObject:(id)object
+                        change:(NSDictionary *)change
+                       context:(void *)context {
+  if ([keyPath isEqualToString:@"cancelled"]) {
+    // キャンセル処理のロジック
+    // 例: データタスクをキャンセルする
+    // [dataTask cancel];
+  }
+}
+
+@end
\ No newline at end of file
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/Header.h b/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/Header.h
new file mode 100644
index 0000000..900ea88
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/Header.h
@@ -0,0 +1,29 @@
+#import <Foundation/Foundation.h>
+
+typedef struct
+{
+  uint64_t root_dir_offset;
+  uint64_t root_dir_bytes;
+  uint64_t json_metadata_offset;
+  uint64_t json_metadata_bytes;
+  uint64_t leaf_dirs_offset;
+  uint64_t leaf_dirs_bytes;
+  uint64_t tile_data_offset;
+  uint64_t tile_data_bytes;
+  uint64_t addressed_tiles_count;
+  uint64_t tile_entries_count;
+  uint64_t tile_contents_count;
+  BOOL clustered;
+  uint8_t internal_compression;
+  uint8_t tile_compression;
+  uint8_t tile_type;
+  uint8_t min_zoom;
+  uint8_t max_zoom;
+  int32_t min_lon_e7;
+  int32_t min_lat_e7;
+  int32_t max_lon_e7;
+  int32_t max_lat_e7;
+  uint8_t center_zoom;
+  int32_t center_lon_e7;
+  int32_t center_lat_e7;
+} headerv3;
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/PMTiles.h b/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/PMTiles.h
new file mode 100644
index 0000000..a26ac22
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/PMTiles.h
@@ -0,0 +1,87 @@
+// pmtiles.h
+
+#import "FetchSource.h"
+#import "Header.h"
+#import "SharedCache.h"
+#import <Foundation/Foundation.h>
+@interface PMTiles : NSObject
+
+@property(nonatomic, strong) NSString *urlString;
+@property(nonatomic, strong) FetchSource *fetchSource;
+@property(nonatomic, strong) SharedCache *sharedCache;
+
+typedef struct
+{
+  uint8_t z;
+  uint32_t x;
+  uint32_t y;
+} ZXY;
+
+typedef struct
+{
+  uint64_t tile_id;
+  uint64_t offset;
+  uint32_t length;
+  uint32_t run_length;
+} EntryV3;
+
+typedef struct
+{
+  uint8_t z;
+  uint32_t x;
+  uint32_t y;
+  uint64_t offset;
+  uint32_t length;
+} EntryZXY;
+
+ZXY ZXYMake(uint8_t z, uint32_t x, uint32_t y);
+EntryV3 EntryV3Make(uint64_t tile_id, uint64_t offset, uint32_t length,
+                    uint32_t run_length);
+
+EntryZXY EntryZXYMake(uint8_t z, uint32_t x, uint32_t y, uint64_t offset,
+                      uint32_t length);
+
+NS_INLINE NSComparisonResult EntryV3Compare(EntryV3 a, EntryV3 b);
+
+NS_INLINE NSComparisonResult EntryZXYCompare(EntryZXY a, EntryZXY b);
+
++ (NSString *)serializeHeader:(headerv3)header;
++ (headerv3)deserializeHeader:(NSData *)bytes;
++ (ZXY)tileIDToZXY:(uint64_t)tileID;
++ (uint64_t)zxyToTileID:(uint8_t)z x:(uint32_t)x y:(uint32_t)y;
++ (NSString *)serializeDirectory:(NSArray<NSValue *> *)entries;
++ (NSArray<NSValue *> *)deserializeDirectory:(NSData *)decompressed;
++ (void)collectEntries:(NSData * (^)(NSData *, uint8_t))decompress
+           tileEntries:(NSMutableArray<NSValue *> *)tileEntries
+            pmtilesMap:(const char *)pmtilesMap
+                header:(headerv3)h
+             dirOffset:(uint64_t)dirOffset
+             dirLength:(uint64_t)dirLength;
++ (NSArray<NSValue *> *)entriesTMS:(NSData * (^)(NSData *, uint8_t))decompress
+                        pmtilesMap:(const char *)pmtilesMap;
+
++ (uint64_t)getUint64:(const uint8_t *)data atOffset:(int)offset;
++ (int32_t)getInt32:(const uint8_t *)data
+           atOffset:(int)offset
+     isLittleEndian:(BOOL)isLittleEndian;
+
+- (instancetype)initWithURL:(NSString *)urlString;
+- (NSData *)getTileWithZ:(uint8_t)z x:(uint32_t)x y:(uint32_t)y;
+- (headerv3)fetchHeader;
+- (NSDictionary *)fetchMetadata;
+
+@end
+
+@interface PMTilesMagicNumberException : NSException
+- (NSString *)what;
+@end
+
+@interface PMTilesVersionException : NSException
+- (NSString *)what;
+@end
+
+@interface VarIntTooLongException : NSException
+@end
+
+@interface EndOfBufferException : NSException
+@end
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/PMTiles.m b/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/PMTiles.m
new file mode 100644
index 0000000..3806926
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/PMTiles.m
@@ -0,0 +1,487 @@
+#import "PMTiles.h"
+#import "Decompress.h"
+#import "FetchSource.h"
+// #import "SharedCache.h"
+#import "VarintHelper.h"
+#import <Foundation/Foundation.h>
+@implementation PMTiles
+
+- (instancetype)initWithURL:(NSString *)urlString {
+  self = [super init];
+  if (self) {
+    self.urlString = urlString;
+    self.fetchSource = [[FetchSource alloc] initWithURL:urlString];
+    self.sharedCache = [[SharedCache alloc] init];
+  }
+  return self;
+}
+
+const uint8_t TILETYPE_UNKNOWN = 0x0;
+const uint8_t TILETYPE_MVT = 0x1;
+const uint8_t TILETYPE_PNG = 0x2;
+const uint8_t TILETYPE_JPEG = 0x3;
+const uint8_t TILETYPE_WEBP = 0x4;
+
+const uint8_t COMPRESSION_UNKNOWN = 0x0;
+const uint8_t COMPRESSION_NONE = 0x1;
+const uint8_t COMPRESSION_GZIP = 0x2;
+const uint8_t COMPRESSION_BROTLI = 0x3;
+const uint8_t COMPRESSION_ZSTD = 0x4;
+
+ZXY ZXYMake(uint8_t z, uint32_t x, uint32_t y) {
+  ZXY result;
+  result.z = z;
+  result.x = x;
+  result.y = y;
+  return result;
+}
+EntryV3 EntryV3Make(uint64_t tile_id, uint64_t offset, uint32_t length,
+                    uint32_t run_length) {
+  EntryV3 result;
+  result.tile_id = tile_id;
+  result.offset = offset;
+  result.length = length;
+  result.run_length = run_length;
+  return result;
+}
+
+EntryZXY EntryZXYMake(uint8_t z, uint32_t x, uint32_t y, uint64_t offset,
+                      uint32_t length) {
+  EntryZXY result;
+  result.z = z;
+  result.x = x;
+  result.y = y;
+  result.offset = offset;
+  result.length = length;
+  return result;
+}
+
+NS_INLINE NSComparisonResult EntryV3Compare(EntryV3 a, EntryV3 b) {
+  if (a.tile_id < b.tile_id) {
+    return NSOrderedAscending;
+  } else if (a.tile_id > b.tile_id) {
+    return NSOrderedDescending;
+  } else {
+    return NSOrderedSame;
+  }
+}
+
+NS_INLINE NSComparisonResult EntryZXYCompare(EntryZXY a, EntryZXY b) {
+  if (a.z != b.z) {
+    return a.z < b.z ? NSOrderedAscending : NSOrderedDescending;
+  }
+  if (a.x != b.x) {
+    return a.x < b.x ? NSOrderedAscending : NSOrderedDescending;
+  }
+  if (a.y != b.y) {
+    return a.y < b.y ? NSOrderedAscending : NSOrderedDescending;
+  }
+  return NSOrderedSame;
+}
+
++ (ZXY)tileIDToZXY:(uint64_t)tileID {
+  uint64_t acc = 0;
+  for (uint8_t t_z = 0; t_z < 32; t_z++) {
+    uint64_t num_tiles = (1LL << t_z) * (1LL << t_z);
+    if (acc + num_tiles > tileID) {
+      return [VarintHelper t_on_level:t_z position:tileID - acc];
+    }
+    acc += num_tiles;
+  }
+  @throw [NSException exceptionWithName:NSRangeException
+                                 reason:@"Tile zoom exceeds 64-bit limit"
+                               userInfo:nil];
+}
+
++ (uint64_t)zxyToTileID:(uint8_t)z x:(uint32_t)x y:(uint32_t)y {
+  if (z > 31) {
+    @throw [NSException exceptionWithName:NSGenericException
+                                   reason:@"Tile zoom exceeds 64-bit limit"
+                                 userInfo:nil];
+  }
+  if (x > (1 << z) - 1 || y > (1 << z) - 1) {
+    @throw [NSException exceptionWithName:NSGenericException
+                                   reason:@"Tile x/y outside zoom level bounds "
+                                 userInfo:nil];
+  }
+  uint64_t acc = 0;
+  for (uint8_t t_z = 0; t_z < z; t_z++) {
+    acc += (1LL << t_z) * (1LL << t_z);
+  }
+  int64_t n = 1LL << z;
+  int64_t rx, ry, s, d = 0;
+  int64_t tx = x;
+  int64_t ty = y;
+  for (s = n / 2; s > 0; s /= 2) {
+    rx = (tx & s) > 0;
+    ry = (ty & s) > 0;
+    d += s * s * ((3LL * rx) ^ ry);
+    [VarintHelper rotate:s x:&tx y:&ty rx:rx ry:ry];
+  }
+  return acc + d;
+}
+
++ (NSString *)serializeDirectory:(NSArray<NSValue *> *)entries {
+  NSMutableString *data = [NSMutableString string];
+
+  [VarintHelper writeVarint:data value:entries.count];
+
+  uint64_t lastID = 0;
+  for (NSValue *entryValue in entries) {
+    EntryV3 entry;
+    [entryValue getValue:&entry];
+    [VarintHelper writeVarint:data value:(entry.tile_id - lastID)];
+    lastID = entry.tile_id;
+  }
+
+  for (NSValue *entryValue in entries) {
+    EntryV3 entry;
+    [entryValue getValue:&entry];
+    [VarintHelper writeVarint:data value:entry.run_length];
+  }
+
+  for (NSValue *entryValue in entries) {
+    EntryV3 entry;
+    [entryValue getValue:&entry];
+    [VarintHelper writeVarint:data value:entry.length];
+  }
+
+  for (NSUInteger i = 0; i < entries.count; i++) {
+    EntryV3 entry, prevEntry;
+    [entries[i] getValue:&entry];
+    if (i > 0) {
+      [entries[i - 1] getValue:&prevEntry];
+    }
+    if (i > 0 && entry.offset == prevEntry.offset + prevEntry.length) {
+      [VarintHelper writeVarint:data value:0];
+    } else {
+      [VarintHelper writeVarint:data value:(entry.offset + 1)];
+    }
+  }
+
+  return [NSString stringWithString:data];
+}
+
++ (NSArray<NSValue *> *)deserializeDirectory:(NSData *)decompressed {
+  const char *t = (const char *)decompressed.bytes;
+  const char *end = t + decompressed.length;
+
+  uint64_t numEntries = [VarintHelper decodeVarint:&t end:end];
+
+  NSMutableArray<NSValue *> *result =
+      [NSMutableArray arrayWithCapacity:numEntries];
+
+  uint64_t lastID = 0;
+  for (NSUInteger i = 0; i < numEntries; i++) {
+    uint64_t tileID = lastID + [VarintHelper decodeVarint:&t end:end];
+    EntryV3 entry = {tileID, 0, 0, 0};
+    [result addObject:[NSValue valueWithBytes:&entry
+                                     objCType:@encode(EntryV3)]];
+    lastID = tileID;
+  }
+
+  for (NSUInteger i = 0; i < numEntries; i++) {
+    EntryV3 entry;
+    [result[i] getValue:&entry];
+    entry.run_length = [VarintHelper decodeVarint:&t end:end];
+    result[i] = [NSValue valueWithBytes:&entry objCType:@encode(EntryV3)];
+  }
+
+  for (NSUInteger i = 0; i < numEntries; i++) {
+    EntryV3 entry;
+    [result[i] getValue:&entry];
+    entry.length = [VarintHelper decodeVarint:&t end:end];
+    result[i] = [NSValue valueWithBytes:&entry objCType:@encode(EntryV3)];
+  }
+
+  for (NSUInteger i = 0; i < numEntries; i++) {
+    uint64_t tmp = [VarintHelper decodeVarint:&t end:end];
+    EntryV3 entry, prevEntry;
+    [result[i] getValue:&entry];
+    if (i > 0) {
+      [result[i - 1] getValue:&prevEntry];
+    }
+    if (i > 0 && tmp == 0) {
+      entry.offset = prevEntry.offset + prevEntry.length;
+    } else {
+      entry.offset = tmp - 1;
+    }
+    result[i] = [NSValue valueWithBytes:&entry objCType:@encode(EntryV3)];
+  }
+
+  // assert the directory has been fully consumed
+  if (t != end) {
+    fprintf(stderr, "Error: malformed pmtiles directory\n");
+    exit(EXIT_FAILURE);
+  }
+
+  return [NSArray arrayWithArray:result];
+}
+
++ (void)collectEntries:(NSData * (^)(NSData *, uint8_t))decompress
+           tileEntries:(NSMutableArray<NSValue *> *)tileEntries
+            pmtilesMap:(const char *)pmtilesMap
+                header:(headerv3)h
+             dirOffset:(uint64_t)dirOffset
+             dirLength:(uint64_t)dirLength {
+  NSData *dirData = [NSData dataWithBytes:pmtilesMap + dirOffset
+                                   length:dirLength];
+
+  NSData *decompressedData = decompress(dirData, h.internal_compression);
+
+  NSArray<NSValue *> *dirEntries =
+      [PMTiles deserializeDirectory:decompressedData];
+  for (NSValue *entryValue in dirEntries) {
+    EntryV3 entry;
+    [entryValue getValue:&entry];
+    if (entry.run_length == 0) {
+      [PMTiles collectEntries:decompress
+                  tileEntries:tileEntries
+                   pmtilesMap:pmtilesMap
+                       header:h
+                    dirOffset:h.leaf_dirs_offset + entry.offset
+                    dirLength:entry.length];
+    } else {
+      for (uint64_t i = entry.tile_id; i < entry.tile_id + entry.run_length;
+           i++) {
+        ZXY zxy = [PMTiles tileIDToZXY:i];
+        EntryZXY entryZXY =
+            EntryZXYMake(zxy.z, zxy.x, zxy.y, h.tile_data_offset + entry.offset,
+                         entry.length);
+        [tileEntries addObject:[NSValue valueWithBytes:&entryZXY
+                                              objCType:@encode(EntryZXY)]];
+      }
+    }
+  }
+}
+
++ (NSArray<NSValue *> *)entriesTMS:(NSData * (^)(NSData *, uint8_t))decompress
+                        pmtilesMap:(const char *)pmtilesMap {
+  NSData *headerData = [NSData dataWithBytes:pmtilesMap length:127];
+  headerv3 header = [PMTiles deserializeHeader:headerData];
+  NSMutableArray<NSValue *> *tileEntries = [NSMutableArray array];
+  [PMTiles collectEntries:decompress
+              tileEntries:tileEntries
+               pmtilesMap:pmtilesMap
+                   header:header
+                dirOffset:header.root_dir_offset
+                dirLength:header.root_dir_bytes];
+  NSArray<NSValue *> *sortedTileEntries = [tileEntries
+      sortedArrayUsingComparator:^NSComparisonResult(NSValue *a, NSValue *b) {
+        EntryZXY entryA, entryB;
+        [a getValue:&entryA];
+        [b getValue:&entryB];
+        if (entryA.z != entryB.z) {
+          return entryA.z < entryB.z ? NSOrderedAscending : NSOrderedDescending;
+        }
+        if (entryA.x != entryB.x) {
+          return entryA.x < entryB.x ? NSOrderedAscending : NSOrderedDescending;
+        }
+        return entryA.y > entryB.y ? NSOrderedAscending : NSOrderedDescending;
+      }];
+
+  return sortedTileEntries;
+}
+
++ (headerv3)deserializeHeader:(NSData *)bytes {
+  headerv3 header;
+  const uint8_t *dataPtr = bytes.bytes;
+
+  uint8_t spec_version = dataPtr[7];
+  if (spec_version > 3) {
+    [NSException raise:@"InvalidArchiveException"
+                format:@"Archive is spec version %d but this library supports "
+                       @"up to spec version 3",
+                       spec_version];
+  }
+
+  header.root_dir_offset = [self getUint64:dataPtr atOffset:8];
+  header.root_dir_bytes = [self getUint64:dataPtr atOffset:16];
+  header.json_metadata_offset = [self getUint64:dataPtr atOffset:24];
+  header.json_metadata_bytes = [self getUint64:dataPtr atOffset:32];
+  header.leaf_dirs_offset = [self getUint64:dataPtr atOffset:40];
+  header.leaf_dirs_bytes = [self getUint64:dataPtr atOffset:48];
+  header.tile_data_offset = [self getUint64:dataPtr atOffset:56];
+  header.tile_data_bytes = [self getUint64:dataPtr atOffset:64];
+  header.addressed_tiles_count = [self getUint64:dataPtr atOffset:72];
+  header.tile_entries_count = [self getUint64:dataPtr atOffset:80];
+  header.tile_contents_count = [self getUint64:dataPtr atOffset:88];
+  header.clustered = dataPtr[96] == 1;
+  header.internal_compression = dataPtr[97];
+  header.tile_compression = dataPtr[98];
+  header.tile_type = dataPtr[99];
+  header.min_zoom = dataPtr[100];
+  header.max_zoom = dataPtr[101];
+  header.min_lon_e7 = [self getInt32:dataPtr atOffset:102 isLittleEndian:YES];
+  header.min_lat_e7 = [self getInt32:dataPtr atOffset:106 isLittleEndian:YES];
+  header.max_lon_e7 = [self getInt32:dataPtr atOffset:110 isLittleEndian:YES];
+  header.max_lat_e7 = [self getInt32:dataPtr atOffset:114 isLittleEndian:YES];
+  header.center_zoom = dataPtr[118];
+  header.center_lon_e7 = [self getInt32:dataPtr
+                               atOffset:119
+                         isLittleEndian:YES];
+  header.center_lat_e7 = [self getInt32:dataPtr
+                               atOffset:123
+                         isLittleEndian:YES];
+
+  return header;
+}
+
++ (uint64_t)getUint64:(const uint8_t *)data atOffset:(int)offset {
+  uint64_t value;
+  memcpy(&value, &data[offset], sizeof(value));
+  return CFSwapInt64LittleToHost(value);
+}
+
++ (int32_t)getInt32:(const uint8_t *)data
+           atOffset:(int)offset
+     isLittleEndian:(BOOL)isLittleEndian {
+  int32_t value;
+  memcpy(&value, &data[offset], sizeof(value));
+  if (isLittleEndian) {
+    return CFSwapInt32LittleToHost(value);
+  } else {
+    return CFSwapInt32BigToHost(value);
+  }
+}
+
++ (NSString *)serializeHeader:(headerv3)header {
+  NSMutableData *data = [NSMutableData data];
+
+  [data appendData:[@"PMTiles" dataUsingEncoding:NSUTF8StringEncoding]];
+  uint8_t version = 3;
+  [data appendBytes:&version length:1];
+  [data appendBytes:&header.root_dir_offset
+             length:sizeof(header.root_dir_offset)];
+  [data appendBytes:&header.root_dir_bytes
+             length:sizeof(header.root_dir_bytes)];
+  [data appendBytes:&header.json_metadata_offset
+             length:sizeof(header.json_metadata_offset)];
+  [data appendBytes:&header.json_metadata_bytes
+             length:sizeof(header.json_metadata_bytes)];
+  [data appendBytes:&header.leaf_dirs_offset
+             length:sizeof(header.leaf_dirs_offset)];
+  [data appendBytes:&header.leaf_dirs_bytes
+             length:sizeof(header.leaf_dirs_bytes)];
+  [data appendBytes:&header.tile_data_offset
+             length:sizeof(header.tile_data_offset)];
+  [data appendBytes:&header.tile_data_bytes
+             length:sizeof(header.tile_data_bytes)];
+  [data appendBytes:&header.addressed_tiles_count
+             length:sizeof(header.addressed_tiles_count)];
+  [data appendBytes:&header.tile_entries_count
+             length:sizeof(header.tile_entries_count)];
+  [data appendBytes:&header.tile_contents_count
+             length:sizeof(header.tile_contents_count)];
+
+  uint8_t clustered_val = header.clustered ? 0x1 : 0x0;
+  [data appendBytes:&clustered_val length:1];
+  [data appendBytes:&header.internal_compression length:1];
+  [data appendBytes:&header.tile_compression length:1];
+  [data appendBytes:&header.tile_type length:1];
+  [data appendBytes:&header.min_zoom length:1];
+  [data appendBytes:&header.max_zoom length:1];
+  [data appendBytes:&header.min_lon_e7 length:sizeof(header.min_lon_e7)];
+  [data appendBytes:&header.min_lat_e7 length:sizeof(header.min_lat_e7)];
+  [data appendBytes:&header.max_lon_e7 length:sizeof(header.max_lon_e7)];
+  [data appendBytes:&header.max_lat_e7 length:sizeof(header.max_lat_e7)];
+  [data appendBytes:&header.center_zoom length:1];
+  [data appendBytes:&header.center_lon_e7 length:sizeof(header.center_lon_e7)];
+  [data appendBytes:&header.center_lat_e7 length:sizeof(header.center_lat_e7)];
+
+  return [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
+}
+
+- (NSDictionary *)fetchMetadata {
+  NSString *metadata =
+      [self.sharedCache fetchMetadataWithSource:self.fetchSource];
+  if (metadata == nil) {
+    return nil;
+  }
+  // NSLog(@"metadata: %@", metadata);
+  return (NSDictionary *)[NSJSONSerialization
+      JSONObjectWithData:[metadata dataUsingEncoding:NSUTF8StringEncoding]
+                 options:NSJSONReadingMutableContainers
+                   error:nil];
+}
+
+- (headerv3)fetchHeader {
+  return [self.sharedCache getHeaderWithSource:self.fetchSource];
+}
+
+- (NSData *)getTileWithZ:(uint8_t)z x:(uint32_t)x y:(uint32_t)y {
+  uint64_t tileID = [PMTiles zxyToTileID:z x:x y:y];
+  headerv3 header = [self.sharedCache getHeaderWithSource:self.fetchSource];
+  if (header.tile_entries_count == 0) {
+    // NSLog(@"Error fetching header");
+    return nil;
+  }
+  uint64_t dirOffset = header.root_dir_offset;
+  uint32_t dirLength = header.root_dir_bytes;
+  for (int depth = 0; depth <= 3; depth++) {
+    NSData *dirData = [self.sharedCache getDirectoryWithSource:self.fetchSource
+                                                        offset:dirOffset
+                                                        length:dirLength];
+    if (dirData == nil) {
+      return nil;
+    }
+    NSData *decompressedData =
+        [Decompress decompress:dirData compression:header.internal_compression];
+
+    NSArray<NSValue *> *dirEntries =
+        [PMTiles deserializeDirectory:decompressedData];
+    EntryV3 entry = [VarintHelper findTile:dirEntries withTileID:tileID];
+
+    if (entry.length > 0) {
+      if (entry.run_length > 0) {
+        NSData *resp = [self.sharedCache
+            fetchTileWithSource:self.fetchSource
+                         offset:header.tile_data_offset + entry.offset
+                         length:entry.length];
+        NSData *decompressedData =
+            [Decompress decompress:resp compression:header.tile_compression];
+        return decompressedData;
+      } else {
+        dirOffset = header.leaf_dirs_offset + entry.offset;
+        dirLength = entry.length;
+      }
+    } else {
+      return nil;
+    }
+  }
+
+  return nil;
+}
+
+@end
+
+@implementation PMTilesMagicNumberException
+
+- (NSString *)what {
+  return @"pmtiles magic number exception";
+}
+
+@end
+@implementation PMTilesVersionException
+
+- (NSString *)what {
+  return @"pmtiles version: must be 3";
+}
+
+@end
+
+@implementation VarIntTooLongException
+
+- (NSString *)what {
+  return @"varint too long exception";
+}
+
+@end
+
+@implementation EndOfBufferException
+
+- (NSString *)what {
+  return @"end of buffer exception";
+}
+
+@end
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/SharedCache.h b/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/SharedCache.h
new file mode 100644
index 0000000..537df07
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/SharedCache.h
@@ -0,0 +1,18 @@
+#import "FetchSource.h"
+#import "Header.h"
+#import <Foundation/Foundation.h>
+@interface SharedCache : NSObject
+
+@property(nonatomic) headerv3 header;
+@property(nonatomic) BOOL isHeaderSet;
+@property(nonatomic, strong) NSMutableDictionary<NSString *, NSData *> *cache;
+- (headerv3)getHeaderWithSource:(FetchSource *)source;
+- (headerv3)fetchHeaderWithSource:(FetchSource *)source;
+- (NSData *)getDirectoryWithSource:(FetchSource *)source
+                            offset:(NSUInteger)offset
+                            length:(NSUInteger)length;
+- (NSData *)fetchTileWithSource:(FetchSource *)source
+                         offset:(NSUInteger)offset
+                         length:(NSUInteger)length;
+- (NSString *)fetchMetadataWithSource:(FetchSource *)source;
+@end
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/SharedCache.m b/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/SharedCache.m
new file mode 100644
index 0000000..83866f8
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/SharedCache.m
@@ -0,0 +1,150 @@
+#import "SharedCache.h"
+#import "Decompress.h"
+#import "PMTiles.h"
+
+@implementation SharedCache
+
+- (instancetype)init {
+  self = [super init];
+  self.cache = [NSMutableDictionary dictionary];
+  return self;
+}
+
+- (headerv3)getHeaderWithSource:(FetchSource *)source {
+  if (!self.isHeaderSet) {
+    self.header = [self fetchHeaderWithSource:source];
+    if (self.header.tile_entries_count == 0) {
+      return (headerv3){0};
+    }
+    self.isHeaderSet = YES;
+  }
+  return self.header;
+}
+
+- (headerv3)fetchHeaderWithSource:(FetchSource *)source {
+  __block NSError *fetchError = nil;
+  dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
+  __block headerv3 header;
+  [source getBytesWithOffset:0
+                      length:127
+                      signal:[NSProgress new]
+                  completion:^(NSDictionary *rangeResponse, NSError *error) {
+                    if (error) {
+                      // NSLog(@"Error: %@", error.localizedDescription);
+                      fetchError = error;
+                    } else {
+                      header =
+                          [PMTiles deserializeHeader:rangeResponse[@"data"]];
+                    }
+                    dispatch_semaphore_signal(semaphore);
+                  }];
+
+  dispatch_time_t timeout =
+      dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC));
+  long waitResult = dispatch_semaphore_wait(semaphore, timeout);
+  if (waitResult != 0) {
+    // NSLog(@"ヘッダーの取得がタイムアウトしました。");
+    return (headerv3){0};
+  }
+  if (fetchError) {
+    // ここでエラーを処理（ログ出力やnilを返すなど）
+    // NSLog(@"Error fetching tile: %@", [fetchError localizedDescription]);
+    return (headerv3){0};
+  }
+  return header;
+}
+
+- (NSData *)getDirectoryWithSource:(FetchSource *)source
+                            offset:(NSUInteger)offset
+                            length:(NSUInteger)length {
+  NSString *key =
+      [NSString stringWithFormat:@"%@-%lu-%lu", source.url, offset, length];
+  if (self.cache[key]) {
+    return self.cache[key];
+  } else {
+    self.cache[key] = [self fetchTileWithSource:source
+                                         offset:offset
+                                         length:length];
+    return self.cache[key];
+  }
+}
+- (NSData *)fetchTileWithSource:(FetchSource *)source
+                         offset:(NSUInteger)offset
+                         length:(NSUInteger)length {
+
+  dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
+  __block NSDictionary *rangeResponseResult;
+  __block NSError *fetchError = nil;
+
+  [source getBytesWithOffset:offset
+                      length:length
+                      signal:[NSProgress new]
+                  completion:^(NSDictionary *rangeResponse, NSError *error) {
+                    if (error) {
+                      fetchError = error;
+                    } else {
+                      rangeResponseResult = [rangeResponse copy];
+                    }
+                    dispatch_semaphore_signal(semaphore);
+                  }];
+
+  dispatch_time_t timeout =
+      dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC));
+  long waitResult = dispatch_semaphore_wait(semaphore, timeout);
+  if (waitResult != 0) {
+    // NSLog(@"タイルの取得がタイムアウトしました。");
+    return nil;
+  }
+
+  if (fetchError) {
+    // ここでエラーを処理（ログ出力やnilを返すなど）
+    // NSLog(@"Error fetching tile: %@", [fetchError localizedDescription]);
+    return nil;
+  }
+  NSData *tileData = rangeResponseResult[@"data"];
+  // 取得したデータを処理する
+  //   NSLog(@"ETag: %@", rangeResponseResult[@"etag"]);
+  //   NSLog(@"Cache-Control: %@", rangeResponseResult[@"cacheControl"]);
+  //   NSLog(@"Expires: %@", rangeResponseResult[@"expires"]);
+  //   NSLog(@"Data: %@", tileData);
+  return tileData;
+}
+
+- (NSString *)fetchMetadataWithSource:(FetchSource *)source {
+  // ヘッダーを取得
+  headerv3 header = [self getHeaderWithSource:source];
+  // メタデータの位置とサイズを取得
+  uint64_t offset = header.json_metadata_offset;
+  uint64_t length = header.json_metadata_bytes;
+  // NSLog(@"Metadata offset: %llu", offset);
+  // NSLog(@"Metadata length: %llu", length);
+  dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
+  __block NSString *metadata;
+  // メタデータを取得
+  [source getBytesWithOffset:offset
+                      length:length
+                      signal:[NSProgress new]
+                  completion:^(NSDictionary *rangeResponse, NSError *error) {
+                    if (error) {
+                      // NSLog(@"Error: %@", error.localizedDescription);
+                    } else {
+                      NSData *decompressedData =
+                          [Decompress decompress:rangeResponse[@"data"]
+                                     compression:header.internal_compression];
+                      metadata =
+                          [[NSString alloc] initWithData:decompressedData
+                                                encoding:NSUTF8StringEncoding];
+                    }
+                    dispatch_semaphore_signal(semaphore);
+                  }];
+
+  dispatch_time_t timeout =
+      dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC));
+  long waitResult = dispatch_semaphore_wait(semaphore, timeout);
+  if (waitResult != 0) {
+    // NSLog(@"メタデータの取得がタイムアウトしました。");
+    return nil;
+  }
+  return metadata;
+}
+@end
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/VarintHelper.h b/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/VarintHelper.h
new file mode 100644
index 0000000..0d6ff78
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/VarintHelper.h
@@ -0,0 +1,19 @@
+#import "PMTiles.h"
+#import <Foundation/Foundation.h>
+@interface VarintHelper : NSObject
+
++ (uint64_t)decodeVarintImpl:(const char **)data end:(const char *)end;
++ (uint64_t)decodeVarint:(const char **)data end:(const char *)end;
+
++ (void)rotate:(int64_t)n
+             x:(int64_t *)x
+             y:(int64_t *)y
+            rx:(int64_t)rx
+            ry:(int64_t)ry;
++ (ZXY)t_on_level:(uint8_t)z position:(uint64_t)pos;
++ (NSInteger)writeVarint:(NSMutableString *)data value:(uint64_t)value;
+
++ (NSComparisonResult)compareEntryZXY:(EntryZXY)a withEntryZXY:(EntryZXY)b;
++ (EntryV3)findTile:(NSArray<NSValue *> *)entries withTileID:(uint64_t)tileID;
+
+@end
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/VarintHelper.m b/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/VarintHelper.m
new file mode 100644
index 0000000..7a5b940
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/PMTiles/VarintHelper.m
@@ -0,0 +1,192 @@
+#import "VarintHelper.h"
+
+static const int8_t maxVarintLength = sizeof(uint64_t) * 8 / 7 + 1;
+
+@implementation VarintHelper
+
++ (uint64_t)decodeVarintImpl:(const char **)data end:(const char *)end {
+
+  const int8_t *begin = (const int8_t *)(*data);
+  const int8_t *iend = (const int8_t *)(end);
+  const int8_t *p = begin;
+  uint64_t val = 0;
+
+  if (iend - begin >= maxVarintLength) { // fast path
+    do {
+      int64_t b = *p++;
+      val = ((uint64_t)(b)&0x7fU);
+      if (b >= 0) {
+        break;
+      }
+      b = *p++;
+      val |= ((uint64_t)(b)&0x7fU) << 7U;
+      if (b >= 0) {
+        break;
+      }
+      b = *p++;
+      val |= ((uint64_t)(b)&0x7fU) << 14U;
+      if (b >= 0) {
+        break;
+      }
+      b = *p++;
+      val |= ((uint64_t)(b)&0x7fU) << 21U;
+      if (b >= 0) {
+        break;
+      }
+      b = *p++;
+      val |= ((uint64_t)(b)&0x7fU) << 28U;
+      if (b >= 0) {
+        break;
+      }
+      b = *p++;
+      val |= ((uint64_t)(b)&0x7fU) << 35U;
+      if (b >= 0) {
+        break;
+      }
+      b = *p++;
+      val |= ((uint64_t)(b)&0x7fU) << 42U;
+      if (b >= 0) {
+        break;
+      }
+      b = *p++;
+      val |= ((uint64_t)(b)&0x7fU) << 49U;
+      if (b >= 0) {
+        break;
+      }
+      b = *p++;
+      val |= ((uint64_t)(b)&0x7fU) << 56U;
+      if (b >= 0) {
+        break;
+      }
+      b = *p++;
+      val |= ((uint64_t)(b)&0x01U) << 63U;
+      if (b >= 0) {
+        break;
+      }
+      @throw [VarIntTooLongException new];
+    } while (false);
+  } else {
+    unsigned int shift = 0;
+    while (p != iend && *p < 0) {
+      val |= ((uint64_t)(*p++) & 0x7fU) << shift;
+      shift += 7;
+    }
+    if (p == iend) {
+      @throw [EndOfBufferException new];
+    }
+    val |= (uint64_t)(*p++) << shift;
+  }
+
+  *data = (const char *)(p);
+  return val;
+}
+
++ (uint64_t)decodeVarint:(const char **)data end:(const char *)end {
+  // If this is a one-byte varint, decode it here.
+  if (end != *data && (((uint64_t)(**data) & 0x80U) == 0)) {
+    const uint64_t val = (uint64_t)(**data);
+    ++(*data);
+    return val;
+  }
+  // If this varint is more than one byte, defer to complete implementation.
+  return [VarintHelper decodeVarintImpl:data end:end];
+}
+
++ (void)rotate:(int64_t)n
+             x:(int64_t *)x
+             y:(int64_t *)y
+            rx:(int64_t)rx
+            ry:(int64_t)ry {
+  if (ry == 0) {
+    if (rx == 1) {
+      *x = n - 1 - *x;
+      *y = n - 1 - *y;
+    }
+    int64_t t = *x;
+    *x = *y;
+    *y = t;
+  }
+}
+
++ (ZXY)t_on_level:(uint8_t)z position:(uint64_t)pos {
+  int64_t n = 1LL << z;
+  int64_t rx, ry, s, t = pos;
+  int64_t tx = 0;
+  int64_t ty = 0;
+  ZXY result;
+
+  for (s = 1; s < n; s *= 2) {
+    rx = 1LL & (t / 2);
+    ry = 1LL & (t ^ rx);
+    [VarintHelper rotate:s x:&tx y:&ty rx:rx ry:ry];
+    tx += s * rx;
+    ty += s * ry;
+    t /= 4;
+  }
+  result.z = z;
+  result.x = (uint32_t)tx;
+  result.y = (uint32_t)ty;
+
+  return result;
+}
+
++ (NSInteger)writeVarint:(NSMutableString *)data value:(uint64_t)value {
+  NSInteger n = 1;
+
+  while (value >= 0x80U) {
+    char byte = (char)((value & 0x7fU) | 0x80U);
+    NSString *appendStr = [NSString stringWithFormat:@"%c", byte];
+    [data appendString:appendStr];
+    value >>= 7U;
+    ++n;
+  }
+  char byte = (char)value;
+  NSString *appendStr = [NSString stringWithFormat:@"%c", byte];
+  [data appendString:appendStr];
+
+  return n;
+}
+
++ (NSComparisonResult)compareEntryZXY:(EntryZXY)a withEntryZXY:(EntryZXY)b {
+  if (a.z != b.z) {
+    return (a.z < b.z) ? NSOrderedAscending : NSOrderedDescending;
+  }
+  if (a.x != b.x) {
+    return (a.x < b.x) ? NSOrderedAscending : NSOrderedDescending;
+  }
+  return (a.y > b.y) ? NSOrderedAscending : NSOrderedDescending;
+}
+
++ (EntryV3)findTile:(NSArray<NSValue *> *)entries withTileID:(uint64_t)tileID {
+  NSInteger m = 0;
+  NSInteger n = [entries count] - 1;
+  while (m <= n) {
+    NSInteger k = (n + m) >> 1;
+    EntryV3 entryK;
+    [entries[k] getValue:&entryK];
+    int64_t cmp = tileID - entryK.tile_id;
+    if (cmp > 0) {
+      m = k + 1;
+    } else if (cmp < 0) {
+      n = k - 1;
+    } else {
+      return entryK;
+    }
+  }
+
+  if (n >= 0) {
+    EntryV3 entryN;
+    [entries[n] getValue:&entryN];
+    if (entryN.run_length == 0) {
+      return entryN;
+    }
+    if (tileID - entryN.tile_id < entryN.run_length) {
+      return entryN;
+    }
+  }
+
+  EntryV3 nullEntry = {0, 0, 0, 0};
+  return nullEntry;
+}
+
+@end
\ No newline at end of file
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/FeatureData.h b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/FeatureData.h
new file mode 100644
index 0000000..9bbdcc7
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/FeatureData.h
@@ -0,0 +1,10 @@
+#import <Foundation/Foundation.h>
+
+@interface FeatureData : NSObject
+
+@property(nonatomic, strong) NSDictionary<NSString *, NSString *> *attributes;
+@property(nonatomic, strong) id geometry;
+
+- (instancetype)initWithAttributes:(NSDictionary<NSString *, NSString *> *)attributes geometry:(id)geometry;
+
+@end
\ No newline at end of file
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/FeatureData.m b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/FeatureData.m
new file mode 100644
index 0000000..7a2eb28
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/FeatureData.m
@@ -0,0 +1,16 @@
+#import "FeatureData.h"
+
+@implementation FeatureData
+
+- (instancetype)initWithAttributes:
+                    (NSDictionary<NSString *, NSString *> *)attributes
+                          geometry:(id)geometry {
+  self = [super init];
+  if (self) {
+    _attributes = attributes;
+    _geometry = geometry;
+  }
+  return self;
+}
+
+@end
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/LineData.h b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/LineData.h
new file mode 100644
index 0000000..c4f077a
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/LineData.h
@@ -0,0 +1,14 @@
+#import <Foundation/Foundation.h>
+#import <UIKit/UIKit.h>
+
+@interface LineData : NSObject
+
+@property(nonatomic, strong) UIBezierPath *path;
+@property(nonatomic, assign) float centerX;
+@property(nonatomic, assign) float centerY;
+
+- (instancetype)initWithPath:(UIBezierPath *)path
+                     centerX:(float)centerX
+                     centerY:(float)centerY;
+
+@end
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/LineData.m b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/LineData.m
new file mode 100644
index 0000000..8373d8b
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/LineData.m
@@ -0,0 +1,18 @@
+#import "LineData.h"
+
+@implementation LineData
+
+- (instancetype)initWithPath:(UIBezierPath *)path
+                     centerX:(float)centerX
+                     centerY:(float)centerY {
+  self = [super
+      init]; // Now super works, because it refers to NSObject's init method
+  if (self) {
+    _path = path; // Assuming you've declared these in the header (.h) file
+    _centerX = centerX;
+    _centerY = centerY;
+  }
+  return self;
+}
+
+@end
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/PolygonData.h b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/PolygonData.h
new file mode 100644
index 0000000..e44e917
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/PolygonData.h
@@ -0,0 +1,12 @@
+// PolygonData.h
+#import <UIKit/UIKit.h>
+
+@interface PolygonData : NSObject
+
+@property(nonatomic, strong) UIBezierPath *path;
+@property(nonatomic, assign) float centerX;
+@property(nonatomic, assign) float centerY;
+
+- (instancetype)initWithPath:(UIBezierPath *)path centerX:(float)centerX centerY:(float)centerY;
+
+@end
\ No newline at end of file
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/PolygonData.m b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/PolygonData.m
new file mode 100644
index 0000000..9c2efc4
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/PolygonData.m
@@ -0,0 +1,18 @@
+// PolygonData.m
+#import "PolygonData.h"
+
+@implementation PolygonData
+
+- (instancetype)initWithPath:(UIBezierPath *)path
+                     centerX:(float)centerX
+                     centerY:(float)centerY {
+  self = [super init];
+  if (self) {
+    _path = path;
+    _centerX = centerX;
+    _centerY = centerY;
+  }
+  return self;
+}
+
+@end
\ No newline at end of file
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/StyleManager.h b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/StyleManager.h
new file mode 100644
index 0000000..4e6dab3
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/StyleManager.h
@@ -0,0 +1,16 @@
+#import <Foundation/Foundation.h>
+
+@interface StyleManager : NSObject
+
+// イニシャライザ
+- (instancetype)initWithURLTemplate:(NSString *)urlTemplate
+                      tileCachePath:(NSString *)tileCachePath
+                           styleURL:(NSString *)styleURL
+                        offlineMode:(BOOL)offlineMode;
+
+// スタイルレイヤー情報を返す
+- (NSArray *)getStyleLayers;
+- (NSArray *)getDefaultStyleLayersWithMetadata:(NSDictionary *)metadata;
+- (long long)getLastUpdatedTime;
+
+@end
\ No newline at end of file
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/StyleManager.m b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/StyleManager.m
new file mode 100644
index 0000000..acac68b
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/StyleManager.m
@@ -0,0 +1,368 @@
+#import "StyleManager.h"
+#import <Foundation/Foundation.h>
+
+@implementation StyleManager {
+  NSURL *_urlTemplate;
+  NSURL *_localPath;
+  NSURL *_tileCachePath;
+  NSArray *_styleLayers;
+  long long _lastUpdatedTime; // 最終更新時間（ミリ秒）
+  BOOL _offlineMode;
+}
+
+- (instancetype)initWithURLTemplate:(NSString *)urlTemplate
+                      tileCachePath:(NSString *)tileCachePath
+                           styleURL:(NSString *)styleURL
+                        offlineMode:(BOOL)offlineMode {
+  self = [super init];
+  if (self) {
+    // NSLog(@"##!urlTemplate: %@", urlTemplate);
+    NSString *trimmedStyleURL =
+        [styleURL stringByTrimmingCharactersInSet:[NSCharacterSet
+                                                      whitespaceCharacterSet]];
+    // NSLog(@"##!trimmedStyleURL: %@", trimmedStyleURL);
+    NSString *trimmedTileCachePath = [tileCachePath
+        stringByTrimmingCharactersInSet:[NSCharacterSet
+                                            whitespaceCharacterSet]];
+
+    if (trimmedStyleURL && ![trimmedStyleURL isEqualToString:@""]) {
+      // エンコードする
+      NSString *encodedURL =
+          [trimmedStyleURL stringByAddingPercentEncodingWithAllowedCharacters:
+                               [NSCharacterSet URLQueryAllowedCharacterSet]];
+      // NSLog(@"##!encodedURL: %@", encodedURL);
+      _urlTemplate = [NSURL URLWithString:encodedURL];
+    }
+    if (trimmedTileCachePath && ![trimmedTileCachePath isEqualToString:@""]) {
+      _localPath = [NSURL
+          URLWithString:[NSString stringWithFormat:@"%@/style.json",
+                                                   trimmedTileCachePath]];
+      _tileCachePath = [NSURL URLWithString:trimmedTileCachePath];
+    }
+    _lastUpdatedTime = 0;
+    _offlineMode = offlineMode;
+    // NSLog(@"##!_urlTemplate: %@", _urlTemplate);
+    [self loadStyle];
+  }
+  return self;
+}
+
+- (void)loadStyle {
+  NSError *error;
+  NSString *style = [NSString stringWithContentsOfFile:_localPath
+                                              encoding:NSUTF8StringEncoding
+                                                 error:&error];
+  //NSLog(@"##!style: %@", style);
+  if (_offlineMode) {
+    // オフラインモードの場合、ローカルにスタイルがない場合はデフォルトのスタイルを使用
+    if (!style || error) {
+      // NSLog(@"Failed to load style JSON: %@", [error localizedDescription]);
+      _styleLayers = @[];
+      return;
+    }
+    // NSLog(@"Loaded style JSON from local file");
+  } else {
+    // オンラインなら、スタイルをダウンロードする
+    NSString *styleData = [self downloadStyleJsonFromUrl:_urlTemplate];
+    if (styleData) {
+      // NSLog(@"Downloaded style JSON");
+      style = [self saveStyle:styleData
+                tileCachePath:_tileCachePath
+                    localPath:_localPath
+                        error:&error];
+
+      // スタイルの最終更新日時を取得して、_lastUpdatedTimeに設定
+      NSFileManager *fileManager = [NSFileManager defaultManager];
+      NSDictionary *fileAttributes =
+          [fileManager attributesOfItemAtPath:[_localPath path] error:nil];
+      NSDate *fileModificationDate = fileAttributes[NSFileModificationDate];
+      _lastUpdatedTime =
+          (long long)([fileModificationDate timeIntervalSince1970] * 1000.0);
+
+      error = nil;
+    } else {
+      // オンラインでスタイルのダウンロードに失敗した場合は、ローカルのスタイルがあればそれを使用。なければデフォルトのスタイルを使用。
+      if (!style || error) {
+        //NSLog(@"Failed to load style JSON");
+        _styleLayers = @[];
+        return;
+      }
+    }
+  }
+
+  // スタイルをパースして_styleLayersに設定
+  NSData *data = [style dataUsingEncoding:NSUTF8StringEncoding];
+  NSObject *parsedStyleLayers =
+      [NSJSONSerialization JSONObjectWithData:data
+                                      options:kNilOptions
+                                        error:&error];
+
+  //   for (NSDictionary *layer in parsedStyleLayers) {
+  //     NSLog(@"layer: %@", layer);
+  //   }
+
+  // パースが失敗した場合はデフォルトのスタイルを使用
+  if (error) {
+    NSLog(@"JSON parsing error: %@", [error localizedDescription]);
+    _styleLayers = @[];
+  } else if (![parsedStyleLayers isKindOfClass:[NSDictionary class]]) {
+    // NSLog(@"parsedStyleLayers: %@", parsedStyleLayers);
+    _styleLayers = @[];
+  } else {
+    NSDictionary *parsedStyleDictionary = (NSDictionary *)parsedStyleLayers;
+    if ([parsedStyleDictionary[@"layers"] isKindOfClass:[NSArray class]]) {
+      _styleLayers = parsedStyleDictionary[@"layers"];
+    } else {
+      _styleLayers = @[];
+    }
+  }
+  // NSLog(@"##_styleLayers: %@", _styleLayers);
+}
+
+- (NSString *)changeExtensionToJson:(NSString *)url {
+  return [url stringByReplacingOccurrencesOfString:@"\\.[^.]+$"
+                                        withString:@".json"
+                                           options:NSRegularExpressionSearch
+                                             range:NSMakeRange(0, url.length)];
+}
+
+- (NSString *)saveStyle:(NSString *)styleData
+          tileCachePath:(NSURL *)tileCachePath
+              localPath:(NSURL *)localPath
+                  error:(NSError **)error {
+
+  // NSLog(@"styleData: %@", styleData);
+  if (styleData) {
+    [self writeStyleData:tileCachePath
+        withStyleCacheFilePath:localPath
+                 withStyleData:styleData];
+
+    return styleData;
+  } else {
+    if (error) {
+
+      *error = [NSError
+          errorWithDomain:@"YourErrorDomain"
+                     code:100
+                 userInfo:@{
+                   NSLocalizedDescriptionKey : @"Failed to download style JSON"
+                 }];
+    }
+    return nil;
+  }
+}
+
+- (void)removeStyleFile {
+  NSFileManager *fileManager = [NSFileManager defaultManager];
+  NSError *error;
+  if ([fileManager fileExistsAtPath:[_localPath path]]) {
+    [fileManager removeItemAtPath:[_localPath path] error:&error];
+    if (error) {
+      // NSLog(@"Failed to remove style file: %@", [error
+      // localizedDescription]);
+      return;
+    }
+    // NSLog(@"Removed style file: %@", [_localPath path]);
+  }
+}
+
+- (void)writeStyleData:(NSURL *)tileCacheFileDirectory
+    withStyleCacheFilePath:(NSURL *)styleCacheFilePath
+             withStyleData:(NSString *)styleData {
+
+  NSError *error;
+  NSFileManager *fileManager = [NSFileManager defaultManager];
+
+  if (![fileManager fileExistsAtPath:[tileCacheFileDirectory path]]) {
+    [fileManager createDirectoryAtPath:[tileCacheFileDirectory path]
+           withIntermediateDirectories:YES
+                            attributes:nil
+                                 error:&error];
+    if (error) {
+      // NSLog(@"ディレクトリ作成エラー: %@", error.localizedDescription);
+      return;
+    }
+  }
+
+  NSString *existingStyle =
+      [NSString stringWithContentsOfFile:[styleCacheFilePath path]
+                                encoding:NSUTF8StringEncoding
+                                   error:nil];
+
+  if (existingStyle && [existingStyle isEqualToString:styleData]) {
+    // ファイルが変更されていない場合は、既存のファイルの最後の修正日を取得
+    NSDictionary *fileAttributes =
+        [fileManager attributesOfItemAtPath:[styleCacheFilePath path]
+                                      error:nil];
+    NSDate *fileModificationDate = fileAttributes[NSFileModificationDate];
+    _lastUpdatedTime =
+        (long long)([fileModificationDate timeIntervalSince1970]);
+  } else {
+    // NSLog(@"ファイル書き込み: %@", [styleCacheFilePath path]);
+    [styleData writeToFile:[styleCacheFilePath path]
+                atomically:YES
+                  encoding:NSUTF8StringEncoding
+                     error:&error];
+
+    if (error) {
+      // NSLog(@"ファイル書き込みエラー: %@", error.localizedDescription);
+      return;
+    }
+
+    _lastUpdatedTime = (long long)([[NSDate date] timeIntervalSince1970]);
+  }
+}
+
+- (NSString *)downloadStyleJsonFromUrl:(NSURL *)url {
+  __block NSString *responseString = nil;
+
+  // NSLog(@"##!downloadStyleJsonFromUrl: %@", url);
+  NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
+  [request setHTTPMethod:@"GET"];
+  [request setCachePolicy:NSURLRequestReloadIgnoringLocalCacheData];
+  dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
+
+  NSURLSessionDataTask *task = [[NSURLSession sharedSession]
+      dataTaskWithRequest:request
+        completionHandler:^(NSData *data, NSURLResponse *response,
+                            NSError *error) {
+          if (error) {
+            // NSLog(@"Failed to download style JSON: %@",
+            //       error.localizedDescription);
+          } else {
+            NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;
+
+            if (httpResponse.statusCode == 200) {
+              responseString =
+                  [[NSString alloc] initWithData:data
+                                        encoding:NSUTF8StringEncoding];
+            } else {
+              // NSLog(@"Bad response code: %ld",
+              // (long)httpResponse.statusCode);
+            }
+          }
+
+          dispatch_semaphore_signal(semaphore);
+        }];
+
+  [task resume];
+
+  dispatch_time_t timeout =
+      dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC));
+  long waitResult = dispatch_semaphore_wait(semaphore, timeout);
+  if (waitResult != 0) {
+    // NSLog(@"スタイルの取得がタイムアウトしました。");
+    return nil;
+  }
+
+  return responseString;
+}
+
+// 最終更新時間を取得するメソッドを追加
+- (long long)getLastUpdatedTime {
+  return _lastUpdatedTime;
+}
+
+- (NSArray *)getStyleLayers {
+  return _styleLayers;
+}
+
+- (NSArray *)getDefaultStyleLayersWithMetadata:(NSDictionary *)metadata {
+  // NSMutableArrayを作成して_styleLayersに割り当てる
+  NSMutableArray *styleLayers = [NSMutableArray array];
+
+  // metadataからvectorLayers配列を取得
+  NSArray *vectorLayers = metadata[@"vector_layers"];
+
+  // vectorLayersの各要素に対して処理
+  for (NSDictionary *layer in vectorLayers) {
+    // layerからidを取得
+    NSString *layerId = layer[@"id"];
+
+    // JSON文字列を作成
+    NSString *jsonString = [NSString
+        stringWithFormat:@"["
+                          "  {"
+                          "    \"id\": \"%@_fill\","
+                          "    \"type\": \"fill\","
+                          "    \"source\": \"example-source\","
+                          "    \"source-layer\": \"%@\","
+                          "    \"minzoom\": 0,"
+                          "    \"maxzoom\": 24,"
+                          "    \"paint\": {"
+                          "      \"fill-color\": \"#00FF00\","
+                          "      \"fill-outline-color\": \"#000000\","
+                          "      \"fill-opacity\": 0.5"
+                          "    }"
+                          "  },"
+                          "  {"
+                          "    \"id\": \"%@_stroke\","
+                          "    \"type\": \"line\","
+                          "    \"source\": \"example-source\","
+                          "    \"source-layer\": \"%@\","
+                          "    \"minzoom\": 0,"
+                          "    \"maxzoom\": 24,"
+                          "    \"paint\": {"
+                          "      \"line-color\": \"#0000FF\","
+                          "      \"line-width\": 1"
+                          "    }"
+                          "  },"
+                          "  {"
+                          "    \"id\": \"%@_point\","
+                          "    \"type\": \"circle\","
+                          "    \"source\": \"example-source\","
+                          "    \"source-layer\": \"%@\","
+                          "    \"minzoom\": 0,"
+                          "    \"maxzoom\": 24,"
+                          "    \"paint\": {"
+                          "      \"circle-color\": \"#FF0000\","
+                          "      \"circle-radius\": 3,"
+                          "      \"circle-stroke-width\": 1,"
+                          "      \"circle-stroke-color\": \"#FFFFFF\""
+                          "    }"
+                          "  }"
+                          "]",
+                         layerId, layerId, layerId, layerId, layerId, layerId];
+
+    // JSON文字列をNSDataに変換
+    NSData *jsonData = [jsonString dataUsingEncoding:NSUTF8StringEncoding];
+
+    // JSONデータをデコード
+    NSError *jsonError;
+    NSArray *newLayers = [NSJSONSerialization JSONObjectWithData:jsonData
+                                                         options:kNilOptions
+                                                           error:&jsonError];
+
+    // エラーチェック
+    if (jsonError) {
+      // NSLog(@"JSON Error: %@", jsonError.localizedDescription);
+    } else {
+      // newLayersをstyleLayersに追加
+      [styleLayers addObjectsFromArray:newLayers];
+    }
+  }
+  // styleLayersを文字列に変換
+  NSError *error;
+  NSData *jsonData =
+      [NSJSONSerialization dataWithJSONObject:styleLayers
+                                      options:NSJSONWritingPrettyPrinted
+                                        error:&error];
+
+  if (error) {
+    // NSLog(@"Error converting styleLayers to JSON: %@",
+    //       error.localizedDescription);
+    return @[]; // エラーの場合、空のJSONオブジェクトを返す
+  }
+
+  NSString *styleLayersString =
+      [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];
+  [self saveStyle:styleLayersString
+      tileCachePath:_tileCachePath
+          localPath:_localPath
+              error:&error];
+
+  //  結果を返す
+  return [styleLayers copy];
+}
+
+@end
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/UIColor+Hex.h b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/UIColor+Hex.h
new file mode 100644
index 0000000..ea61c9c
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/UIColor+Hex.h
@@ -0,0 +1,9 @@
+// UIColor+Hex.h
+#import <UIKit/UIKit.h>
+
+@interface UIColor (Hex)
+
++ (UIColor *)colorWithHexString:(NSString *)hexString;
++ (UIColor *)colorWithHexString:(NSString *)hexString alpha:(CGFloat)alpha;
+
+@end
\ No newline at end of file
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/UIColor+Hex.m b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/UIColor+Hex.m
new file mode 100644
index 0000000..80a2663
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/UIColor+Hex.m
@@ -0,0 +1,32 @@
+// UIColor+Hex.m
+#import "UIColor+Hex.h"
+
+@implementation UIColor (Hex)
+
++ (UIColor *)colorWithHexString:(NSString *)hexString {
+  return [self colorWithHexString:hexString alpha:1.0];
+}
+
++ (UIColor *)colorWithHexString:(NSString *)hexString alpha:(CGFloat)alpha {
+  unsigned int hex = 0;
+
+  // '#'を取り除く
+  NSString *cleanString = [hexString stringByReplacingOccurrencesOfString:@"#"
+                                                               withString:@""];
+
+  // NSScannerを使って16進数の解釈
+  NSScanner *scanner = [NSScanner scannerWithString:cleanString];
+  [scanner scanHexInt:&hex];
+
+  return [self colorFromHex:hex withAlpha:alpha];
+}
+
++ (UIColor *)colorFromHex:(unsigned int)hexValue withAlpha:(CGFloat)alpha {
+  CGFloat red = ((CGFloat)((hexValue & 0xFF0000) >> 16)) / 255.0;
+  CGFloat green = ((CGFloat)((hexValue & 0x00FF00) >> 8)) / 255.0;
+  CGFloat blue = ((CGFloat)((hexValue & 0x0000FF))) / 255.0;
+
+  return [UIColor colorWithRed:red green:green blue:blue alpha:alpha];
+}
+
+@end
\ No newline at end of file
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/VectorSource.h b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/VectorSource.h
new file mode 100644
index 0000000..48a559e
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/VectorSource.h
@@ -0,0 +1,11 @@
+#import <Foundation/Foundation.h>
+#import "FeatureData.h"
+
+@interface VectorSource : NSObject
+
+@property(nonatomic, strong) NSString *name;
+@property(nonatomic, strong) NSArray<FeatureData *> *features;
+
+- (instancetype)initWithName:(NSString *)name features:(NSArray<FeatureData *> *)features;
+
+@end
\ No newline at end of file
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/VectorSource.m b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/VectorSource.m
new file mode 100644
index 0000000..eabd444
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/VectorSource.m
@@ -0,0 +1,15 @@
+#import "VectorSource.h"
+
+@implementation VectorSource
+
+- (instancetype)initWithName:(NSString *)name
+                    features:(NSArray<FeatureData *> *)features {
+  self = [super init];
+  if (self) {
+    _name = name;
+    _features = features;
+  }
+  return self;
+}
+
+@end
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/VectorTile.pbobjc.h b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/VectorTile.pbobjc.h
new file mode 100644
index 0000000..f95b7db
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/VectorTile.pbobjc.h
@@ -0,0 +1,230 @@
+// Generated by the protocol buffer compiler.  DO NOT EDIT!
+// clang-format off
+// source: vector_tile.proto
+
+// This CPP symbol can be defined to use imports that match up to the framework
+// imports needed when using CocoaPods.
+#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
+ #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
+#endif
+
+#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
+ #import <Protobuf/GPBProtocolBuffers.h>
+#else
+ #import "GPBProtocolBuffers.h"
+#endif
+
+#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
+#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
+#endif
+#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
+#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
+#endif
+
+// @@protoc_insertion_point(imports)
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+
+CF_EXTERN_C_BEGIN
+
+@class Tile_Feature;
+@class Tile_Layer;
+@class Tile_Value;
+
+NS_ASSUME_NONNULL_BEGIN
+
+#pragma mark - Enum Tile_GeomType
+
+/** GeomType is described in section 4.3.4 of the specification */
+typedef GPB_ENUM(Tile_GeomType) {
+  Tile_GeomType_Unknown = 0,
+  Tile_GeomType_Point = 1,
+  Tile_GeomType_Linestring = 2,
+  Tile_GeomType_Polygon = 3,
+};
+
+GPBEnumDescriptor *Tile_GeomType_EnumDescriptor(void);
+
+/**
+ * Checks to see if the given value is defined by the enum or was not known at
+ * the time this source was generated.
+ **/
+BOOL Tile_GeomType_IsValidValue(int32_t value);
+
+#pragma mark - VectorTileRoot
+
+/**
+ * Exposes the extension registry for this file.
+ *
+ * The base class provides:
+ * @code
+ *   + (GPBExtensionRegistry *)extensionRegistry;
+ * @endcode
+ * which is a @c GPBExtensionRegistry that includes all the extensions defined by
+ * this file and all files that it depends on.
+ **/
+GPB_FINAL @interface VectorTileRoot : GPBRootObject
+@end
+
+#pragma mark - Tile
+
+typedef GPB_ENUM(Tile_FieldNumber) {
+  Tile_FieldNumber_LayersArray = 3,
+};
+
+GPB_FINAL @interface Tile : GPBMessage
+
+@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Tile_Layer*> *layersArray;
+/** The number of items in @c layersArray without causing the container to be created. */
+@property(nonatomic, readonly) NSUInteger layersArray_Count;
+
+@end
+
+#pragma mark - Tile_Value
+
+typedef GPB_ENUM(Tile_Value_FieldNumber) {
+  Tile_Value_FieldNumber_StringValue = 1,
+  Tile_Value_FieldNumber_FloatValue = 2,
+  Tile_Value_FieldNumber_DoubleValue = 3,
+  Tile_Value_FieldNumber_IntValue = 4,
+  Tile_Value_FieldNumber_UintValue = 5,
+  Tile_Value_FieldNumber_SintValue = 6,
+  Tile_Value_FieldNumber_BoolValue = 7,
+};
+
+/**
+ * Variant type encoding
+ * The use of values is described in section 4.1 of the specification
+ **/
+GPB_FINAL @interface Tile_Value : GPBMessage
+
+/** Exactly one of these values must be present in a valid message */
+@property(nonatomic, readwrite, copy, null_resettable) NSString *stringValue;
+/** Test to see if @c stringValue has been set. */
+@property(nonatomic, readwrite) BOOL hasStringValue;
+
+@property(nonatomic, readwrite) float floatValue;
+@property(nonatomic, readwrite) BOOL hasFloatValue;
+
+@property(nonatomic, readwrite) double doubleValue;
+@property(nonatomic, readwrite) BOOL hasDoubleValue;
+
+@property(nonatomic, readwrite) int64_t intValue;
+@property(nonatomic, readwrite) BOOL hasIntValue;
+
+@property(nonatomic, readwrite) uint64_t uintValue;
+@property(nonatomic, readwrite) BOOL hasUintValue;
+
+@property(nonatomic, readwrite) int64_t sintValue;
+@property(nonatomic, readwrite) BOOL hasSintValue;
+
+@property(nonatomic, readwrite) BOOL boolValue;
+@property(nonatomic, readwrite) BOOL hasBoolValue;
+
+@end
+
+#pragma mark - Tile_Feature
+
+typedef GPB_ENUM(Tile_Feature_FieldNumber) {
+  Tile_Feature_FieldNumber_Id_p = 1,
+  Tile_Feature_FieldNumber_TagsArray = 2,
+  Tile_Feature_FieldNumber_Type = 3,
+  Tile_Feature_FieldNumber_GeometryArray = 4,
+};
+
+/**
+ * Features are described in section 4.2 of the specification
+ **/
+GPB_FINAL @interface Tile_Feature : GPBMessage
+
+@property(nonatomic, readwrite) uint64_t id_p;
+@property(nonatomic, readwrite) BOOL hasId_p;
+
+/**
+ * Tags of this feature are encoded as repeated pairs of
+ * integers.
+ * A detailed description of tags is located in sections
+ * 4.2 and 4.4 of the specification
+ **/
+@property(nonatomic, readwrite, strong, null_resettable) GPBUInt32Array *tagsArray;
+/** The number of items in @c tagsArray without causing the container to be created. */
+@property(nonatomic, readonly) NSUInteger tagsArray_Count;
+
+/** The type of geometry stored in this feature. */
+@property(nonatomic, readwrite) Tile_GeomType type;
+@property(nonatomic, readwrite) BOOL hasType;
+
+/**
+ * Contains a stream of commands and parameters (vertices).
+ * A detailed description on geometry encoding is located in
+ * section 4.3 of the specification.
+ **/
+@property(nonatomic, readwrite, strong, null_resettable) GPBUInt32Array *geometryArray;
+/** The number of items in @c geometryArray without causing the container to be created. */
+@property(nonatomic, readonly) NSUInteger geometryArray_Count;
+
+@end
+
+#pragma mark - Tile_Layer
+
+typedef GPB_ENUM(Tile_Layer_FieldNumber) {
+  Tile_Layer_FieldNumber_Name = 1,
+  Tile_Layer_FieldNumber_FeaturesArray = 2,
+  Tile_Layer_FieldNumber_KeysArray = 3,
+  Tile_Layer_FieldNumber_ValuesArray = 4,
+  Tile_Layer_FieldNumber_Extent = 5,
+  Tile_Layer_FieldNumber_Version = 15,
+};
+
+/**
+ * Layers are described in section 4.1 of the specification
+ **/
+GPB_FINAL @interface Tile_Layer : GPBMessage
+
+/**
+ * Any compliant implementation must first read the version
+ * number encoded in this message and choose the correct
+ * implementation for this version number before proceeding to
+ * decode other parts of this message.
+ **/
+@property(nonatomic, readwrite) uint32_t version;
+@property(nonatomic, readwrite) BOOL hasVersion;
+
+@property(nonatomic, readwrite, copy, null_resettable) NSString *name;
+/** Test to see if @c name has been set. */
+@property(nonatomic, readwrite) BOOL hasName;
+
+/** The actual features in this tile. */
+@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Tile_Feature*> *featuresArray;
+/** The number of items in @c featuresArray without causing the container to be created. */
+@property(nonatomic, readonly) NSUInteger featuresArray_Count;
+
+/** Dictionary encoding for keys */
+@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NSString*> *keysArray;
+/** The number of items in @c keysArray without causing the container to be created. */
+@property(nonatomic, readonly) NSUInteger keysArray_Count;
+
+/** Dictionary encoding for values */
+@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Tile_Value*> *valuesArray;
+/** The number of items in @c valuesArray without causing the container to be created. */
+@property(nonatomic, readonly) NSUInteger valuesArray_Count;
+
+/**
+ * Although this is an "optional" field it is required by the specification.
+ * See https://github.com/mapbox/vector-tile-spec/issues/47
+ **/
+@property(nonatomic, readwrite) uint32_t extent;
+@property(nonatomic, readwrite) BOOL hasExtent;
+
+@end
+
+NS_ASSUME_NONNULL_END
+
+CF_EXTERN_C_END
+
+#pragma clang diagnostic pop
+
+// @@protoc_insertion_point(global_scope)
+
+// clang-format on
diff --git a/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/VectorTile.pbobjc.m b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/VectorTile.pbobjc.m
new file mode 100644
index 0000000..5595147
--- /dev/null
+++ b/node_modules/react-native-maps/ios/AirGoogleMaps/VectorTile/VectorTile.pbobjc.m
@@ -0,0 +1,464 @@
+// Generated by the protocol buffer compiler.  DO NOT EDIT!
+// clang-format off
+// source: vector_tile.proto
+
+// This CPP symbol can be defined to use imports that match up to the framework
+// imports needed when using CocoaPods.
+#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
+ #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
+#endif
+
+#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
+ #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
+#else
+ #import "GPBProtocolBuffers_RuntimeSupport.h"
+#endif
+
+#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
+#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
+#endif
+#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
+#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
+#endif
+
+#import <stdatomic.h>
+
+#import "VectorTile.pbobjc.h"
+// @@protoc_insertion_point(imports)
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"
+
+#pragma mark - Objective-C Class declarations
+// Forward declarations of Objective-C classes that we can use as
+// static values in struct initializers.
+// We don't use [Foo class] because it is not a static value.
+GPBObjCClassDeclaration(Tile);
+GPBObjCClassDeclaration(Tile_Feature);
+GPBObjCClassDeclaration(Tile_Layer);
+GPBObjCClassDeclaration(Tile_Value);
+
+#pragma mark - VectorTileRoot
+
+@implementation VectorTileRoot
+
+// No extensions in the file and no imports, so no need to generate
+// +extensionRegistry.
+
+@end
+
+static GPBFileDescription VectorTileRoot_FileDescription = {
+  .package = "vector_tile",
+  .prefix = NULL,
+  .syntax = GPBFileSyntaxProto2
+};
+
+#pragma mark - Enum Tile_GeomType
+
+GPBEnumDescriptor *Tile_GeomType_EnumDescriptor(void) {
+  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
+  if (!descriptor) {
+    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
+    static const char *valueNames =
+        "Unknown\000Point\000Linestring\000Polygon\000";
+    static const int32_t values[] = {
+        Tile_GeomType_Unknown,
+        Tile_GeomType_Point,
+        Tile_GeomType_Linestring,
+        Tile_GeomType_Polygon,
+    };
+    GPBEnumDescriptor *worker =
+        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Tile_GeomType)
+                                       valueNames:valueNames
+                                           values:values
+                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
+                                     enumVerifier:Tile_GeomType_IsValidValue
+                                            flags:GPBEnumDescriptorInitializationFlag_IsClosed];
+    GPBEnumDescriptor *expected = nil;
+    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
+      //[worker release];
+    }
+  }
+  return descriptor;
+}
+
+BOOL Tile_GeomType_IsValidValue(int32_t value__) {
+  switch (value__) {
+    case Tile_GeomType_Unknown:
+    case Tile_GeomType_Point:
+    case Tile_GeomType_Linestring:
+    case Tile_GeomType_Polygon:
+      return YES;
+    default:
+      return NO;
+  }
+}
+
+#pragma mark - Tile
+
+@implementation Tile
+
+@dynamic layersArray, layersArray_Count;
+
+typedef struct Tile__storage_ {
+  uint32_t _has_storage_[1];
+  NSMutableArray *layersArray;
+} Tile__storage_;
+
+// This method is threadsafe because it is initially called
+// in +initialize for each subclass.
++ (GPBDescriptor *)descriptor {
+  static GPBDescriptor *descriptor = nil;
+  if (!descriptor) {
+    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
+    static GPBMessageFieldDescription fields[] = {
+      {
+        .name = "layersArray",
+        .dataTypeSpecific.clazz = GPBObjCClass(Tile_Layer),
+        .number = Tile_FieldNumber_LayersArray,
+        .hasIndex = GPBNoHasBit,
+        .offset = (uint32_t)offsetof(Tile__storage_, layersArray),
+        .flags = GPBFieldRepeated,
+        .dataType = GPBDataTypeMessage,
+      },
+    };
+    GPBDescriptor *localDescriptor =
+        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Tile)
+                                   messageName:@"Tile"
+                               fileDescription:&VectorTileRoot_FileDescription
+                                        fields:fields
+                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
+                                   storageSize:sizeof(Tile__storage_)
+                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
+    static const GPBExtensionRange ranges[] = {
+      { .start = 16, .end = 8192 },
+    };
+    [localDescriptor setupExtensionRanges:ranges
+                                    count:(uint32_t)(sizeof(ranges) / sizeof(GPBExtensionRange))];
+    #if defined(DEBUG) && DEBUG
+      NSAssert(descriptor == nil, @"Startup recursed!");
+    #endif  // DEBUG
+    descriptor = localDescriptor;
+  }
+  return descriptor;
+}
+
+@end
+
+#pragma mark - Tile_Value
+
+@implementation Tile_Value
+
+@dynamic hasStringValue, stringValue;
+@dynamic hasFloatValue, floatValue;
+@dynamic hasDoubleValue, doubleValue;
+@dynamic hasIntValue, intValue;
+@dynamic hasUintValue, uintValue;
+@dynamic hasSintValue, sintValue;
+@dynamic hasBoolValue, boolValue;
+
+typedef struct Tile_Value__storage_ {
+  uint32_t _has_storage_[1];
+  float floatValue;
+  NSString *stringValue;
+  double doubleValue;
+  int64_t intValue;
+  uint64_t uintValue;
+  int64_t sintValue;
+} Tile_Value__storage_;
+
+// This method is threadsafe because it is initially called
+// in +initialize for each subclass.
++ (GPBDescriptor *)descriptor {
+  static GPBDescriptor *descriptor = nil;
+  if (!descriptor) {
+    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
+    static GPBMessageFieldDescription fields[] = {
+      {
+        .name = "stringValue",
+        .dataTypeSpecific.clazz = Nil,
+        .number = Tile_Value_FieldNumber_StringValue,
+        .hasIndex = 0,
+        .offset = (uint32_t)offsetof(Tile_Value__storage_, stringValue),
+        .flags = GPBFieldOptional,
+        .dataType = GPBDataTypeString,
+      },
+      {
+        .name = "floatValue",
+        .dataTypeSpecific.clazz = Nil,
+        .number = Tile_Value_FieldNumber_FloatValue,
+        .hasIndex = 1,
+        .offset = (uint32_t)offsetof(Tile_Value__storage_, floatValue),
+        .flags = GPBFieldOptional,
+        .dataType = GPBDataTypeFloat,
+      },
+      {
+        .name = "doubleValue",
+        .dataTypeSpecific.clazz = Nil,
+        .number = Tile_Value_FieldNumber_DoubleValue,
+        .hasIndex = 2,
+        .offset = (uint32_t)offsetof(Tile_Value__storage_, doubleValue),
+        .flags = GPBFieldOptional,
+        .dataType = GPBDataTypeDouble,
+      },
+      {
+        .name = "intValue",
+        .dataTypeSpecific.clazz = Nil,
+        .number = Tile_Value_FieldNumber_IntValue,
+        .hasIndex = 3,
+        .offset = (uint32_t)offsetof(Tile_Value__storage_, intValue),
+        .flags = GPBFieldOptional,
+        .dataType = GPBDataTypeInt64,
+      },
+      {
+        .name = "uintValue",
+        .dataTypeSpecific.clazz = Nil,
+        .number = Tile_Value_FieldNumber_UintValue,
+        .hasIndex = 4,
+        .offset = (uint32_t)offsetof(Tile_Value__storage_, uintValue),
+        .flags = GPBFieldOptional,
+        .dataType = GPBDataTypeUInt64,
+      },
+      {
+        .name = "sintValue",
+        .dataTypeSpecific.clazz = Nil,
+        .number = Tile_Value_FieldNumber_SintValue,
+        .hasIndex = 5,
+        .offset = (uint32_t)offsetof(Tile_Value__storage_, sintValue),
+        .flags = GPBFieldOptional,
+        .dataType = GPBDataTypeSInt64,
+      },
+      {
+        .name = "boolValue",
+        .dataTypeSpecific.clazz = Nil,
+        .number = Tile_Value_FieldNumber_BoolValue,
+        .hasIndex = 6,
+        .offset = 7,  // Stored in _has_storage_ to save space.
+        .flags = GPBFieldOptional,
+        .dataType = GPBDataTypeBool,
+      },
+    };
+    GPBDescriptor *localDescriptor =
+        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Tile_Value)
+                                   messageName:@"Value"
+                               fileDescription:&VectorTileRoot_FileDescription
+                                        fields:fields
+                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
+                                   storageSize:sizeof(Tile_Value__storage_)
+                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
+    static const GPBExtensionRange ranges[] = {
+      { .start = 8, .end = 536870912 },
+    };
+    [localDescriptor setupExtensionRanges:ranges
+                                    count:(uint32_t)(sizeof(ranges) / sizeof(GPBExtensionRange))];
+    [localDescriptor setupContainingMessageClass:GPBObjCClass(Tile)];
+    #if defined(DEBUG) && DEBUG
+      NSAssert(descriptor == nil, @"Startup recursed!");
+    #endif  // DEBUG
+    descriptor = localDescriptor;
+  }
+  return descriptor;
+}
+
+@end
+
+#pragma mark - Tile_Feature
+
+@implementation Tile_Feature
+
+@dynamic hasId_p, id_p;
+@dynamic tagsArray, tagsArray_Count;
+@dynamic hasType, type;
+@dynamic geometryArray, geometryArray_Count;
+
+typedef struct Tile_Feature__storage_ {
+  uint32_t _has_storage_[1];
+  Tile_GeomType type;
+  GPBUInt32Array *tagsArray;
+  GPBUInt32Array *geometryArray;
+  uint64_t id_p;
+} Tile_Feature__storage_;
+
+// This method is threadsafe because it is initially called
+// in +initialize for each subclass.
++ (GPBDescriptor *)descriptor {
+  static GPBDescriptor *descriptor = nil;
+  if (!descriptor) {
+    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
+    static GPBMessageFieldDescription fields[] = {
+      {
+        .name = "id_p",
+        .dataTypeSpecific.clazz = Nil,
+        .number = Tile_Feature_FieldNumber_Id_p,
+        .hasIndex = 0,
+        .offset = (uint32_t)offsetof(Tile_Feature__storage_, id_p),
+        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
+        .dataType = GPBDataTypeUInt64,
+      },
+      {
+        .name = "tagsArray",
+        .dataTypeSpecific.clazz = Nil,
+        .number = Tile_Feature_FieldNumber_TagsArray,
+        .hasIndex = GPBNoHasBit,
+        .offset = (uint32_t)offsetof(Tile_Feature__storage_, tagsArray),
+        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
+        .dataType = GPBDataTypeUInt32,
+      },
+      {
+        .name = "type",
+        .dataTypeSpecific.enumDescFunc = Tile_GeomType_EnumDescriptor,
+        .number = Tile_Feature_FieldNumber_Type,
+        .hasIndex = 1,
+        .offset = (uint32_t)offsetof(Tile_Feature__storage_, type),
+        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
+        .dataType = GPBDataTypeEnum,
+      },
+      {
+        .name = "geometryArray",
+        .dataTypeSpecific.clazz = Nil,
+        .number = Tile_Feature_FieldNumber_GeometryArray,
+        .hasIndex = GPBNoHasBit,
+        .offset = (uint32_t)offsetof(Tile_Feature__storage_, geometryArray),
+        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
+        .dataType = GPBDataTypeUInt32,
+      },
+    };
+    GPBDescriptor *localDescriptor =
+        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Tile_Feature)
+                                   messageName:@"Feature"
+                               fileDescription:&VectorTileRoot_FileDescription
+                                        fields:fields
+                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
+                                   storageSize:sizeof(Tile_Feature__storage_)
+                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
+    [localDescriptor setupContainingMessageClass:GPBObjCClass(Tile)];
+    #if defined(DEBUG) && DEBUG
+      NSAssert(descriptor == nil, @"Startup recursed!");
+    #endif  // DEBUG
+    descriptor = localDescriptor;
+  }
+  return descriptor;
+}
+
+@end
+
+#pragma mark - Tile_Layer
+
+@implementation Tile_Layer
+
+@dynamic hasVersion, version;
+@dynamic hasName, name;
+@dynamic featuresArray, featuresArray_Count;
+@dynamic keysArray, keysArray_Count;
+@dynamic valuesArray, valuesArray_Count;
+@dynamic hasExtent, extent;
+
+typedef struct Tile_Layer__storage_ {
+  uint32_t _has_storage_[1];
+  uint32_t extent;
+  uint32_t version;
+  NSString *name;
+  NSMutableArray *featuresArray;
+  NSMutableArray *keysArray;
+  NSMutableArray *valuesArray;
+} Tile_Layer__storage_;
+
+// This method is threadsafe because it is initially called
+// in +initialize for each subclass.
++ (GPBDescriptor *)descriptor {
+  static GPBDescriptor *descriptor = nil;
+  if (!descriptor) {
+    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
+    static GPBMessageFieldDescriptionWithDefault fields[] = {
+      {
+        .defaultValue.valueString = nil,
+        .core.name = "name",
+        .core.dataTypeSpecific.clazz = Nil,
+        .core.number = Tile_Layer_FieldNumber_Name,
+        .core.hasIndex = 1,
+        .core.offset = (uint32_t)offsetof(Tile_Layer__storage_, name),
+        .core.flags = GPBFieldRequired,
+        .core.dataType = GPBDataTypeString,
+      },
+      {
+        .defaultValue.valueMessage = nil,
+        .core.name = "featuresArray",
+        .core.dataTypeSpecific.clazz = GPBObjCClass(Tile_Feature),
+        .core.number = Tile_Layer_FieldNumber_FeaturesArray,
+        .core.hasIndex = GPBNoHasBit,
+        .core.offset = (uint32_t)offsetof(Tile_Layer__storage_, featuresArray),
+        .core.flags = GPBFieldRepeated,
+        .core.dataType = GPBDataTypeMessage,
+      },
+      {
+        .defaultValue.valueMessage = nil,
+        .core.name = "keysArray",
+        .core.dataTypeSpecific.clazz = Nil,
+        .core.number = Tile_Layer_FieldNumber_KeysArray,
+        .core.hasIndex = GPBNoHasBit,
+        .core.offset = (uint32_t)offsetof(Tile_Layer__storage_, keysArray),
+        .core.flags = GPBFieldRepeated,
+        .core.dataType = GPBDataTypeString,
+      },
+      {
+        .defaultValue.valueMessage = nil,
+        .core.name = "valuesArray",
+        .core.dataTypeSpecific.clazz = GPBObjCClass(Tile_Value),
+        .core.number = Tile_Layer_FieldNumber_ValuesArray,
+        .core.hasIndex = GPBNoHasBit,
+        .core.offset = (uint32_t)offsetof(Tile_Layer__storage_, valuesArray),
+        .core.flags = GPBFieldRepeated,
+        .core.dataType = GPBDataTypeMessage,
+      },
+      {
+        .defaultValue.valueUInt32 = 4096U,
+        .core.name = "extent",
+        .core.dataTypeSpecific.clazz = Nil,
+        .core.number = Tile_Layer_FieldNumber_Extent,
+        .core.hasIndex = 2,
+        .core.offset = (uint32_t)offsetof(Tile_Layer__storage_, extent),
+        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
+        .core.dataType = GPBDataTypeUInt32,
+      },
+      {
+        .defaultValue.valueUInt32 = 1U,
+        .core.name = "version",
+        .core.dataTypeSpecific.clazz = Nil,
+        .core.number = Tile_Layer_FieldNumber_Version,
+        .core.hasIndex = 0,
+        .core.offset = (uint32_t)offsetof(Tile_Layer__storage_, version),
+        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasDefaultValue),
+        .core.dataType = GPBDataTypeUInt32,
+      },
+    };
+    GPBDescriptor *localDescriptor =
+        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Tile_Layer)
+                                   messageName:@"Layer"
+                               fileDescription:&VectorTileRoot_FileDescription
+                                        fields:fields
+                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
+                                   storageSize:sizeof(Tile_Layer__storage_)
+                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
+    static const GPBExtensionRange ranges[] = {
+      { .start = 16, .end = 536870912 },
+    };
+    [localDescriptor setupExtensionRanges:ranges
+                                    count:(uint32_t)(sizeof(ranges) / sizeof(GPBExtensionRange))];
+    [localDescriptor setupContainingMessageClass:GPBObjCClass(Tile)];
+    #if defined(DEBUG) && DEBUG
+      NSAssert(descriptor == nil, @"Startup recursed!");
+    #endif  // DEBUG
+    descriptor = localDescriptor;
+  }
+  return descriptor;
+}
+
+@end
+
+
+#pragma clang diagnostic pop
+
+// @@protoc_insertion_point(global_scope)
+
+// clang-format on
diff --git a/node_modules/react-native-maps/ios/AirMaps/AIRMapUrlTileCachedOverlay.m b/node_modules/react-native-maps/ios/AirMaps/AIRMapUrlTileCachedOverlay.m
index 63d305c..bcfdcf2 100644
--- a/node_modules/react-native-maps/ios/AirMaps/AIRMapUrlTileCachedOverlay.m
+++ b/node_modules/react-native-maps/ios/AirMaps/AIRMapUrlTileCachedOverlay.m
@@ -12,224 +12,293 @@ @interface AIRMapUrlTileCachedOverlay ()
 @end
 
 @implementation AIRMapUrlTileCachedOverlay {
-    CIContext *_ciContext;
-    CGColorSpaceRef _colorspace;
-    NSURLSession *_urlSession;
+  CIContext *_ciContext;
+  CGColorSpaceRef _colorspace;
+  NSURLSession *_urlSession;
 }
 
-- (void)loadTileAtPath:(MKTileOverlayPath)path result:(void (^)(NSData *, NSError *))result
-{
-    if (!result) return;
-
-    NSInteger maximumZ = self.maximumNativeZ ? self.maximumNativeZ : path.z;
-    [self scaleIfNeededLowerZoomTile:path maximumZ:maximumZ result:^(NSData *image, NSError *error) {
-        if (!image && self.offlineMode && self.tileCachePath) {
-            NSInteger zoomLevelToStart = (path.z > maximumZ) ? maximumZ - 1 : path.z - 1; 
-            NSInteger minimumZoomToSearch = self.minimumZ >= zoomLevelToStart - 3 ? self.minimumZ : zoomLevelToStart - 3;
-            [self findLowerZoomTileAndScale:path tryZ:zoomLevelToStart minZ:minimumZoomToSearch result:result];
-        } else {
-            result(image, error);
-        }    
-    }];
+- (void)loadTileAtPath:(MKTileOverlayPath)path
+                result:(void (^)(NSData *, NSError *))result {
+  if (!result)
+    return;
+
+  NSInteger maximumZ = self.maximumNativeZ ? self.maximumNativeZ : path.z;
+  [self
+      scaleIfNeededLowerZoomTile:path
+                        maximumZ:maximumZ
+                          result:^(NSData *image, NSError *error) {
+                            if (!image && self.offlineMode &&
+                                self.tileCachePath) {
+                              NSInteger zoomLevelToStart = (path.z > maximumZ)
+                                                               ? maximumZ - 1
+                                                               : path.z - 1;
+                              NSInteger minimumZoomToSearch =
+                                  self.minimumZ >= zoomLevelToStart - 3
+                                      ? self.minimumZ
+                                      : zoomLevelToStart - 3;
+                              [self
+                                  findLowerZoomTileAndScale:path
+                                                       tryZ:zoomLevelToStart
+                                                       minZ:minimumZoomToSearch
+                                                     result:result];
+                            } else {
+                              result(image, error);
+                            }
+                          }];
 }
 
-- (void)scaleIfNeededLowerZoomTile:(MKTileOverlayPath)path maximumZ:(NSInteger)maximumZ result:(void (^)(NSData *, NSError *))result
-{
-    NSInteger overZoomLevel = path.z - maximumZ;
-    if (overZoomLevel <= 0) {
-        [self getTileImage:path result:result];
-        return;
-    }
+- (void)scaleIfNeededLowerZoomTile:(MKTileOverlayPath)path
+                          maximumZ:(NSInteger)maximumZ
+                            result:(void (^)(NSData *, NSError *))result {
+  NSInteger overZoomLevel = path.z - maximumZ;
+  if (overZoomLevel <= 0) {
+    [self getTileImage:path result:result];
+    return;
+  }
+
+  NSInteger zoomFactor = 1 << overZoomLevel;
+
+  MKTileOverlayPath parentTile;
+  parentTile.x = path.x >> overZoomLevel;
+  parentTile.y = path.y >> overZoomLevel;
+  parentTile.z = path.z - overZoomLevel;
+  parentTile.contentScaleFactor = path.contentScaleFactor;
+
+  NSInteger xOffset = path.x % zoomFactor;
+  NSInteger yOffset = path.y % zoomFactor;
+  NSInteger subTileSize = self.tileSize.width / zoomFactor;
+
+  if (!_ciContext)
+    _ciContext = [CIContext context];
+  if (!_colorspace)
+    _colorspace = CGColorSpaceCreateDeviceRGB();
+
+  [self getTileImage:parentTile
+              result:^(NSData *image, NSError *error) {
+                if (!image) {
+                  result(nil, nil);
+                  return;
+                }
 
-    NSInteger zoomFactor = 1 << overZoomLevel;
-    
-    MKTileOverlayPath parentTile;
-    parentTile.x = path.x >> overZoomLevel;
-    parentTile.y = path.y >> overZoomLevel;
-    parentTile.z = path.z - overZoomLevel;
-    parentTile.contentScaleFactor = path.contentScaleFactor;
-    
-    NSInteger xOffset = path.x % zoomFactor;
-    NSInteger yOffset = path.y % zoomFactor;
-    NSInteger subTileSize = self.tileSize.width / zoomFactor;
-
-    if (!_ciContext) _ciContext = [CIContext context];
-    if (!_colorspace) _colorspace = CGColorSpaceCreateDeviceRGB();
-
-    [self getTileImage:parentTile result:^(NSData *image, NSError *error) {
-        if (!image) {
-            result(nil, nil);
-            return;
-        }
-
-        CIImage* originalCIImage = [CIImage imageWithData:image];
-
-        CGRect rect;
-        rect.origin.x = xOffset * subTileSize;
-        rect.origin.y = self.tileSize.width - (yOffset + 1) * subTileSize;
-        rect.size.width = subTileSize;
-        rect.size.height = subTileSize;
-        CIVector *inputRect = [CIVector vectorWithCGRect:rect];
-        CIFilter* cropFilter = [CIFilter filterWithName:@"CICrop"];
-        [cropFilter setValue:originalCIImage forKey:@"inputImage"];
-        [cropFilter setValue:inputRect forKey:@"inputRectangle"];
-
-        CGAffineTransform trans = CGAffineTransformMakeScale(zoomFactor, zoomFactor);
-        CIImage* scaledCIImage = [cropFilter.outputImage imageByApplyingTransform:trans];
-
-        NSData *finalImage = [_ciContext PNGRepresentationOfImage:scaledCIImage format:kCIFormatABGR8 colorSpace:_colorspace options:nil];
-        result(finalImage, nil);
-    }];    
+                CIImage *originalCIImage = [CIImage imageWithData:image];
+
+                CGRect rect;
+                rect.origin.x = xOffset * subTileSize;
+                rect.origin.y =
+                    self.tileSize.width - (yOffset + 1) * subTileSize;
+                rect.size.width = subTileSize;
+                rect.size.height = subTileSize;
+                CIVector *inputRect = [CIVector vectorWithCGRect:rect];
+                CIFilter *cropFilter = [CIFilter filterWithName:@"CICrop"];
+                [cropFilter setValue:originalCIImage forKey:@"inputImage"];
+                [cropFilter setValue:inputRect forKey:@"inputRectangle"];
+
+                CGAffineTransform trans =
+                    CGAffineTransformMakeScale(zoomFactor, zoomFactor);
+                CIImage *scaledCIImage =
+                    [cropFilter.outputImage imageByApplyingTransform:trans];
+
+                NSData *finalImage =
+                    [_ciContext PNGRepresentationOfImage:scaledCIImage
+                                                  format:kCIFormatABGR8
+                                              colorSpace:_colorspace
+                                                 options:nil];
+                result(finalImage, nil);
+              }];
 }
 
-- (void)findLowerZoomTileAndScale:(MKTileOverlayPath)path tryZ:(NSInteger)tryZ minZ:(NSInteger)minZ result:(void (^)(NSData *, NSError *))result
-{
-    [self scaleIfNeededLowerZoomTile:path maximumZ:tryZ result:^(NSData *image, NSError *error) {
-        if (image) {
-            result(image, error);
-        } else if (tryZ >= minZ) {
-            [self findLowerZoomTileAndScale:path tryZ:tryZ - 1 minZ:minZ result:result];
-        } else {
-            result(nil, nil);
-        }
-    }];
+- (void)findLowerZoomTileAndScale:(MKTileOverlayPath)path
+                             tryZ:(NSInteger)tryZ
+                             minZ:(NSInteger)minZ
+                           result:(void (^)(NSData *, NSError *))result {
+  [self scaleIfNeededLowerZoomTile:path
+                          maximumZ:tryZ
+                            result:^(NSData *image, NSError *error) {
+                              if (image) {
+                                result(image, error);
+                              } else if (tryZ >= minZ) {
+                                [self findLowerZoomTileAndScale:path
+                                                           tryZ:tryZ - 1
+                                                           minZ:minZ
+                                                         result:result];
+                              } else {
+                                result(nil, nil);
+                              }
+                            }];
 }
 
-- (void)getTileImage:(MKTileOverlayPath)path result:(void (^)(NSData *, NSError *))result
-{
-    NSData *image;
-    NSURL *tileCacheFileDirectory = [NSURL URLWithString:[NSString stringWithFormat:@"%d/%d/", (int)path.z, (int)path.x] relativeToURL:self.tileCachePath];
-    NSURL *tileCacheFilePath = [NSURL URLWithString:[NSString stringWithFormat:@"%d", (int)path.y] relativeToURL:tileCacheFileDirectory];
-
-    if (self.tileCachePath) {
-        image = [self readTileImage:path fromFilePath:tileCacheFilePath];
-        if (image) {
-            result(image, nil);
-            if (!self.offlineMode && self.tileCacheMaxAge) {
-                [self checkForRefresh:path fromFilePath:tileCacheFilePath];
-            }
-        }
+- (void)getTileImage:(MKTileOverlayPath)path
+              result:(void (^)(NSData *, NSError *))result {
+  NSData *image;
+  NSURL *tileCacheFileDirectory =
+      [NSURL URLWithString:[NSString stringWithFormat:@"%d/%d/", (int)path.z,
+                                                      (int)path.x]
+             relativeToURL:self.tileCachePath];
+  NSURL *tileCacheFilePath =
+      [NSURL URLWithString:[NSString stringWithFormat:@"%d", (int)path.y]
+             relativeToURL:tileCacheFileDirectory];
+
+  if (self.tileCachePath) {
+    image = [self readTileImage:path fromFilePath:tileCacheFilePath];
+    if (image) {
+      result(image, nil);
+      if (!self.offlineMode && self.tileCacheMaxAge) {
+        [self checkForRefresh:path fromFilePath:tileCacheFilePath];
+      }
     }
-
-    if (!image) {
-        if (!self.offlineMode) {
-            [self fetchTile:path result:^(NSData *image, NSError *error) {
-                result(image, error);
-                if (image && self.tileCachePath) {
-                    [self writeTileImage:tileCacheFileDirectory withTileCacheFilePath:tileCacheFilePath withTileData:image];
-                }
-            }];
-        } else {
-            result(nil, nil);
-        }
+  }
+
+  if (!image) {
+    if (!self.offlineMode) {
+      [self fetchTile:path
+               result:^(NSData *image, NSError *error) {
+                 result(image, error);
+                 if (image && self.tileCachePath) {
+                   [self writeTileImage:tileCacheFileDirectory
+                       withTileCacheFilePath:tileCacheFilePath
+                                withTileData:image];
+                 }
+               }];
+    } else {
+      result(nil, nil);
     }
+  }
 }
 
-- (NSData *)readTileImage:(MKTileOverlayPath)path fromFilePath:(NSURL *)tileCacheFilePath
-{
-    NSError *error;
-
-    if ([[NSFileManager defaultManager] fileExistsAtPath:[tileCacheFilePath path]]) {
-        if (!self.tileCacheMaxAge) {
-            [[NSFileManager defaultManager] setAttributes:@{NSFileModificationDate:[NSDate date]}
-                            ofItemAtPath:[tileCacheFilePath path]
-                                    error:&error];
-        }
-
-        NSData *tile = [NSData dataWithContentsOfFile:[tileCacheFilePath path]];
-        NSLog(@"tileCache HIT for %d_%d_%d", (int)path.z, (int)path.x, (int)path.y);
-        NSLog(@"tileCache HIT, with max age set at %d", self.tileCacheMaxAge);
-        return tile;
-    } else {
-        NSLog(@"tileCache MISS for %d_%d_%d", (int)path.z, (int)path.x, (int)path.y);
-        return nil;
+- (NSData *)readTileImage:(MKTileOverlayPath)path
+             fromFilePath:(NSURL *)tileCacheFilePath {
+  NSError *error;
+
+  if ([[NSFileManager defaultManager]
+          fileExistsAtPath:[tileCacheFilePath path]]) {
+    if (!self.tileCacheMaxAge) {
+      [[NSFileManager defaultManager]
+          setAttributes:@{NSFileModificationDate : [NSDate date]}
+           ofItemAtPath:[tileCacheFilePath path]
+                  error:&error];
     }
+
+    NSData *tile = [NSData dataWithContentsOfFile:[tileCacheFilePath path]];
+    NSLog(@"tileCache HIT for %d_%d_%d", (int)path.z, (int)path.x, (int)path.y);
+    NSLog(@"tileCache HIT, with max age set at %d", self.tileCacheMaxAge);
+    return tile;
+  } else {
+    NSLog(@"tileCache MISS for %d_%d_%d", (int)path.z, (int)path.x,
+          (int)path.y);
+    return nil;
+  }
 }
 
-- (void)fetchTile:(MKTileOverlayPath)path result:(void (^)(NSData *, NSError *))result
-{
-    if (!_urlSession) [self createURLSession];
+- (void)fetchTile:(MKTileOverlayPath)path
+           result:(void (^)(NSData *, NSError *))result {
+  if (!_urlSession)
+    [self createURLSession];
 
-    [[_urlSession dataTaskWithURL:[self URLForTilePath:path]
-        completionHandler:^(NSData *data,
-                            NSURLResponse *response,
-                            NSError *error) {
-            result(data, error);
-        }] resume];
+  [[_urlSession dataTaskWithURL:[self URLForTilePath:path]
+              completionHandler:^(NSData *data, NSURLResponse *response,
+                                  NSError *error) {
+                result(data, error);
+              }] resume];
 }
 
-- (void)writeTileImage:(NSURL *)tileCacheFileDirectory withTileCacheFilePath:(NSURL *)tileCacheFilePath withTileData:(NSData *)data
-{
-    NSError *error;
-    
-    if (![[NSFileManager defaultManager] fileExistsAtPath:[tileCacheFileDirectory path]]) {
-        [[NSFileManager defaultManager] createDirectoryAtPath:[tileCacheFileDirectory path] withIntermediateDirectories:YES attributes:nil error:&error];
-        if (error) {
-            NSLog(@"Error: %@", error);
-            return;
-        }
+- (void)writeTileImage:(NSURL *)tileCacheFileDirectory
+    withTileCacheFilePath:(NSURL *)tileCacheFilePath
+             withTileData:(NSData *)data {
+  NSError *error;
+
+  if (![[NSFileManager defaultManager]
+          fileExistsAtPath:[tileCacheFileDirectory path]]) {
+    [[NSFileManager defaultManager]
+              createDirectoryAtPath:[tileCacheFileDirectory path]
+        withIntermediateDirectories:YES
+                         attributes:nil
+                              error:&error];
+    if (error) {
+      NSLog(@"Error: %@", error);
+      return;
     }
+  }
 
-    [[NSFileManager defaultManager] createFileAtPath:[tileCacheFilePath path] contents:data attributes:nil];
-    NSLog(@"tileCache SAVED tile %@", [tileCacheFilePath path]);
+  [[NSFileManager defaultManager] createFileAtPath:[tileCacheFilePath path]
+                                          contents:data
+                                        attributes:nil];
+  NSLog(@"tileCache SAVED tile %@", [tileCacheFilePath path]);
 }
 
-- (void)createTileCacheDirectory
-{
-    NSError *error;
-    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
-    NSString *documentsDirectory = [paths objectAtIndex:0];
-    NSString *tileCacheBaseDirectory = [NSString stringWithFormat:@"%@/tileCache", documentsDirectory];
-    self.tileCachePath = [NSURL fileURLWithPath:tileCacheBaseDirectory isDirectory:YES];
-    
-    if (![[NSFileManager defaultManager] fileExistsAtPath:[self.tileCachePath path]])
-        [[NSFileManager defaultManager] createDirectoryAtPath:[self.tileCachePath path] withIntermediateDirectories:NO attributes:nil error:&error];
+- (void)createTileCacheDirectory {
+  NSError *error;
+  NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,
+                                                       NSUserDomainMask, YES);
+  NSString *documentsDirectory = [paths objectAtIndex:0];
+  NSString *tileCacheBaseDirectory =
+      [NSString stringWithFormat:@"%@/tileCache", documentsDirectory];
+  self.tileCachePath = [NSURL fileURLWithPath:tileCacheBaseDirectory
+                                  isDirectory:YES];
+
+  if (![[NSFileManager defaultManager]
+          fileExistsAtPath:[self.tileCachePath path]])
+    [[NSFileManager defaultManager]
+              createDirectoryAtPath:[self.tileCachePath path]
+        withIntermediateDirectories:NO
+                         attributes:nil
+                              error:&error];
 }
 
-- (void)createURLSession
-{
- if (!_urlSession) {
-     _urlSession = [NSURLSession sharedSession];
- }
+- (void)createURLSession {
+  if (!_urlSession) {
+    _urlSession = [NSURLSession sharedSession];
+  }
 }
 
-- (void)checkForRefresh:(MKTileOverlayPath)path fromFilePath:(NSURL *)tileCacheFilePath
-{
-    if ([self doesFileNeedRefresh:path fromFilePath:tileCacheFilePath withMaxAge:self.tileCacheMaxAge]) {
-        dispatch_async(dispatch_get_global_queue(QOS_CLASS_UTILITY, 0), ^ {
-            // This code runs asynchronously!
-            if ([self doesFileNeedRefresh:path fromFilePath:tileCacheFilePath withMaxAge:self.tileCacheMaxAge]) {
-                if (!_urlSession) [self createURLSession];
-
-                [[_urlSession dataTaskWithURL:[self URLForTilePath:path]
-                    completionHandler:^(NSData *data,
-                                        NSURLResponse *response,
+- (void)checkForRefresh:(MKTileOverlayPath)path
+           fromFilePath:(NSURL *)tileCacheFilePath {
+  if ([self doesFileNeedRefresh:path
+                   fromFilePath:tileCacheFilePath
+                     withMaxAge:self.tileCacheMaxAge]) {
+    dispatch_async(dispatch_get_global_queue(QOS_CLASS_UTILITY, 0), ^{
+      // This code runs asynchronously!
+      if ([self doesFileNeedRefresh:path
+                       fromFilePath:tileCacheFilePath
+                         withMaxAge:self.tileCacheMaxAge]) {
+        if (!_urlSession)
+          [self createURLSession];
+
+        [[_urlSession dataTaskWithURL:[self URLForTilePath:path]
+                    completionHandler:^(NSData *data, NSURLResponse *response,
                                         NSError *error) {
-                    if (!error) {
-                        [[NSFileManager defaultManager] createFileAtPath:[tileCacheFilePath path] contents:data attributes:nil];
-                        NSLog(@"tileCache File refreshed at %@", [tileCacheFilePath path]);
-                    }
-                }] resume];             
-            }
-        });
-    }
+                      if (!error) {
+                        [[NSFileManager defaultManager]
+                            createFileAtPath:[tileCacheFilePath path]
+                                    contents:data
+                                  attributes:nil];
+                        NSLog(@"tileCache File refreshed at %@",
+                              [tileCacheFilePath path]);
+                      }
+                    }] resume];
+      }
+    });
+  }
 }
 
-- (BOOL)doesFileNeedRefresh:(MKTileOverlayPath)path fromFilePath:(NSURL *)tileCacheFilePath withMaxAge:(NSInteger)tileCacheMaxAge
-{
-    NSError *error;
-    NSDictionary<NSFileAttributeKey, id> *fileAttributes = [[NSFileManager defaultManager] attributesOfItemAtPath:[tileCacheFilePath path] error:&error]; 
-
-    if (fileAttributes) {
-        NSDate *modificationDate = fileAttributes[@"NSFileModificationDate"];
-        if (modificationDate) {
-            if (-1 * (int)modificationDate.timeIntervalSinceNow > tileCacheMaxAge) {
-                return YES;
-            }
-        }
+- (BOOL)doesFileNeedRefresh:(MKTileOverlayPath)path
+               fromFilePath:(NSURL *)tileCacheFilePath
+                 withMaxAge:(NSInteger)tileCacheMaxAge {
+  NSError *error;
+  NSDictionary<NSFileAttributeKey, id> *fileAttributes =
+      [[NSFileManager defaultManager]
+          attributesOfItemAtPath:[tileCacheFilePath path]
+                           error:&error];
+
+  if (fileAttributes) {
+    NSDate *modificationDate = fileAttributes[@"NSFileModificationDate"];
+    if (modificationDate) {
+      if (-1 * (int)modificationDate.timeIntervalSinceNow > tileCacheMaxAge) {
+        return YES;
+      }
     }
+  }
 
-    return NO;
+  return NO;
 }
 
 @end
diff --git a/node_modules/react-native-maps/lib/MapPMTile.d.ts b/node_modules/react-native-maps/lib/MapPMTile.d.ts
new file mode 100644
index 0000000..9c807d0
--- /dev/null
+++ b/node_modules/react-native-maps/lib/MapPMTile.d.ts
@@ -0,0 +1,140 @@
+import * as React from 'react';
+import { ProviderContext, NativeComponent, MapManagerCommand, UIManagerCommand } from './decorateMapComponent';
+import { ViewProps } from 'react-native';
+export type MapPMTileProps = ViewProps & {
+    /**
+     * Doubles tile size from 256 to 512 utilising higher zoom levels
+     * i.e loading 4 higher zoom level tiles and combining them for one high-resolution tile.
+     * iOS does this automatically, even if it is not desirable always.
+     * NB! using this makes text labels smaller than in the original map style.
+     *
+     * @platform iOS: Not supported
+     * @platform Android: Supported
+     */
+    doubleTileSize?: boolean;
+    /**
+     * Allow tiles using the TMS coordinate system (origin bottom left) to be used,
+     * and displayed at their correct coordinates.
+     *
+     * @platform iOS: Supported
+     * @platform Android: Supported
+     */
+    flipY?: boolean;
+    /**
+     * The maximum native zoom level for this tile overlay i.e. the highest zoom level that the tile server provides.
+     * Tiles are auto-scaled for higher zoom levels.
+     *
+     * @platform iOS: Apple Maps only
+     * @platform Android: Supported
+     */
+    maximumNativeZ?: number;
+    /**
+     * The maximum zoom level for this tile overlay.
+     *
+     * @platform iOS: Supported
+     * @platform Android: Supported
+     */
+    maximumZ?: number;
+    /**
+     * The minimum zoom level for this tile overlay.
+     *
+     * @platform iOS: Supported
+     * @platform Android: Supported
+     */
+    minimumZ?: number;
+    /**
+     * In offline-mode tiles are not fetched from the tile servers, rather only tiles stored in the cache directory are used.
+     * Furthermore automated tile scaling is activated: if tile at a desired zoom level is not found from the cache directory,
+     * then lower zoom level tile is used (up to 4 levels lower) and scaled.
+     *
+     * @default false
+     * @platform iOS: Apple Maps only
+     * @platform Android: Supported
+     */
+    offlineMode?: boolean;
+    /**
+     * Map layer opacity. Value between 0 - 1, with 0 meaning fully transparent.
+     *
+     * @platform iOS: Apple Maps only
+     * @platform Android: Supported
+     */
+    opacity?: number;
+    /**
+     * Corresponds to MKTileOverlay canReplaceMapContent i.e. if true then underlying iOS basemap is not shown.
+     *
+     * @default false
+     * @platform iOS: Apple Maps only
+     * @platform Android: Not supported
+     */
+    shouldReplaceMapContent?: boolean;
+    /**
+     * Defines maximum age in seconds for a cached tile before it's refreshed.
+     *
+     * NB! Refresh logic is "serve-stale-while-refresh"
+     * i.e. to ensure map availability a stale (over max age) tile is served
+     * while a tile refresh process is started in the background.
+     *
+     * @platform iOS: Apple Maps only
+     * @platform Android: Supported
+     */
+    tileCacheMaxAge?: number;
+    /**
+     * Enable caching of tiles in the specified directory.
+     * Directory can be specified either as a normal path or in URL format (`file://`).
+     *
+     * Tiles are stored in tileCachePath directory as `/{z}/{x}/{y}` i.e. in sub-directories 2-levels deep,
+     * filename is tile y-coordinate without any filetype-extension.
+     *
+     * NB! All cache management needs to be implemented by client e.g. deleting tiles to manage use of storage space etc.
+     *
+     * @platform iOS: Apple Maps only
+     * @platform Android: Supported
+     */
+    tileCachePath?: string;
+    /**
+     * Tile size, default size is 256 (for tiles of 256 _ 256 pixels).
+     * High-res (aka 'retina') tiles are 512 (tiles of 512 _ 512 pixels)
+     *
+     * @platform iOS: Apple Maps only
+     * @platform Android: Supported
+     */
+    tileSize?: number;
+    /**
+     * The url template of the map tileserver.
+     * (URLTile) The patterns {x} {y} {z} will be replaced at runtime.
+     * For example, http://c.tile.openstreetmap.org/{z}/{x}/{y}.png.
+     *
+     * It is also possible to refer to tiles in local filesystem with file:///top-level-directory/sub-directory/{z}/{x}/{y}.png URL-format.
+     * (WMSTile) The patterns {minX} {maxX} {minY} {maxY} {width} {height} will be replaced at runtime according to EPSG:900913 specification bounding box.
+     * For example, https://demo.geo-solutions.it/geoserver/tiger/wms?service=WMS&version=1.1.0&request=GetMap&layers=tiger:poi&styles=&bbox={minX},{minY},{maxX},{maxY}&width={width}&height={height}&srs=EPSG:900913&format=image/png&transparent=true&format_options=dpi:213.
+     *
+     * @platform iOS: Supported
+     * @platform Android: Supported
+     */
+    urlTemplate: string;
+    /**
+    * @platform iOS: Google Maps only
+    * @platform Android: Supported
+    * */
+    styleURL?: string;
+    /**
+     * The order in which this tile overlay is drawn with respect to other overlays.
+     * An overlay with a larger z-index is drawn over overlays with smaller z-indices.
+     * The order of overlays with the same z-index is arbitrary.
+     *
+     * @platform iOS: Google Maps only
+     * @platform Android: Supported
+     */
+    zIndex?: number;
+    isVector?: boolean;
+};
+type NativeProps = MapPMTileProps;
+export declare class MapPMTile extends React.Component<MapPMTileProps> {
+    context: React.ContextType<typeof ProviderContext>;
+    getNativeComponent: () => NativeComponent<NativeProps>;
+    getMapManagerCommand: (name: string) => MapManagerCommand;
+    getUIManagerCommand: (name: string) => UIManagerCommand;
+    render(): JSX.Element;
+}
+declare const _default: typeof MapPMTile;
+export default _default;
diff --git a/node_modules/react-native-maps/lib/MapPMTile.js b/node_modules/react-native-maps/lib/MapPMTile.js
new file mode 100644
index 0000000..2e5823b
--- /dev/null
+++ b/node_modules/react-native-maps/lib/MapPMTile.js
@@ -0,0 +1,44 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || function (mod) {
+    if (mod && mod.__esModule) return mod;
+    var result = {};
+    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
+    __setModuleDefault(result, mod);
+    return result;
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.MapPMTile = void 0;
+const React = __importStar(require("react"));
+const decorateMapComponent_1 = __importStar(require("./decorateMapComponent"));
+class MapPMTile extends React.Component {
+    getNativeComponent;
+    getMapManagerCommand;
+    getUIManagerCommand;
+    render() {
+        const AIRMapPMTile = this.getNativeComponent();
+        return <AIRMapPMTile {...this.props}/>;
+    }
+}
+exports.MapPMTile = MapPMTile;
+exports.default = (0, decorateMapComponent_1.default)(MapPMTile, 'PMTile', {
+    google: {
+        ios: decorateMapComponent_1.SUPPORTED,
+        android: decorateMapComponent_1.USES_DEFAULT_IMPLEMENTATION,
+    },
+});
diff --git a/node_modules/react-native-maps/lib/decorateMapComponent.d.ts b/node_modules/react-native-maps/lib/decorateMapComponent.d.ts
index 392c619..c67dbec 100644
--- a/node_modules/react-native-maps/lib/decorateMapComponent.d.ts
+++ b/node_modules/react-native-maps/lib/decorateMapComponent.d.ts
@@ -11,6 +11,7 @@ import { MapMarker } from './MapMarker';
 import { MapPolygon } from './MapPolygon';
 import { MapPolyline } from './MapPolyline';
 import { MapUrlTile } from './MapUrlTile';
+import { MapPMTile } from './MapPMTile';
 import { MapWMSTile } from './MapWMSTile';
 import { Commands } from './MapViewNativeComponent';
 export declare const SUPPORTED: ImplementationStatus;
@@ -31,6 +32,5 @@ type Providers = {
 export type UIManagerCommand = number;
 export type MapManagerCommand = keyof typeof Commands;
 export type NativeComponent<H = unknown> = HostComponent<H> | ReturnType<typeof createNotSupportedComponent>;
-type Component = typeof MapCallout | typeof MapCalloutSubview | typeof MapCircle | typeof MapHeatmap | typeof MapLocalTile | typeof MapMarker | typeof MapOverlay | typeof MapPolygon | typeof MapPolyline | typeof MapUrlTile | typeof MapWMSTile;
-type ComponentName = 'Callout' | 'CalloutSubview' | 'Circle' | 'Heatmap' | 'LocalTile' | 'Marker' | 'Overlay' | 'Polygon' | 'Polyline' | 'UrlTile' | 'WMSTile';
-export {};
+type Component = typeof MapCallout | typeof MapCalloutSubview | typeof MapCircle | typeof MapHeatmap | typeof MapLocalTile | typeof MapMarker | typeof MapOverlay | typeof MapPolygon | typeof MapPolyline | typeof MapUrlTile | typeof MapPMTile | typeof MapWMSTile;
+type ComponentName = 'Callout' | 'CalloutSubview' | 'Circle' | 'Heatmap' | 'LocalTile' | 'Marker' | 'Overlay' | 'Polygon' | 'Polyline' | 'UrlTile' | 'PMTile' | 'WMSTile';export {};
diff --git a/node_modules/react-native-maps/lib/index.d.ts b/node_modules/react-native-maps/lib/index.d.ts
index 8ecb17f..95c4335 100644
--- a/node_modules/react-native-maps/lib/index.d.ts
+++ b/node_modules/react-native-maps/lib/index.d.ts
@@ -15,6 +15,8 @@ export { default as Circle, MapCircle } from './MapCircle';
 export type { MapCircleProps } from './MapCircle';
 export { default as UrlTile, MapUrlTile } from './MapUrlTile';
 export type { MapUrlTileProps } from './MapUrlTile';
+export { default as PMTile, MapPMTile } from './MapPMTile';
+export type { MapPMTileProps } from './MapPMTile';
 export { default as WMSTile, MapWMSTile } from './MapWMSTile';
 export type { MapWMSTileProps } from './MapWMSTile';
 export { default as LocalTile, MapLocalTile } from './MapLocalTile';
diff --git a/node_modules/react-native-maps/lib/index.js b/node_modules/react-native-maps/lib/index.js
index ede2a1a..99f37fb 100644
--- a/node_modules/react-native-maps/lib/index.js
+++ b/node_modules/react-native-maps/lib/index.js
@@ -29,7 +29,7 @@ var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.OverlayAnimated = exports.MarkerAnimated = exports.MAP_TYPES = exports.Animated = exports.Overlay = exports.Marker = exports.Geojson = exports.AnimatedRegion = exports.MapCalloutSubview = exports.CalloutSubview = exports.MapCallout = exports.Callout = exports.MapLocalTile = exports.LocalTile = exports.MapWMSTile = exports.WMSTile = exports.MapUrlTile = exports.UrlTile = exports.MapCircle = exports.Circle = exports.MapPolygon = exports.Polygon = exports.MapHeatmap = exports.Heatmap = exports.MapPolyline = exports.Polyline = exports.MapOverlay = exports.MapMarker = void 0;
+exports.OverlayAnimated = exports.MarkerAnimated = exports.enableLatestRenderer = exports.MAP_TYPES = exports.Animated = exports.Overlay = exports.Marker = exports.Geojson = exports.AnimatedRegion = exports.MapCalloutSubview = exports.CalloutSubview = exports.MapCallout = exports.Callout = exports.MapLocalTile = exports.LocalTile = exports.MapWMSTile = exports.WMSTile = exports.MapPMTile = exports.PMTile = exports.MapUrlTile = exports.UrlTile = exports.MapCircle = exports.Circle = exports.MapPolygon = exports.Polygon = exports.MapHeatmap = exports.Heatmap = exports.MapPolyline = exports.Polyline = exports.MapOverlay = exports.MapMarker = void 0;
 const MapView_1 = __importStar(require("./MapView"));
 Object.defineProperty(exports, "Animated", { enumerable: true, get: function () { return MapView_1.AnimatedMapView; } });
 Object.defineProperty(exports, "MAP_TYPES", { enumerable: true, get: function () { return MapView_1.MAP_TYPES; } });
@@ -56,6 +56,9 @@ Object.defineProperty(exports, "MapCircle", { enumerable: true, get: function ()
 var MapUrlTile_1 = require("./MapUrlTile");
 Object.defineProperty(exports, "UrlTile", { enumerable: true, get: function () { return __importDefault(MapUrlTile_1).default; } });
 Object.defineProperty(exports, "MapUrlTile", { enumerable: true, get: function () { return MapUrlTile_1.MapUrlTile; } });
+var MapPMTile_1 = require("./MapPMTile");
+Object.defineProperty(exports, "PMTile", { enumerable: true, get: function () { return __importDefault(MapPMTile_1).default; } });
+Object.defineProperty(exports, "MapPMTile", { enumerable: true, get: function () { return MapPMTile_1.MapPMTile; } });
 var MapWMSTile_1 = require("./MapWMSTile");
 Object.defineProperty(exports, "WMSTile", { enumerable: true, get: function () { return __importDefault(MapWMSTile_1).default; } });
 Object.defineProperty(exports, "MapWMSTile", { enumerable: true, get: function () { return MapWMSTile_1.MapWMSTile; } });
diff --git a/node_modules/react-native-maps/react-native-google-maps.podspec b/node_modules/react-native-maps/react-native-google-maps.podspec
index 0745418..09a79ba 100644
--- a/node_modules/react-native-maps/react-native-google-maps.podspec
+++ b/node_modules/react-native-maps/react-native-google-maps.podspec
@@ -19,4 +19,10 @@ Pod::Spec.new do |s|
   s.dependency 'React-Core'
   s.dependency 'GoogleMaps', '7.4.0'
   s.dependency 'Google-Maps-iOS-Utils', '4.2.2'
+
+  s.dependency 'Protobuf'
+  s.subspec 'NonARCFiles' do |ss|
+    ss.source_files = "ios/AirGoogleMaps/VectorTile/VectorTile.pbobjc.m"
+    ss.compiler_flags = '-fno-objc-arc'
+  end
 end
