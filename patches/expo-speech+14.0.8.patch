diff --git a/node_modules/expo-speech/android/src/main/java/expo/modules/speech/SpeechModule.kt b/node_modules/expo-speech/android/src/main/java/expo/modules/speech/SpeechModule.kt
index 33b9587..d0251e1 100644
--- a/node_modules/expo-speech/android/src/main/java/expo/modules/speech/SpeechModule.kt
+++ b/node_modules/expo-speech/android/src/main/java/expo/modules/speech/SpeechModule.kt
@@ -64,7 +64,11 @@ class SpeechModule : Module() {
         throw SpeechInputIsToLongException()
       }
 
-      if (isTextToSpeechReady) {
+      // Check if TTS is disconnected and needs reinitialization
+      if (isTextToSpeechReady && !isTtsConnected()) {
+        delayedUtterances.add(Utterance(id, text, options))
+        reinitializeTts()
+      } else if (isTextToSpeechReady && isTtsConnected()) {
         speakOut(id, text, options)
       } else {
         delayedUtterances.add(Utterance(id, text, options))
@@ -100,12 +104,15 @@ class SpeechModule : Module() {
   }
 
   private fun speakOut(id: String, text: String, options: SpeechOptions) {
-    options.pitch?.let(textToSpeech::setPitch)
-    options.rate?.let(textToSpeech::setSpeechRate)
+    // Use _textToSpeech directly to ensure we use the current instance (may be reinitialized)
+    val tts = _textToSpeech ?: return
+
+    options.pitch?.let(tts::setPitch)
+    options.rate?.let(tts::setSpeechRate)
 
-    textToSpeech.language = options.language?.let {
+    tts.language = options.language?.let {
       val locale = Locale(it)
-      val languageAvailable = textToSpeech.isLanguageAvailable(locale)
+      val languageAvailable = tts.isLanguageAvailable(locale)
 
       return@let if (
         languageAvailable != TextToSpeech.LANG_MISSING_DATA &&
@@ -118,12 +125,12 @@ class SpeechModule : Module() {
     } ?: Locale.getDefault()
 
     options.voice?.let { voiceName ->
-      textToSpeech.voices
+      tts.voices
         .firstOrNull { it.name == voiceName }
-        ?.let(textToSpeech::setVoice)
+        ?.let(tts::setVoice)
     }
 
-    textToSpeech.speak(
+    tts.speak(
       text,
       TextToSpeech.QUEUE_ADD,
       null,
@@ -196,4 +203,61 @@ class SpeechModule : Module() {
   // do not refer to these - they're only needed when initializing `textToSpeech`
   private var _textToSpeech: TextToSpeech? = null
   private var _ttsReady = false
+
+  // Check if TTS engine is actually connected by testing a simple operation
+  private fun isTtsConnected(): Boolean {
+    return try {
+      // isLanguageAvailable returns -2 (LANG_NOT_SUPPORTED) when not connected
+      val result = _textToSpeech?.isLanguageAvailable(Locale.getDefault())
+      result != null && result != TextToSpeech.LANG_NOT_SUPPORTED
+    } catch (e: Exception) {
+      false
+    }
+  }
+
+  // Reinitialize TTS engine
+  private fun reinitializeTts() {
+    synchronized(this@SpeechModule) {
+      _ttsReady = false
+      _textToSpeech?.shutdown()
+      _textToSpeech = TextToSpeech(appContext.reactContext) { status: Int ->
+        if (status == TextToSpeech.SUCCESS) {
+          synchronized(this@SpeechModule) {
+            _ttsReady = true
+            _textToSpeech!!.setOnUtteranceProgressListener(object : UtteranceProgressListener() {
+              override fun onStart(utteranceId: String) {
+                sendEvent(speakingStartedEvent, idToMap(utteranceId))
+              }
+              override fun onRangeStart(utteranceId: String, start: Int, end: Int, frame: Int) {
+                val map = Bundle().apply {
+                  putString("id", utteranceId)
+                  putInt("charIndex", start)
+                  putInt("charLength", end - start)
+                }
+                sendEvent(speakingWillSayNextStringEvent, map)
+              }
+              override fun onDone(utteranceId: String) {
+                sendEvent(speakingDoneEvent, idToMap(utteranceId))
+              }
+              override fun onStop(utteranceId: String, interrupted: Boolean) {
+                sendEvent(speakingStoppedEvent, idToMap(utteranceId))
+              }
+              override fun onError(utteranceId: String) {
+                sendEvent(speakingErrorEvent, idToMap(utteranceId))
+              }
+            })
+            // Process any delayed utterances after TTS is fully connected
+            // Add a delay to ensure TTS engine is fully ready (engine needs time after callback)
+            val utterancesToProcess = delayedUtterances.toList()
+            delayedUtterances.clear()
+            android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({
+              for ((id, text, options) in utterancesToProcess) {
+                speakOut(id, text, options)
+              }
+            }, 500)
+          }
+        }
+      }
+    }
+  }
 }
